diff -urN linux-2.4.34/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.34/Documentation/Configure.help	2007-05-10 19:37:42.000000000 -0400
+++ linux/Documentation/Configure.help	2007-05-10 19:49:49.000000000 -0400
@@ -11341,6 +11341,11 @@
   <file:net/sched/sch_sfq.c> for details and references about the SFQ
   algorithm).
 
+  This is an enchanced SFQ version which allows you to control the
+  hardcoded values in the SFQ scheduler: queue depth, hash table size,
+  queues limit. Also adds control to the hash function used to identify
+  packet flows. Hash by src or dst ip and original sfq hash.
+
   This code is also available as a module called sch_sfq.o ( = code
   which can be inserted in and removed from the running kernel
   whenever you want). If you want to compile it as a module, say M
diff -urN linux-2.4.37/include/linux/pkt_sched.h linux/include/linux/pkt_sched.h
--- linux-2.4.37/include/linux/pkt_sched.h	2007-05-10 23:38:19.000000000 +0000
+++ linux/include/linux/pkt_sched.h	2009-09-28 13:33:49.000000000 +0000
@@ -157,6 +157,21 @@ enum
 
 /* SFQ section */
 
+enum
+{
+	/* traditional */
+	TCA_SFQ_HASH_CLASSIC,
+	TCA_SFQ_HASH_DST,
+	TCA_SFQ_HASH_SRC,
+	TCA_SFQ_HASH_FWMARK,
+	/* conntrack */
+	TCA_SFQ_HASH_CTORIGDST,
+	TCA_SFQ_HASH_CTORIGSRC,
+	TCA_SFQ_HASH_CTREPLDST,
+	TCA_SFQ_HASH_CTREPLSRC,
+	TCA_SFQ_HASH_CTNATCHG,
+};
+
 struct tc_sfq_qopt
 {
 	unsigned	quantum;	/* Bytes per round allocated to flow */
@@ -164,17 +179,9 @@ struct tc_sfq_qopt
 	__u32		limit;		/* Maximal packets in queue */
 	unsigned	divisor;	/* Hash divisor  */
 	unsigned	flows;		/* Maximal number of flows  */
+	unsigned	hash_kind;	/* Hash function to use for flow identification */
 };
 
-/*
- *  NOTE: limit, divisor and flows are hardwired to code at the moment.
- *
- *	limit=flows=128, divisor=1024;
- *
- *	The only reason for this is efficiency, it is possible
- *	to change these parameters in compile time.
- */
-
 /* RED section */
 
 enum
diff -urN linux-2.4.37/net/sched/sch_sfq.c linux/net/sched/sch_sfq.c
--- linux-2.4.37/net/sched/sch_sfq.c	2009-08-14 02:04:00.000000000 +0400
+++ linux/net/sched/sch_sfq.c	2009-09-28 18:34:49.000000000 +0400
@@ -1,5 +1,5 @@
 /*
- * net/sched/sch_sfq.c	Stochastic Fairness Queueing discipline.
+ * net/sched/sch_sfq.c	Extended Stochastic Fairness Queueing discipline.
  *
  *		This program is free software; you can redistribute it and/or
  *		modify it under the terms of the GNU General Public License
@@ -7,13 +7,26 @@
  *		2 of the License, or (at your option) any later version.
  *
  * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ *
+ * Changes:	Alexander Atanasov, <alex@ssi.bg>
+ *		Added dynamic depth,limit,divisor,hash_kind options.
+ *		Added dst and src hashes.
+ *
+ * 		Alexander Clouter, <alex@digriz.org.uk>
+ *		Ported ESFQ to Linux 2.6.
+ *
+ * 		Corey Hickey, <bugfood-c@fatooh.org>
+ *		Maintenance of the Linux 2.6 port.
+ *		Added fwmark hash (thanks to Robert Kurjata).
+ *		Added usage of jhash.
+ *		Added ctnatchg hash (thanks to Ben Pfountz).
  */
 
 #include <linux/config.h>
 #include <linux/module.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
-#include <asm/bitops.h>
+#include <linux/bitops.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
@@ -36,7 +49,14 @@
 #include <linux/skbuff.h>
 #include <net/sock.h>
 #include <net/pkt_sched.h>
+#include <linux/jhash.h>
 
+#define qdisc_priv(q)   ((void *)(q->data))
+
+#ifdef CONFIG_IP_NF_CONNTRACK
+/* #include <net/netfilter/nf_conntrack.h> */
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#endif
 
 /*	Stochastic Fairness Queuing algorithm.
 	=======================================
@@ -77,22 +97,27 @@
 	for the best effort traffic is absolutely pointless:
 	SFQ is superior for this purpose.
 
-	IMPLEMENTATION:
-	This implementation limits maximal queue length to 128;
-	maximal mtu to 2^15-1; number of hash buckets to 1024.
-	The only goal of this restrictions was that all data
-	fit into one 4K page :-). Struct sfq_sched_data is
-	organized in anti-cache manner: all the data for a bucket
-	are scattered over different locations. This is not good,
-	but it allowed me to put it into 4K.
+	The difference is that you can change limit, depth,
+	hash table size and choose alternate hash types.
 
-	It is easy to increase these values, but not in flight.  */
+	classic:	same as in sch_sfq.c
+	dst:		destination IP address
+	src:		source IP address
+	fwmark:		netfilter mark value
+	ctorigdst:	original destination IP address
+	ctorigsrc:	original source IP address
+	ctrepldst:	reply destination IP address
+	ctreplsrc:	reply source IP 
+	ctnatchg:	use the address which changed via nat
+	
+*/
+
+#define ESFQ_HEAD 0
+#define ESFQ_TAIL 1
 
-#define SFQ_DEPTH		128
-#define SFQ_HASH_DIVISOR	1024
 
 /* This type should contain at least SFQ_DEPTH*2 values */
-typedef unsigned char sfq_index;
+typedef unsigned int sfq_index;
 
 struct sfq_head
 {
@@ -106,70 +131,156 @@ struct sfq_sched_data
 	int		perturb_period;
 	unsigned	quantum;	/* Allotment per round: MUST BE >= MTU */
 	int		limit;
-
+	unsigned	depth;
+	unsigned	hash_divisor;
+	unsigned	hash_kind;
 /* Variables */
 	struct timer_list perturb_timer;
 	int		perturbation;
 	sfq_index	tail;		/* Index of current slot in round */
 	sfq_index	max_depth;	/* Maximal depth */
 
-	sfq_index	ht[SFQ_HASH_DIVISOR];	/* Hash table */
-	sfq_index	next[SFQ_DEPTH];	/* Active slots link */
-	short		allot[SFQ_DEPTH];	/* Current allotment per slot */
-	unsigned short	hash[SFQ_DEPTH];	/* Hash value indexed by slots */
-	struct sk_buff_head	qs[SFQ_DEPTH];		/* Slot queue */
-	struct sfq_head	dep[SFQ_DEPTH*2];	/* Linked list of slots, indexed by depth */
+	sfq_index	*ht;			/* Hash table */
+	sfq_index	*next;			/* Active slots link */
+	short		*allot;			/* Current allotment per slot */
+	unsigned short	*hash;			/* Hash value indexed by slots */
+	struct sk_buff_head	*qs;		/* Slot queue */
+	struct sfq_head	*dep;		/* Linked list of slots, indexed by depth */
 };
 
-static __inline__ unsigned sfq_fold_hash(struct sfq_sched_data *q, u32 h, u32 h1)
+/* This contains the info we will hash. */
+struct sfq_packet_info
 {
-	int pert = q->perturbation;
+	u32	proto;		/* protocol or port */
+	u32	src;		/* source from packet header */
+	u32	dst;		/* destination from packet header */
+	u32	ctorigsrc;	/* original source from conntrack */
+	u32	ctorigdst;	/* original destination from conntrack */
+	u32	ctreplsrc;	/* reply source from conntrack */
+	u32	ctrepldst;	/* reply destination from conntrack */
+	u32	mark;		/* netfilter mark (fwmark) */
+};
 
-	/* Have we any rotation primitives? If not, WHY? */
-	h ^= (h1<<pert) ^ (h1>>(0x1F - pert));
-	h ^= h>>10;
-	return h & 0x3FF;
+static __inline__ unsigned sfq_jhash_1word(struct sfq_sched_data *q,u32 a)
+{
+	return jhash_1word(a, q->perturbation) & (q->hash_divisor-1);
 }
 
+static __inline__ unsigned sfq_jhash_2words(struct sfq_sched_data *q, u32 a, u32 b)
+{
+	return jhash_2words(a, b, q->perturbation) & (q->hash_divisor-1);
+}
+
+static __inline__ unsigned sfq_jhash_3words(struct sfq_sched_data *q, u32 a, u32 b, u32 c)
+{
+	return jhash_3words(a, b, c, q->perturbation) & (q->hash_divisor-1);
+}
+
+
 static unsigned sfq_hash(struct sfq_sched_data *q, struct sk_buff *skb)
 {
-	u32 h, h2;
+	struct sfq_packet_info info;
+#ifdef CONFIG_IP_NF_CONNTRACK
+	enum ip_conntrack_info ctinfo;
+	struct ip_conntrack *ct = ip_conntrack_get(skb, &ctinfo);
+#endif
 
 	switch (skb->protocol) {
 	case __constant_htons(ETH_P_IP):
 	{
 		struct iphdr *iph = skb->nh.iph;
-		h = iph->daddr;
-		h2 = iph->saddr^iph->protocol;
+		info.dst = iph->daddr;
+		info.src = iph->saddr;
 		if (!(iph->frag_off&htons(IP_MF|IP_OFFSET)) &&
 		    (iph->protocol == IPPROTO_TCP ||
 		     iph->protocol == IPPROTO_UDP ||
+		     iph->protocol == IPPROTO_SCTP ||
+		     iph->protocol == IPPROTO_DCCP ||
 		     iph->protocol == IPPROTO_ESP))
-			h2 ^= *(((u32*)iph) + iph->ihl);
+			info.proto = *(((u32*)iph) + iph->ihl);
+		else
+			info.proto = iph->protocol;
 		break;
 	}
 	case __constant_htons(ETH_P_IPV6):
 	{
 		struct ipv6hdr *iph = skb->nh.ipv6h;
-		h = iph->daddr.s6_addr32[3];
-		h2 = iph->saddr.s6_addr32[3]^iph->nexthdr;
+		/* Hash ipv6 addresses into a u32. This isn't ideal,
+		 * but the code is simple. */
+		info.dst = jhash2(iph->daddr.s6_addr32, 4, q->perturbation);
+		info.src = jhash2(iph->saddr.s6_addr32, 4, q->perturbation);
 		if (iph->nexthdr == IPPROTO_TCP ||
 		    iph->nexthdr == IPPROTO_UDP ||
 		    iph->nexthdr == IPPROTO_ESP)
-			h2 ^= *(u32*)&iph[1];
+			info.proto = *(u32*)&iph[1];
+		else
+			info.proto = iph->nexthdr;
 		break;
 	}
 	default:
-		h = (u32)(unsigned long)skb->dst^skb->protocol;
-		h2 = (u32)(unsigned long)skb->sk;
+		info.dst   = (u32)(unsigned long)skb->dst;
+		info.src   = (u32)(unsigned long)skb->sk;
+		info.proto = skb->protocol;
 	}
-	return sfq_fold_hash(q, h, h2);
+
+#ifdef CONFIG_NETFILTER
+	info.mark = skb->nfmark;
+#endif
+
+#ifdef CONFIG_IP_NF_CONNTRACK
+	/* defaults if there is no conntrack info */
+	info.ctorigsrc = info.src;
+	info.ctorigdst = info.dst;
+	info.ctreplsrc = info.dst;
+	info.ctrepldst = info.src;
+	/* collect conntrack info */
+	IP_NF_ASSERT(ct);
+	if (ct) {
+		if (skb->protocol == __constant_htons(ETH_P_IP)) {
+			info.ctorigsrc = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.ip;
+			info.ctorigdst = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.ip;
+			info.ctreplsrc = ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.ip;
+			info.ctrepldst = ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.ip;
+		}
+	}
+#endif
+
+	switch(q->hash_kind) {
+	case TCA_SFQ_HASH_CLASSIC:
+		return sfq_jhash_3words(q, info.dst, info.src, info.proto);
+	case TCA_SFQ_HASH_DST:
+		return sfq_jhash_1word(q, info.dst);
+	case TCA_SFQ_HASH_SRC:
+		return sfq_jhash_1word(q, info.src);
+	case TCA_SFQ_HASH_FWMARK:
+		return sfq_jhash_1word(q, info.mark);
+#ifdef CONFIG_IP_NF_CONNTRACK
+	case TCA_SFQ_HASH_CTORIGDST:
+		return sfq_jhash_1word(q, info.ctorigdst);
+	case TCA_SFQ_HASH_CTORIGSRC:
+		return sfq_jhash_1word(q, info.ctorigsrc);
+	case TCA_SFQ_HASH_CTREPLDST:
+		return sfq_jhash_1word(q, info.ctrepldst);
+	case TCA_SFQ_HASH_CTREPLSRC:
+		return sfq_jhash_1word(q, info.ctreplsrc);
+	case TCA_SFQ_HASH_CTNATCHG:
+	{
+		if (info.ctorigdst == info.ctreplsrc)
+			return sfq_jhash_1word(q, info.ctorigsrc);
+		return sfq_jhash_1word(q, info.ctreplsrc);
+	}
+#endif
+	default:
+		if (net_ratelimit())
+			printk(KERN_WARNING "ESFQ: Unknown hash method. Falling back to classic.\n");
+	}
+	return sfq_jhash_3words(q, info.dst, info.src, info.proto);
 }
 
-extern __inline__ void sfq_link(struct sfq_sched_data *q, sfq_index x)
+static inline void sfq_link(struct sfq_sched_data *q, sfq_index x)
 {
 	sfq_index p, n;
-	int d = q->qs[x].qlen + SFQ_DEPTH;
+	int d = q->qs[x].qlen + q->depth;
 
 	p = d;
 	n = q->dep[d].next;
@@ -178,7 +289,7 @@ extern __inline__ void sfq_link(struct s
 	q->dep[p].next = q->dep[n].prev = x;
 }
 
-extern __inline__ void sfq_dec(struct sfq_sched_data *q, sfq_index x)
+static inline void sfq_dec(struct sfq_sched_data *q, sfq_index x)
 {
 	sfq_index p, n;
 
@@ -193,7 +304,7 @@ extern __inline__ void sfq_dec(struct sf
 	sfq_link(q, x);
 }
 
-extern __inline__ void sfq_inc(struct sfq_sched_data *q, sfq_index x)
+static inline void sfq_inc(struct sfq_sched_data *q, sfq_index x)
 {
 	sfq_index p, n;
 	int d;
@@ -211,7 +322,7 @@ extern __inline__ void sfq_inc(struct sf
 
 static unsigned int sfq_drop(struct Qdisc *sch)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 	sfq_index d = q->max_depth;
 	struct sk_buff *skb;
 	unsigned int len;
@@ -220,7 +331,7 @@ static unsigned int sfq_drop(struct Qdis
 	   drop a packet from it */
 
 	if (d > 1) {
-		sfq_index x = q->dep[d+SFQ_DEPTH].next;
+		sfq_index x = q->dep[d+q->depth].next;
 		skb = q->qs[x].prev;
 		len = skb->len;
 		__skb_unlink(skb, &q->qs[x]);
@@ -228,6 +339,7 @@ static unsigned int sfq_drop(struct Qdis
 		sfq_dec(q, x);
 		sch->q.qlen--;
 		sch->stats.drops++;
+		sch->stats.backlog -= len;
 		return len;
 	}
 
@@ -242,30 +354,33 @@ static unsigned int sfq_drop(struct Qdis
 		kfree_skb(skb);
 		sfq_dec(q, d);
 		sch->q.qlen--;
-		q->ht[q->hash[d]] = SFQ_DEPTH;
+		q->ht[q->hash[d]] = q->depth;
 		sch->stats.drops++;
+		sch->stats.backlog -= len;
 		return len;
 	}
 
 	return 0;
 }
 
-static int
-sfq_enqueue(struct sk_buff *skb, struct Qdisc* sch)
+static void sfq_q_enqueue(struct sk_buff *skb, struct sfq_sched_data *q, unsigned int end)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
 	unsigned hash = sfq_hash(q, skb);
+	unsigned depth = q->depth;
 	sfq_index x;
 
 	x = q->ht[hash];
-	if (x == SFQ_DEPTH) {
-		q->ht[hash] = x = q->dep[SFQ_DEPTH].next;
+	if (x == depth) {
+		q->ht[hash] = x = q->dep[depth].next;
 		q->hash[x] = hash;
 	}
-	__skb_queue_tail(&q->qs[x], skb);
+	if (end == ESFQ_TAIL)
+		__skb_queue_tail(&q->qs[x], skb);
+	else
+		__skb_queue_head(&q->qs[x], skb);
 	sfq_inc(q, x);
 	if (q->qs[x].qlen == 1) {		/* The flow is new */
-		if (q->tail == SFQ_DEPTH) {	/* It is the first flow */
+		if (q->tail == depth) {	/* It is the first flow */
 			q->tail = x;
 			q->next[x] = x;
 			q->allot[x] = q->quantum;
@@ -275,43 +390,33 @@ sfq_enqueue(struct sk_buff *skb, struct 
 			q->tail = x;
 		}
 	}
+}
+
+static int sfq_enqueue(struct sk_buff *skb, struct Qdisc* sch)
+{
+	struct sfq_sched_data *q = qdisc_priv(sch);
+	sfq_q_enqueue(skb, q, ESFQ_TAIL);
+	sch->stats.backlog += skb->len;
 	if (++sch->q.qlen < q->limit-1) {
 		sch->stats.bytes += skb->len;
 		sch->stats.packets++;
 		return 0;
 	}
 
+	sch->stats.drops++;
 	sfq_drop(sch);
 	return NET_XMIT_CN;
 }
 
-static int
-sfq_requeue(struct sk_buff *skb, struct Qdisc* sch)
+static int sfq_requeue(struct sk_buff *skb, struct Qdisc* sch)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
-	unsigned hash = sfq_hash(q, skb);
-	sfq_index x;
-
-	x = q->ht[hash];
-	if (x == SFQ_DEPTH) {
-		q->ht[hash] = x = q->dep[SFQ_DEPTH].next;
-		q->hash[x] = hash;
-	}
-	__skb_queue_head(&q->qs[x], skb);
-	sfq_inc(q, x);
-	if (q->qs[x].qlen == 1) {		/* The flow is new */
-		if (q->tail == SFQ_DEPTH) {	/* It is the first flow */
-			q->tail = x;
-			q->next[x] = x;
-			q->allot[x] = q->quantum;
-		} else {
-			q->next[x] = q->next[q->tail];
-			q->next[q->tail] = x;
-			q->tail = x;
-		}
-	}
-	if (++sch->q.qlen < q->limit - 1)
+	struct sfq_sched_data *q = qdisc_priv(sch);
+	sfq_q_enqueue(skb, q, ESFQ_HEAD);
+	sch->stats.backlog += skb->len;
+	if (++sch->q.qlen < q->limit - 1) {
+//2.6		sch->stats.requeues++;
 		return 0;
+	}
 
 	sch->stats.drops++;
 	sfq_drop(sch);
@@ -321,15 +426,14 @@ sfq_requeue(struct sk_buff *skb, struct 
 
 
 
-static struct sk_buff *
-sfq_dequeue(struct Qdisc* sch)
+static struct sk_buff *sfq_q_dequeue(struct sfq_sched_data *q)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
 	struct sk_buff *skb;
+	unsigned depth = q->depth;
 	sfq_index a, old_a;
 
 	/* No active slots */
-	if (q->tail == SFQ_DEPTH)
+	if (q->tail == depth)
 		return NULL;
 
 	a = old_a = q->next[q->tail];
@@ -337,14 +441,13 @@ sfq_dequeue(struct Qdisc* sch)
 	/* Grab packet */
 	skb = __skb_dequeue(&q->qs[a]);
 	sfq_dec(q, a);
-	sch->q.qlen--;
 
 	/* Is the slot empty? */
 	if (q->qs[a].qlen == 0) {
-		q->ht[q->hash[a]] = SFQ_DEPTH;
+		q->ht[q->hash[a]] = depth;
 		a = q->next[a];
 		if (a == old_a) {
-			q->tail = SFQ_DEPTH;
+			q->tail = depth;
 			return skb;
 		}
 		q->next[q->tail] = a;
@@ -357,8 +461,43 @@ sfq_dequeue(struct Qdisc* sch)
 	return skb;
 }
 
-static void
-sfq_reset(struct Qdisc* sch)
+static struct sk_buff *sfq_dequeue(struct Qdisc* sch)
+{
+	struct sfq_sched_data *q = qdisc_priv(sch);
+	struct sk_buff *skb;
+
+	skb = sfq_q_dequeue(q);
+	if (skb == NULL)
+		return NULL;
+	sch->q.qlen--;
+	sch->stats.backlog -= skb->len;
+	return skb;
+}
+
+static void sfq_q_destroy(struct sfq_sched_data *q)
+{
+	del_timer(&q->perturb_timer);
+	if(q->ht)
+		kfree(q->ht);
+	if(q->dep)
+		kfree(q->dep);
+	if(q->next)
+		kfree(q->next);
+	if(q->allot)
+		kfree(q->allot);
+	if(q->hash)
+		kfree(q->hash);
+	if(q->qs)
+		kfree(q->qs);
+}
+
+static void sfq_destroy(struct Qdisc *sch)
+{
+	struct sfq_sched_data *q = qdisc_priv(sch);
+	sfq_q_destroy(q);
+}
+
+static void sfq_reset(struct Qdisc* sch)
 {
 	struct sk_buff *skb;
 
@@ -369,10 +508,9 @@ sfq_reset(struct Qdisc* sch)
 static void sfq_perturbation(unsigned long arg)
 {
 	struct Qdisc *sch = (struct Qdisc*)arg;
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
+	struct sfq_sched_data *q = qdisc_priv(sch);
 
 	q->perturbation = net_random()&0x1F;
-	q->perturb_timer.expires = jiffies + q->perturb_period;
 
 	if (q->perturb_period) {
 		q->perturb_timer.expires = jiffies + q->perturb_period;
@@ -380,84 +518,180 @@ static void sfq_perturbation(unsigned lo
 	}
 }
 
-static int sfq_change(struct Qdisc *sch, struct rtattr *opt)
+static unsigned int sfq_check_hash(unsigned int kind)
+{
+	switch (kind) {
+	case TCA_SFQ_HASH_CTORIGDST:
+	case TCA_SFQ_HASH_CTORIGSRC:
+	case TCA_SFQ_HASH_CTREPLDST:
+	case TCA_SFQ_HASH_CTREPLSRC:
+	case TCA_SFQ_HASH_CTNATCHG:
+	case TCA_SFQ_HASH_CLASSIC:
+	case TCA_SFQ_HASH_DST:
+	case TCA_SFQ_HASH_SRC:
+	case TCA_SFQ_HASH_FWMARK:
+		return kind;
+	default:
+	{
+		if (net_ratelimit())
+			printk(KERN_WARNING "ESFQ: Unknown hash type. Falling back to classic.\n");
+		return TCA_SFQ_HASH_CLASSIC;
+	}
+	}
+}
+
+static int sfq_q_init(struct sfq_sched_data *q, struct rtattr *opt)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
 	struct tc_sfq_qopt *ctl = RTA_DATA(opt);
+	sfq_index p = ~0U/2;
+	int i;
 
-	if (opt->rta_len < RTA_LENGTH(sizeof(*ctl)))
+	if (opt && opt->rta_len < RTA_LENGTH(sizeof(*ctl)))
 		return -EINVAL;
 
-	sch_tree_lock(sch);
-	q->quantum = ctl->quantum ? : psched_mtu(sch->dev);
-	q->perturb_period = ctl->perturb_period*HZ;
-	if (ctl->limit)
-		q->limit = min_t(u32, ctl->limit, SFQ_DEPTH);
+	q->perturbation = 0;
+	q->hash_kind = TCA_SFQ_HASH_CLASSIC;
+	q->max_depth = 0;
+	if (opt == NULL) {
+		q->perturb_period = 0;
+		q->hash_divisor = 1024;
+		q->tail = q->limit = q->depth = 128;
 
-	while (sch->q.qlen >= q->limit-1)
-		sfq_drop(sch);
+	} else {
+		struct tc_sfq_qopt *ctl = RTA_DATA(opt);
+		if (ctl->quantum)
+			q->quantum = ctl->quantum;
+		q->perturb_period = ctl->perturb_period*HZ;
+		q->hash_divisor = ctl->divisor ? : 1024;
+		q->tail = q->limit = q->depth = ctl->flows ? : 128;
 
-	del_timer(&q->perturb_timer);
-	if (q->perturb_period) {
-		q->perturb_timer.expires = jiffies + q->perturb_period;
-		add_timer(&q->perturb_timer);
+		if ( q->depth > p - 1 )
+			return -EINVAL;
+
+		if (ctl->limit)
+			q->limit = min_t(u32, ctl->limit, q->depth);
+
+		if (ctl->hash_kind) {
+			q->hash_kind = sfq_check_hash(ctl->hash_kind);
+		}
 	}
-	sch_tree_unlock(sch);
+
+	q->ht = kmalloc(q->hash_divisor*sizeof(sfq_index), GFP_KERNEL);
+	if (!q->ht)
+		goto err_case;
+	q->dep = kmalloc((1+q->depth*2)*sizeof(struct sfq_head), GFP_KERNEL);
+	if (!q->dep)
+		goto err_case;
+	q->next = kmalloc(q->depth*sizeof(sfq_index), GFP_KERNEL);
+	if (!q->next)
+		goto err_case;
+	q->allot = kmalloc(q->depth*sizeof(short), GFP_KERNEL);
+	if (!q->allot)
+		goto err_case;
+	q->hash = kmalloc(q->depth*sizeof(unsigned short), GFP_KERNEL);
+	if (!q->hash)
+		goto err_case;
+	q->qs = kmalloc(q->depth*sizeof(struct sk_buff_head), GFP_KERNEL);
+	if (!q->qs)
+		goto err_case;
+
+	for (i=0; i< q->hash_divisor; i++)
+		q->ht[i] = q->depth;
+	for (i=0; i<q->depth; i++) {
+		skb_queue_head_init(&q->qs[i]);
+		q->dep[i+q->depth].next = i+q->depth;
+		q->dep[i+q->depth].prev = i+q->depth;
+	}
+
+	for (i=0; i<q->depth; i++)
+		sfq_link(q, i);
 	return 0;
+err_case:
+	sfq_q_destroy(q);
+	return -ENOBUFS;
 }
 
 static int sfq_init(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
-	int i;
+	struct sfq_sched_data *q = qdisc_priv(sch);
+	int err;
 
+	q->quantum = psched_mtu(sch->dev); /* default */
+	if ((err = sfq_q_init(q, opt)))
+		return err;
+
+	init_timer(&q->perturb_timer);
 	q->perturb_timer.data = (unsigned long)sch;
 	q->perturb_timer.function = sfq_perturbation;
-	init_timer(&q->perturb_timer);
-
-	for (i=0; i<SFQ_HASH_DIVISOR; i++)
-		q->ht[i] = SFQ_DEPTH;
-	for (i=0; i<SFQ_DEPTH; i++) {
-		skb_queue_head_init(&q->qs[i]);
-		q->dep[i+SFQ_DEPTH].next = i+SFQ_DEPTH;
-		q->dep[i+SFQ_DEPTH].prev = i+SFQ_DEPTH;
-	}
-	q->limit = SFQ_DEPTH;
-	q->max_depth = 0;
-	q->tail = SFQ_DEPTH;
-	if (opt == NULL) {
-		q->quantum = psched_mtu(sch->dev);
-		q->perturb_period = 0;
-	} else {
-		int err = sfq_change(sch, opt);
-		if (err)
-			return err;
+	if (q->perturb_period) {
+		q->perturb_timer.expires = jiffies + q->perturb_period;
+		add_timer(&q->perturb_timer);
 	}
-	for (i=0; i<SFQ_DEPTH; i++)
-		sfq_link(q, i);
-	MOD_INC_USE_COUNT;
+
 	return 0;
 }
 
-static void sfq_destroy(struct Qdisc *sch)
+static int sfq_change(struct Qdisc *sch, struct rtattr *opt)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
-	del_timer(&q->perturb_timer);
-	MOD_DEC_USE_COUNT;
+	struct sfq_sched_data *q = qdisc_priv(sch);
+	struct sfq_sched_data new;
+	struct sk_buff *skb;
+	int err;
+
+	/* set up new queue */
+	memset(&new, 0, sizeof(struct sfq_sched_data));
+	new.quantum = psched_mtu(sch->dev); /* default */
+	if ((err = sfq_q_init(&new, opt)))
+		return err;
+
+	/* copy all packets from the old queue to the new queue */
+	sch_tree_lock(sch);
+	while ((skb = sfq_q_dequeue(q)) != NULL)
+		sfq_q_enqueue(skb, &new, ESFQ_TAIL);
+
+	/* clean up the old queue */
+	sfq_q_destroy(q);
+
+	/* copy elements of the new queue into the old queue */
+	q->perturb_period = new.perturb_period;
+	q->quantum        = new.quantum;
+	q->limit          = new.limit;
+	q->depth          = new.depth;
+	q->hash_divisor   = new.hash_divisor;
+	q->hash_kind      = new.hash_kind;
+	q->tail           = new.tail;
+	q->max_depth      = new.max_depth;
+	q->ht    = new.ht;
+	q->dep   = new.dep;
+	q->next  = new.next;
+	q->allot = new.allot;
+	q->hash  = new.hash;
+	q->qs    = new.qs;
+
+	/* finish up */
+	if (q->perturb_period) {
+		q->perturb_timer.expires = jiffies + q->perturb_period;
+		add_timer(&q->perturb_timer);
+	} else {
+		q->perturbation = 0;
+	}
+	sch_tree_unlock(sch);
+	return 0;
 }
 
 static int sfq_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
-	struct sfq_sched_data *q = (struct sfq_sched_data *)sch->data;
-	unsigned char	 *b = skb->tail;
+	struct sfq_sched_data *q = qdisc_priv(sch);
+	unsigned char *b = skb->tail;
 	struct tc_sfq_qopt opt;
 
 	opt.quantum = q->quantum;
 	opt.perturb_period = q->perturb_period/HZ;
 
 	opt.limit = q->limit;
-	opt.divisor = SFQ_HASH_DIVISOR;
-	opt.flows = q->limit;
+	opt.divisor = q->hash_divisor;
+	opt.flows = q->depth;
+	opt.hash_kind = q->hash_kind;
 
 	RTA_PUT(skb, TCA_OPTIONS, sizeof(opt), &opt);
 
@@ -470,33 +704,31 @@ rtattr_failure:
 
 struct Qdisc_ops sfq_qdisc_ops =
 {
-	NULL,
-	NULL,
-	"sfq",
-	sizeof(struct sfq_sched_data),
-
-	sfq_enqueue,
-	sfq_dequeue,
-	sfq_requeue,
-	sfq_drop,
-
-	sfq_init,
-	sfq_reset,
-	sfq_destroy,
-	NULL, /* sfq_change */
-
-	sfq_dump,
+	.next		=	NULL,
+	.cl_ops		=	NULL,
+	.id		=	"sfq",
+	.priv_size	=	sizeof(struct sfq_sched_data),
+	.enqueue	=	sfq_enqueue,
+	.dequeue	=	sfq_dequeue,
+	.requeue	=	sfq_requeue,
+	.drop		=	sfq_drop,
+	.init		=	sfq_init,
+	.reset		=	sfq_reset,
+	.destroy	=	sfq_destroy,
+	.change		=	sfq_change,
+	.dump		=	sfq_dump,
 };
 
 #ifdef MODULE
-int init_module(void)
+static int __init sfq_module_init(void)
 {
 	return register_qdisc(&sfq_qdisc_ops);
 }
-
-void cleanup_module(void) 
+static void __exit sfq_module_exit(void)
 {
 	unregister_qdisc(&sfq_qdisc_ops);
 }
+module_init(sfq_module_init)
+module_exit(sfq_module_exit)
 #endif
 MODULE_LICENSE("GPL");
