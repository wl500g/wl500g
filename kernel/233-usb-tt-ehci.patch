[patch 2.6.17-rc4-git] improved TT scheduling for EHCI
Date: Wed, 24 May 2006 09:39:16 -0700

This updates the EHCI driver by adding an improved scheduler for the
transaction translators, found in USB 2.0 hubs and used for low and
full speed devices.

 - adds periodic_tt_usecs() and some helper functions, which does
   the same thing that "periodic_usecs" does, except on the other
   side of the TT, i.e.  it calculates the low/fullspeed bandwidth
   usage instead of highspeed.

 - adds a tt_available() function which is the new implementation 
   of what tt_no_collision() does ... while tt_no_collision() ensures
   that each TT handles only 1 periodic transfer at a time (a very
   pessimistic approach) this version instead tracks bandwidth and
   allows each TT to handle as many transfers as will fit on each TT's
   downstream bus (closer to best-case).

The new scheduler is selected by a config option, marked as EXPERIMENTAL
so it can be tested (and more broadly reviewed) for a while until it
seems safe to remove the original scheduler.

Signed-off-by: Dan Streetman <ddstreet@ieee.org>
Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

Backported from 2.6.27 to 2.4 branch by: Lisovskiy Leonid <lly@sf.net>

 Documentation/Configure.help  |   15 +
 drivers/usb/host/Config.in    |    1 
 drivers/usb/host/ehci-q.c     |    7 
 drivers/usb/host/ehci-sched.c |  518 ++++++++++++++++++++++++++++++++++--------
 drivers/usb/host/ehci.h       |    7 
 drivers/usb/hub.c             |   32 +-
 drivers/usb/hub.h             |    6 
 include/linux/usb.h           |    1 
 8 files changed, 484 insertions(+), 103 deletions(-)

---
diff -urbB linux-2.4.37.orig/Documentation/Configure.help linux/Documentation/Configure.help
--- linux-2.4.37.orig/Documentation/Configure.help	2009-01-14 14:29:40.000000000 +0300
+++ linux/Documentation/Configure.help	2009-01-16 13:14:18.000000000 +0300
@@ -15313,6 +15313,21 @@
   The module will be called ehci-hcd.o. If you want to compile it as a
   module, say M here and read <file:Documentation/modules.txt>.
 
+Improved Transaction Translator scheduling (EXPERIMENTAL)
+CONFIG_USB_EHCI_TT_NEWSCHED
+  This changes the periodic scheduling code to fill more of the low
+  and full speed bandwidth available from the Transaction Translator
+  (TT) in USB 2.0 hubs.  Without this, only one transfer will be
+  issued in each microframe, significantly reducing the number of
+  periodic low/fullspeed transfers possible.
+
+  If you have multiple periodic low/fullspeed devices connected to a
+  highspeed USB hub which is connected to a highspeed USB Host
+  Controller, and some of those devices will not work correctly
+  (possibly due to "ENOSPC" or "-28" errors), say Y.
+
+  If unsure, say N.
+
 UHCI (Intel PIIX4, VIA, ...) support
 CONFIG_USB_UHCI
   The Universal Host Controller Interface is a standard by Intel for
diff -urbBp linux-2.4.37.orig/drivers/usb/host/Config.in linux/drivers/usb/host/Config.in
--- linux-2.4.37.orig/drivers/usb/host/Config.in	2008-12-02 11:01:34.000000000 +0300
+++ linux/drivers/usb/host/Config.in	2009-01-16 12:47:37.000000000 +0300
@@ -3,6 +3,7 @@
 #
 comment 'USB Host Controller Drivers'
 dep_tristate '  EHCI HCD (USB 2.0) support (EXPERIMENTAL)' CONFIG_USB_EHCI_HCD $CONFIG_USB $CONFIG_EXPERIMENTAL
+dep_mbool    '  Improved Transaction Translator scheduling (EXPERIMENTAL)' CONFIG_USB_EHCI_TT_NEWSCHED $CONFIG_USB_EHCI_HCD $CONFIG_USB $CONFIG_EXPERIMENTAL
 if [ "$CONFIG_USB_UHCI_ALT" != "y" ]; then
    dep_tristate '  UHCI (Intel PIIX4, VIA, ...) support' CONFIG_USB_UHCI $CONFIG_USB
 fi
diff -urbB linux-2.4.37.orig/include/linux/usb.h linux/include/linux/usb.h
--- linux-2.4.37.orig/include/linux/usb.h	2008-12-02 11:01:34.000000000 +0300
+++ linux/include/linux/usb.h	2009-01-16 13:29:35.000000000 +0300
@@ -806,6 +806,7 @@
 struct usb_tt {
 	struct usb_device	*hub;	/* upstream highspeed hub */
 	int			multi;	/* true means one TT per port */
+	unsigned		think_time;	/* think time in ns */
 };
 
 
diff -uBp linux-2.4.37.orig/drivers/usb/hub.h linux/drivers/usb/hub.h
--- linux-2.4.37.orig/drivers/usb/hub.h	2008-12-15 16:35:51.000000000 +0300
+++ linux/drivers/usb/hub.h	2009-01-22 10:19:27.000000000 +0300
@@ -120,6 +120,12 @@
 
 struct usb_device;
 
+/* Transaction Translator Think Times, in bits */
+#define HUB_TTTT_8_BITS         0x00
+#define HUB_TTTT_16_BITS        0x20
+#define HUB_TTTT_24_BITS        0x40
+#define HUB_TTTT_32_BITS        0x60
+
 struct usb_hub {
 	struct usb_device *dev;
 
diff -uBp linux-2.4.37.orig/drivers/usb/hub.c linux/drivers/usb/hub.c
--- linux-2.4.37.orig/drivers/usb/hub.c	2009-01-22 10:14:54.000000000 +0300
+++ linux/drivers/usb/hub.c	2009-01-22 10:26:03.000000000 +0300
@@ -230,19 +230,33 @@ static int usb_hub_configure(struct usb_
 			break;
 	}
 
+	/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */
 	switch (hub->descriptor->wHubCharacteristics & HUB_CHAR_TTTT) {
-		case 0x00:
-			if (dev->descriptor.bDeviceProtocol != 0)
-				dbg("TT requires at most 8 FS bit times");
+		case HUB_TTTT_8_BITS:
+			if (dev->descriptor.bDeviceProtocol != 0) {
+				hub->tt.think_time = 666;
+				dbg("TT requires at most %d "
+						"FS bit times (%d ns)\n",
+					8, hub->tt.think_time);
+			}
 			break;
-		case 0x20:
-			dbg("TT requires at most 16 FS bit times");
+		case HUB_TTTT_16_BITS:
+			hub->tt.think_time = 666 * 2;
+			dbg("TT requires at most %d "
+					"FS bit times (%d ns)\n",
+				16, hub->tt.think_time);
 			break;
-		case 0x40:
-			dbg("TT requires at most 24 FS bit times");
+		case HUB_TTTT_24_BITS:
+			hub->tt.think_time = 666 * 3;
+			dbg("TT requires at most %d "
+					"FS bit times (%d ns)\n",
+				24, hub->tt.think_time);
 			break;
-		case 0x60:
-			dbg("TT requires at most 32 FS bit times");
+		case HUB_TTTT_32_BITS:
+			hub->tt.think_time = 666 * 4;
+			dbg("TT requires at most %d "
+					"FS bit times (%d ns)\n",
+				32, hub->tt.think_time);
 			break;
 	}
 
diff -urBp linux-2.4.37.orig/drivers/usb/host/ehci.h linux/drivers/usb/host/ehci.h
--- linux-2.4.37.orig/drivers/usb/host/ehci.h	2008-12-02 11:01:34.000000000 +0300
+++ linux/drivers/usb/host/ehci.h	2009-01-18 12:45:16.000000000 +0300
@@ -348,6 +349,11 @@ struct ehci_qh {
 	u32			hw_info1;        /* see EHCI 3.6.2 */
 #define	QH_HEAD		0x00008000
 	u32			hw_info2;        /* see EHCI 3.6.2 */
+#define QH_SMASK        0x000000ff
+#define QH_CMASK        0x0000ff00
+#define QH_HUBADDR      0x007f0000
+#define QH_HUBPORT      0x3f800000
+#define QH_MULT         0xc0000000
 	u32			hw_current;	 /* qtd list - see EHCI 3.6.4 */
 	
 	/* qtd overlay (hardware parts of a struct ehci_qtd) */
@@ -378,6 +384,7 @@ struct ehci_qh {
 	u8			usecs;		/* intr bandwidth */
 	u8			gap_uf;		/* uframes split/csplit gap */
 	u8			c_usecs;	/* ... split completion bw */
+	u16                     tt_usecs;       /* tt downstream bandwidth */
 	unsigned short		period;		/* polling interval */
 	unsigned short		start;		/* where polling starts */
 #define NO_FRAME ((unsigned short)~0)			/* pick new start */
@@ -430,7 +436,9 @@ struct ehci_iso_stream {
 	 */
 	u8			interval;
 	u8			usecs;		
+	u16			tt_usecs;
 	u16			maxp;
+	u16			raw_mask;
 	unsigned		bandwidth;
 
 	/* This is used to initialize iTD's hw_bufp fields */
@@ -504,6 +512,7 @@ struct ehci_sitd {
 	dma_addr_t		sitd_dma;
 	union ehci_shadow	sitd_next;	/* ptr to periodic q entry */
 	struct urb		*urb;
+	struct ehci_iso_stream	*stream;	/* endpoint's queue */
 	dma_addr_t		buf_dma;	/* buffer address */
 
 	unsigned short		usecs;		/* start bandwidth */
diff -urbBp linux-2.4.37.orig/drivers/usb/host/ehci-q.c linux/drivers/usb/host/ehci-q.c
--- linux-2.4.37.orig/drivers/usb/host/ehci-q.c	2008-12-15 11:27:43.000000000 +0300
+++ linux/drivers/usb/host/ehci-q.c	2009-01-16 13:35:28.000000000 +0300
@@ -280,6 +280,9 @@ ehci_urb_done (struct ehci_hcd *ehci, st
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
+static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh, int wait0);
+static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh); 
+
 /*
  * Process and free completed qtds for a qh, returning URBs to drivers.
  * Chases up to qh->hw_current.  Returns number of completions called,
@@ -429,7 +432,23 @@ qh_completions(
 			qh_refresh(ehci, qh);
 			break;
 		case QH_STATE_LINKED:
-			unlink_async (ehci, qh);
+			/* We won't refresh a QH that's linked (after the HC
+			 * stopped the queue).  That avoids a race:
+			 *  - HC reads first part of QH;
+			 *  - CPU updates that first part and the token;
+			 *  - HC reads rest of that QH, including token
+			 * Result:  HC gets an inconsistent image, and then
+			 * DMAs to/from the wrong memory (corrupting it).
+			 *
+			 * That should be rare for interrupt transfers,
+			 * except maybe high bandwidth ...
+			 */
+			if ((__constant_cpu_to_le32(QH_SMASK)
+					& qh->hw_info2) != 0) {
+				intr_deschedule (ehci, qh, 0);
+				(void) qh_schedule (ehci, qh);
+			} else
+				unlink_async (ehci, qh);
 			break;
 		/* otherwise, unlink already started */
 		}
@@ -646,6 +646,7 @@ qh_make (
 	u32			info1 = 0, info2 = 0;
 	int			is_input, type;
 	int			maxp = 0;
+	struct usb_tt		*tt = urb->dev->tt;
 
 	if (!qh)
 		return qh;
@@ -685,6 +686,8 @@ qh_make (
 				goto done;
 			}
 		} else {
+			int		think_time;
+
 			/* gap is f(FS/LS transfer times) */
 			qh->gap_uf = 1 + usb_calc_bus_time (urb->dev->speed,
 					is_input, 0, maxp) / (125 * 1000);
@@ -698,6 +701,10 @@ qh_make (
 				qh->c_usecs = HS_USECS (0);
 			}
 
+			think_time = tt ? tt->think_time : 0;
+			qh->tt_usecs = NS_TO_US (think_time +
+					usb_calc_bus_time (urb->dev->speed,
+					is_input, 0, max_packet (maxp)));
 			qh->period = urb->interval;
 		}
 
diff -urBp linux-2.4.37.orig/drivers/usb/host/ehci-sched.c linux/drivers/usb/host/ehci-sched.c
--- linux-2.4.37.orig/drivers/usb/host/ehci-sched.c	2008-12-02 11:01:34.000000000 +0300
+++ linux/drivers/usb/host/ehci-sched.c	2009-01-18 13:09:26.000000000 +0300
@@ -168,6 +168,202 @@ periodic_usecs (struct ehci_hcd *ehci, u
 	return usecs;
 }
 
+#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
+
+static int same_tt (struct usb_device *dev1, struct usb_device *dev2)
+{
+	if (!dev1->tt || !dev2->tt)
+		return 0;
+	if (dev1->tt != dev2->tt)
+		return 0;
+	if (dev1->tt->multi)
+		return dev1->ttport == dev2->ttport;
+	else
+		return 1;
+}
+
+/* Which uframe does the low/fullspeed transfer start in?
+ *
+ * The parameter is the mask of ssplits in "H-frame" terms
+ * and this returns the transfer start uframe in "B-frame" terms,
+ * which allows both to match, e.g. a ssplit in "H-frame" uframe 0
+ * will cause a transfer in "B-frame" uframe 0.  "B-frames" lag
+ * "H-frames" by 1 uframe.  See the EHCI spec sec 4.5 and figure 4.7.
+ */
+static inline unsigned char tt_start_uframe(struct ehci_hcd *ehci, u32 mask)
+{
+	unsigned char smask = QH_SMASK & le32_to_cpu(mask);
+	if (!smask) {
+		ehci_err(ehci, "invalid empty smask!\n");
+		/* uframe 7 can't have bw so this will indicate failure */
+		return 7;
+	}
+	return ffs(smask) - 1;
+}
+
+static const unsigned char
+max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 58, 0 };
+
+/* carryover low/fullspeed bandwidth that crosses uframe boundries */
+static inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])
+{
+	int i;
+	for (i=0; i<7; i++) {
+		if (max_tt_usecs[i] < tt_usecs[i]) {
+			tt_usecs[i+1] += tt_usecs[i] - max_tt_usecs[i];
+			tt_usecs[i] = max_tt_usecs[i];
+		}
+	}
+}
+
+/* How many of the tt's periodic downstream 1000 usecs are allocated?
+ *
+ * While this measures the bandwidth in terms of usecs/uframe,
+ * the low/fullspeed bus has no notion of uframes, so any particular
+ * low/fullspeed transfer can "carry over" from one uframe to the next,
+ * since the TT just performs downstream transfers in sequence.
+ *
+ * For example two seperate 100 usec transfers can start in the same uframe,
+ * and the second one would "carry over" 75 usecs into the next uframe.
+ */
+static void
+periodic_tt_usecs (
+	struct ehci_hcd *ehci,
+	struct usb_device *dev,
+	unsigned frame,
+	unsigned short tt_usecs[8]
+)
+{
+	u32			*hw_p = &ehci->periodic [frame];
+	union ehci_shadow	*q = &ehci->pshadow [frame];
+	unsigned char		uf;
+
+	memset(tt_usecs, 0, sizeof(unsigned short)*8);
+
+	while (q->ptr) {
+		switch (Q_NEXT_TYPE(*hw_p)) {
+		case Q_TYPE_ITD:
+			hw_p = &q->itd->hw_next;
+			q = &q->itd->itd_next;
+			continue;
+		case Q_TYPE_QH:
+			if (same_tt(dev, q->qh->dev)) {
+				uf = tt_start_uframe(ehci, q->qh->hw_info2);
+				tt_usecs[uf] += q->qh->tt_usecs;
+			}
+			hw_p = &q->qh->hw_next;
+			q = &q->qh->qh_next;
+			continue;
+		case Q_TYPE_SITD:
+			if (same_tt(dev, q->sitd->urb->dev)) {
+				uf = tt_start_uframe(ehci, q->sitd->hw_uframe);
+				tt_usecs[uf] += q->sitd->stream->tt_usecs;
+			}
+			hw_p = &q->sitd->hw_next;
+			q = &q->sitd->sitd_next;
+			continue;
+		// case Q_TYPE_FSTN:
+		default:
+			ehci_dbg(ehci,
+				  "ignoring periodic frame %d FSTN\n", frame);
+			hw_p = &q->fstn->hw_next;
+			q = &q->fstn->fstn_next;
+		}
+	}
+
+	carryover_tt_bandwidth(tt_usecs);
+
+	if (max_tt_usecs[7] < tt_usecs[7])
+		ehci_err(ehci, "frame %d tt sched overrun: %d usecs\n",
+			frame, tt_usecs[7] - max_tt_usecs[7]);
+}
+
+/*
+ * Return true if the device's tt's downstream bus is available for a
+ * periodic transfer of the specified length (usecs), starting at the
+ * specified frame/uframe.  Note that (as summarized in section 11.19
+ * of the usb 2.0 spec) TTs can buffer multiple transactions for each
+ * uframe.
+ *
+ * The uframe parameter is when the fullspeed/lowspeed transfer
+ * should be executed in "B-frame" terms, which is the same as the
+ * highspeed ssplit's uframe (which is in "H-frame" terms).  For example
+ * a ssplit in "H-frame" 0 causes a transfer in "B-frame" 0.
+ * See the EHCI spec sec 4.5 and fig 4.7.
+ *
+ * This checks if the full/lowspeed bus, at the specified starting uframe,
+ * has the specified bandwidth available, according to rules listed
+ * in USB 2.0 spec section 11.18.1 fig 11-60.
+ *
+ * This does not check if the transfer would exceed the max ssplit
+ * limit of 16, specified in USB 2.0 spec section 11.18.4 requirement #4,
+ * since proper scheduling limits ssplits to less than 16 per uframe.
+ */
+static int tt_available (
+	struct ehci_hcd		*ehci,
+	unsigned		period,
+	struct usb_device	*dev,
+	unsigned		frame,
+	unsigned		uframe,
+	u16			usecs
+)
+{
+	if ((period == 0) || (uframe >= 7))	/* error */
+		return 0;
+
+	for (; frame < ehci->periodic_size; frame += period) {
+		unsigned short tt_usecs[8];
+
+		periodic_tt_usecs (ehci, dev, frame, tt_usecs);
+
+		ehci_vdbg(ehci, "tt frame %d check %d usecs start uframe %d in"
+			" schedule %d/%d/%d/%d/%d/%d/%d/%d\n",
+			frame, usecs, uframe,
+			tt_usecs[0], tt_usecs[1], tt_usecs[2], tt_usecs[3],
+			tt_usecs[4], tt_usecs[5], tt_usecs[6], tt_usecs[7]);
+
+		if (max_tt_usecs[uframe] <= tt_usecs[uframe]) {
+			ehci_vdbg(ehci, "frame %d uframe %d fully scheduled\n",
+				frame, uframe);
+			return 0;
+		}
+
+		/* special case for isoc transfers larger than 125us:
+		 * the first and each subsequent fully used uframe
+		 * must be empty, so as to not illegally delay
+		 * already scheduled transactions
+		 */
+		if (125 < usecs) {
+			int ufs = (usecs / 125);
+			int i;
+			for (i = uframe; i < (uframe + ufs) && i < 8; i++)
+				if (0 < tt_usecs[i]) {
+					ehci_vdbg(ehci,
+						"multi-uframe xfer can't fit "
+						"in frame %d uframe %d\n",
+						frame, i);
+					return 0;
+				}
+		}
+
+		tt_usecs[uframe] += usecs;
+
+		carryover_tt_bandwidth(tt_usecs);
+
+		/* fail if the carryover pushed bw past the last uframe's limit */
+		if (max_tt_usecs[7] < tt_usecs[7]) {
+			ehci_vdbg(ehci,
+				"tt unavailable usecs %d frame %d uframe %d\n",
+				tt_usecs[7], frame, uframe);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+#endif /* CONFIG_USB_EHCI_TT_NEWSCHED */
+
 /*-------------------------------------------------------------------------*/
 
 static int enable_periodic (struct ehci_hcd *ehci)
@@ -219,61 +415,145 @@ static int disable_periodic (struct ehci
 
 /*-------------------------------------------------------------------------*/
 
-// FIXME microframe periods not yet handled
+/* periodic schedule slots have iso tds (normal or split) first, then a
+ * sparse tree for active interrupt transfers.
+ *
+ * this just links in a qh; caller guarantees uframe masks are set right.
+ * no FSTN support (yet; ehci 0.96+)
+ */
+static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
+{
+	unsigned	i;
+	unsigned	period = qh->period;
 
-static void intr_deschedule (
-	struct ehci_hcd	*ehci,
-	struct ehci_qh	*qh,
-	int		wait
-) {
-	int		status;
-	unsigned	frame = qh->start;
+	ehci_vdbg (ehci, "link qh %d-%04x/%p start %d [%d/%d us]\n",
+		period, le32_to_cpup(&qh->hw_info2) & (QH_CMASK | QH_SMASK),
+		qh, qh->start, qh->usecs, qh->c_usecs);
+
+	/* high bandwidth, or otherwise every microframe */
+	if (period == 0)
+		period = 1;
+
+	for (i = qh->start; i < ehci->periodic_size; i += period) {
+		union ehci_shadow	*prev = &ehci->pshadow[i];
+		u32			*hw_p = &ehci->periodic[i];
+		union ehci_shadow	here = *prev;
+		u32			type = 0;
+
+		/* skip the iso nodes at list head */
+		while (here.ptr) {
+			type = Q_NEXT_TYPE(*hw_p);
+			if (type == Q_TYPE_QH)
+				break;
+			prev = periodic_next_shadow(prev, type);
+			hw_p = &here.qh->hw_next;
+			here = *prev;
+		}
 
-	do {
-		periodic_unlink (ehci, frame, qh);
-		qh_put (ehci, qh);
-		frame += qh->period;
-	} while (frame < ehci->periodic_size);
+		/* sorting each branch by period (slow-->fast)
+		 * enables sharing interior tree nodes
+		 */
+		while (here.ptr && qh != here.qh) {
+			if (qh->period > here.qh->period)
+				break;
+			prev = &here.qh->qh_next;
+			hw_p = &here.qh->hw_next;
+			here = *prev;
+		}
+		/* link in this qh, unless some earlier pass did that */
+		if (qh != here.qh) {
+			qh->qh_next = here;
+			if (here.qh)
+				qh->hw_next = *hw_p;
+			wmb ();
+			prev->qh = qh;
+			*hw_p = QH_NEXT (qh->qh_dma);
+		}
+	}
+	qh->qh_state = QH_STATE_LINKED;
+	qh_get (qh);
 
+	/* update per-qh bandwidth for usbfs */
+	hcd_to_bus (&ehci->hcd)->bandwidth_allocated += qh->period
+		? ((qh->usecs + qh->c_usecs) / qh->period)
+		: (qh->usecs * 8);
+
+	/* maybe enable periodic schedule processing */
+	if (!ehci->periodic_sched++)
+		return enable_periodic (ehci);
+
+	return 0;
+}
+
+static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
+{
+	unsigned	i;
+	unsigned	period;
+
+	// FIXME:
+	// IF this isn't high speed
+	//   and this qh is active in the current uframe
+	//   (and overlay token SplitXstate is false?)
+	// THEN
+	//   qh->hw_info1 |= __constant_cpu_to_hc32(1 << 7 /* "ignore" */);
+
+	/* high bandwidth, or otherwise part of every microframe */
+	if ((period = qh->period) == 0)
+		period = 1;
+
+	for (i = qh->start; i < ehci->periodic_size; i += period)
+		periodic_unlink (ehci, i, qh);
+
+	/* update per-qh bandwidth utilization (for usbfs) */
+	hcd_to_bus (&ehci->hcd)->bandwidth_allocated -= qh->period
+		? ((qh->usecs + qh->c_usecs) / qh->period)
+		: (qh->usecs * 8);
+
+	/* qh->qh_next still "live" to HC */
 	qh->qh_state = QH_STATE_UNLINK;
-	qh->qh_next.ptr = 0;
+	qh->qh_next.ptr = NULL;
+	qh_put (ehci, qh);
+
 	ehci->periodic_sched--;
 
 	/* maybe turn off periodic schedule */
 	if (!ehci->periodic_sched)
-		status = disable_periodic (ehci);
-	else {
-		status = 0;
-		vdbg ("periodic schedule still enabled");
-	}
+		return disable_periodic (ehci);
 
-	/*
-	 * If the hc may be looking at this qh, then delay a uframe
-	 * (yeech!) to be sure it's done.
-	 * No other threads may be mucking with this qh.
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static void intr_deschedule (
+	struct ehci_hcd	*ehci,
+	struct ehci_qh	*qh,
+	int		wait0
+) {
+	int		status;
+	unsigned	wait; 
+
+	status = qh_unlink_periodic (ehci, qh);
+
+	/* simple/paranoid:  always delay, expecting the HC needs to read
+	 * qh->hw_next or finish a writeback after SPLIT/CSPLIT ... and
+	 * expect khubd to clean up after any CSPLITs we won't issue.
+	 * active high speed queues may need bigger delays...
 	 */
-	if (((ehci_get_frame (&ehci->hcd) - frame) % qh->period) == 0) {
-		if (wait) {
-			udelay (125);
-			qh->hw_next = EHCI_LIST_END;
-		} else {
-			/* we may not be IDLE yet, but if the qh is empty
-			 * the race is very short.  then if qh also isn't
-			 * rescheduled soon, it won't matter.  otherwise...
-			 */
-			vdbg ("intr_deschedule...");
-		}
-	} else
-		qh->hw_next = EHCI_LIST_END;
+	if (list_empty (&qh->qtd_list)
+			|| (__constant_cpu_to_le32(QH_CMASK)
+					& qh->hw_info2) != 0)
+		wait = 2;
+	else
+		wait = 55;	/* worst case: 3 * 1024 */
 
+	udelay (wait);
 	qh->qh_state = QH_STATE_IDLE;
-
-	/* update per-qh bandwidth utilization (for usbfs) */
-	hcd_to_bus (&ehci->hcd)->bandwidth_allocated -= 
-		(qh->usecs + qh->c_usecs) / qh->period;
+	qh->hw_next = EHCI_LIST_END;
+	wmb ();
 
 	dbg ("descheduled qh %p, period = %d frame = %d count = %d, urbs = %d",
-		qh, qh->period, frame,
+		qh, qh->period, qh->start,
 		atomic_read (&qh->refcount), ehci->periodic_sched);
 }
 
@@ -284,6 +560,8 @@ static int check_period (
 	unsigned	period,
 	unsigned	usecs
 ) {
+	int		claimed;
+
 	/* complete split running into next frame?
 	 * given FSTN support, we could sometimes check...
 	 */
@@ -296,22 +574,26 @@ static int check_period (
 	 */
 	usecs = 100 - usecs;
 
-	do {
-		int	claimed;
-
-// FIXME delete when intr_submit handles non-empty queues
-// this gives us a one intr/frame limit (vs N/uframe)
-// ... and also lets us avoid tracking split transactions
-// that might collide at a given TT/hub.
-		if (ehci->pshadow [frame].ptr)
-			return 0;
-
-		claimed = periodic_usecs (ehci, frame, uframe);
-		if (claimed > usecs)
-			return 0;
-
-// FIXME update to handle sub-frame periods
-	} while ((frame += period) < ehci->periodic_size);
+	/* we "know" 2 and 4 uframe intervals were rejected; so                 
+	 * for period 0, check _every_ microframe in the schedule.              
+	 */                                                                     
+	if (unlikely (period == 0)) {                                           
+		do {                                                            
+			for (uframe = 0; uframe < 7; uframe++) {                
+				claimed = periodic_usecs (ehci, frame, uframe); 
+				if (claimed > usecs)                            
+					return 0;                               
+			}                                                       
+		} while ((frame += 1) < ehci->periodic_size);                   
+
+	/* just check the specified uframe, at that period */                   
+	} else {                                                                
+		do {                                                            
+			claimed = periodic_usecs (ehci, frame, uframe);         
+			if (claimed > usecs)                                    
+				return 0;                                       
+		} while ((frame += period) < ehci->periodic_size);              
+	}
 
 	// success!
 	return 1;
@@ -327,7 +609,11 @@ static int check_intr_schedule (
 )
 {
     	int		retval = -ENOSPC;
+	u8		mask = 0;
 
+	if (qh->c_usecs && uframe >= 6)		/* FSTN territory? */
+		goto done;
+
 	if (!check_period (ehci, frame, uframe, qh->period, qh->usecs))
 		goto done;
 	if (!qh->c_usecs) {
@@ -334,6 +619,24 @@ static int check_intr_schedule (
 		*c_maskp = cpu_to_le32 (0);
 		goto done;
 	}
+#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
+	if (tt_available (ehci, qh->period, qh->dev, frame, uframe,
+				qh->tt_usecs)) {
+		unsigned i;
+
+		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
+		for (i=uframe+1; i<8 && i<uframe+4; i++)
+			if (!check_period (ehci, frame, i,
+						qh->period, qh->c_usecs))
+				goto done;
+			else
+				mask |= 1 << i;
+
+		retval = 0;
+
+		*c_maskp = cpu_to_le32 (mask << 8);
+	}
+#else
 
 	/* This is a split transaction; check the bandwidth available for
 	 * the completion too.  Check both worst and best case gaps: worst
@@ -358,6 +662,8 @@ static int check_intr_schedule (
 
 	*c_maskp = cpu_to_le32 (0x03 << (8 + uframe + qh->gap_uf));
 	retval = 0;
+#endif
+
 done:
 	return retval;
 }
@@ -374,7 +680,7 @@ static int qh_schedule (struct ehci_hcd
 
 	/* reuse the previous schedule slots, if we can */
 	if (frame < qh->period) {
-		uframe = ffs (le32_to_cpup (&qh->hw_info2) & 0x00ff);
+		uframe = ffs (le32_to_cpup (&qh->hw_info2) & QH_SMASK);
 		status = check_intr_schedule (ehci, frame, --uframe,
 				qh, &c_mask);
 	} else {
@@ -387,55 +693,44 @@ static int qh_schedule (struct ehci_hcd
 	 * uframes have enough periodic bandwidth available.
 	 */
 	if (status) {
-		frame = qh->period - 1;
-		do {
-			for (uframe = 0; uframe < 8; uframe++) {
-				status = check_intr_schedule (ehci,
-						frame, uframe, qh,
-						&c_mask);
-				if (status == 0)
-					break;
-			}
-		} while (status && frame--);
+		/* "normal" case, uframing flexible except with splits */
+		if (qh->period) {
+			frame = qh->period - 1;
+ 			do {
+				for (uframe = 0; uframe < 8; uframe++) {
+					status = check_intr_schedule (ehci,
+							frame, uframe, qh,
+							&c_mask);
+					if (status == 0)
+						break;
+				}
+			} while (status && frame--);
+
+		/* qh->period == 0 means every uframe */
+		} else {
+			frame = 0;
+			status = check_intr_schedule (ehci, 0, 0, qh, &c_mask); 
+		}
 		if (status)
 			goto done;
 		qh->start = frame;
 
 		/* reset S-frame and (maybe) C-frame masks */
 		qh->hw_info2 &= ~__constant_cpu_to_le32(0xffff);
-		qh->hw_info2 |= cpu_to_le32 (1 << uframe) | c_mask;
+		qh->hw_info2 |= qh->period
+                        ? cpu_to_le32(1 << uframe)
+                        : __constant_cpu_to_le32(QH_SMASK);
+		qh->hw_info2 |= c_mask;
 	} else
 		dbg ("reused previous qh %p schedule", qh);
 
 	/* stuff into the periodic schedule */
-	qh->qh_state = QH_STATE_LINKED;
+	status = qh_link_periodic (ehci, qh);
+
 	dbg ("scheduled qh %p usecs %d/%d period %d.0 starting %d.%d (gap %d)",
 		qh, qh->usecs, qh->c_usecs,
 		qh->period, frame, uframe, qh->gap_uf);
-	do {
-		if (unlikely (ehci->pshadow [frame].ptr != 0)) {
 
-// FIXME -- just link toward the end, before any qh with a shorter period,
-// AND accomodate it already having been linked here (after some other qh)
-// AS WELL AS updating the schedule checking logic
-
-			BUG ();
-		} else {
-			ehci->pshadow [frame].qh = qh_get (qh);
-			ehci->periodic [frame] =
-				QH_NEXT (qh->qh_dma);
-		}
-		wmb ();
-		frame += qh->period;
-	} while (frame < ehci->periodic_size);
-
-	/* update per-qh bandwidth for usbfs */
-	hcd_to_bus (&ehci->hcd)->bandwidth_allocated += 
-		(qh->usecs + qh->c_usecs) / qh->period;
-
-	/* maybe enable periodic schedule processing */
-	if (!ehci->periodic_sched++)
-		status = enable_periodic (ehci);
 done:
 	return status;
 }
@@ -516,6 +811,8 @@ iso_stream_init (
 	unsigned		interval
 )
 {
+	static const u8 smask_out [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };
+
 	u32			buf1;
 	unsigned		epnum, maxp, multi;
 	int			is_input;
@@ -546,6 +843,9 @@ iso_stream_init (
 	stream->interval = interval;
 	stream->maxp = maxp;
 
+	stream->usecs = HS_USECS_ISO (maxp);
+	/* knows about ITD vs SITD */
+	if (dev->speed == USB_SPEED_HIGH) {
 	stream->buf0 = cpu_to_le32 ((epnum << 8) | dev->devnum);
 	stream->buf1 = cpu_to_le32 (buf1);
 	stream->buf2 = cpu_to_le32 (multi);
@@ -553,9 +853,30 @@ iso_stream_init (
 	/* usbfs wants to report the average usecs per frame tied up
 	 * when transfers on this endpoint are scheduled ...
 	 */
-	stream->usecs = HS_USECS_ISO (maxp);
 	bandwidth = stream->usecs * 8;
 	bandwidth /= 1 << (interval - 1);
+	} else {
+		int		think_time;
+		int		hs_transfers;
+
+		think_time = dev->tt ? dev->tt->think_time : 0;
+		stream->tt_usecs = NS_TO_US (think_time + usb_calc_bus_time (
+				dev->speed, is_input, 1, maxp));
+		hs_transfers = max (1u, (maxp + 187) / 188);
+		if (is_input) {
+			u32	tmp;
+
+			stream->raw_mask = 1;
+
+			/* c-mask as specified in USB 2.0 11.18.4 3.c */
+			tmp = (1 << (hs_transfers + 2)) - 1;
+			stream->raw_mask |= tmp << (8 + 2);
+		} else
+			stream->raw_mask = smask_out [hs_transfers - 1];
+		bandwidth = stream->usecs * 2;
+		bandwidth /= 1 << (interval + 2);
+
+	}
 	stream->bandwidth = bandwidth;
 }
 
@@ -867,6 +1188,15 @@ itd_stream_schedule (
 		do {
 			uframe %= mod;
 
+#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
+		/* The tt's fullspeed bus bandwidth must be available.
+		 * tt_available scheduling guarantees 10+% for control/bulk.
+		 */
+		if (!tt_available (ehci, mod << 3,
+				urb->dev, uframe >> 3, uframe & 0x7, stream->tt_usecs))
+			return 0;
+#endif
+
 			/* can't commit more than 80% periodic == 100 usec */
 			if (periodic_usecs (ehci, uframe >> 3, uframe & 0x7)
 					> (100 - stream->usecs)) {
