--- linuz/drivers/usb/printer.c	2008-01-01 15:06:40.000000000 +0300
+++ linux/drivers/usb/printer.c	2004-12-03 05:57:26.000000000 +0300
@@ -58,6 +58,50 @@
 #undef DEBUG
 #include <linux/usb.h>
 
+
+/* Added by PaN */
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+// End PaN
+
+/* Added by PaN */
+struct print_buffer
+{
+	int len;
+	char *buf;
+};
+#define MODULE_NAME "usblp"
+#define MAX_CLASS_NAME  16
+#define MAX_MFR         16
+#define MAX_MODEL       32
+#define MAX_DESCRIPT    64
+#define MAX_STATUS_TYPE 6
+
+static struct proc_dir_entry *usblp_dir, *usblpid_file;
+struct parport_splink_device_info {
+	char class_name[MAX_CLASS_NAME];
+	char mfr[MAX_MFR];
+	char model[MAX_MODEL];
+	char description[MAX_DESCRIPT];
+};
+static char *usblp_status_type[MAX_STATUS_TYPE]={ "Lexmark", "Canon", "Hp", "Epson", "EPSON", NULL};
+static int usblp_status_maping[MAX_STATUS_TYPE][4]={ {0,0,0,0},
+				       		     {0, LP_POUTPA, LP_PERRORP, LP_PBUSY},
+				       		     {0,0,0,0},
+				       		     {0,0,0,0},
+				       		     {0,0,0,0},
+				       		     {0,0,0,0}};
+			       	       	       
+static struct parport_splink_device_info usblpid_info;
+struct parport_splink_device_info prn_info_tmp, *prn_info; // Added by JYWeng 20031212:
+char *strunknown="unknown"; // Added by JYWeng 20031212:
+void parseKeywords(char *str_dev_id, char *keyword1, char *keyword2, char *prn_info_data, char *usblpid_info_data);// Added by JYWeng 20031212:
+
+static ssize_t usblp_write(struct file *file, const char *buffer, size_t count, loff_t *ppos);
+static ssize_t usblp_read(struct file *file, char *buffer, size_t count, loff_t *ppos);
+static int usblp_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg);
+// END PaN
+
 /*
  * Version Information
  */
@@ -68,6 +112,15 @@
 #define USBLP_BUF_SIZE		8192
 #define USBLP_DEVICE_ID_SIZE	1024
 
+/****************add by JY 20031118*************************************/
+#define LPGETID                 0x0610		/* get printer's device ID */
+#define LPWRITEDATA     0x0613  /* write data to printer */
+#define LPWRITEADDR     0x0614  /* write address to printer */
+#define LPREADDATA      0x0615  /* read data from pinter */
+#define LPREADADDR      0x0616  /* read address from pinter */
+#define DEVICE_ID_SIZE	1024
+/*******************************************************/
+
 /* ioctls: */
 #define LPGETSTATUS		0x060b		/* same as in drivers/char/lp.c */
 #define IOCNR_GET_DEVICE_ID		1
@@ -303,6 +345,152 @@
 
 static char *usblp_messages[] = { "ok", "out of paper", "off-line", "on fire" };
 
+
+/* Added by PaN */
+static int proc_read_usblpid(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len=0;
+	
+	len=sprintf(page, "Manufacturer=%s\nModel=%s\nClass=%s\nDescription=%s\n\n", 
+	usblpid_info.mfr, usblpid_info.model, usblpid_info.class_name, usblpid_info.description);
+	
+	return len;
+}
+
+static int proc_get_usblpid(struct usblp *usblp)
+{
+//JYWeng 20031212: set this as global	char *strtmp, *strunknown="unknown"; // Added by PaN
+	char *str_dev_id; // Added by PaN: JYWeng 20031212: modified from the above
+	//int i, unk = 0; // Added by PaN
+	int length, err;
+	int retval = 0;
+
+	prn_info= &prn_info_tmp; // Added by JYWeng 20031212:
+
+	
+	err = usblp_get_id(usblp, 0, usblp->device_id_string, DEVICE_ID_SIZE - 1);
+	
+	if (err < 0) {
+		dbg ("usblp%d: error = %d reading IEEE-1284 Device ID string",
+			usblp->minor, err);
+			usblp->device_id_string[0] = usblp->device_id_string[1] = '\0';
+		retval = -EIO;
+		goto done;
+	}
+
+	length = (usblp->device_id_string[0] << 8) + usblp->device_id_string[1]; /* big-endian */
+	if (length < DEVICE_ID_SIZE)
+		usblp->device_id_string[length] = '\0';
+	else
+		usblp->device_id_string[DEVICE_ID_SIZE - 1] = '\0';
+
+	dbg ("usblp%d Device ID string [%d]='%s'",
+		usblp->minor, length, &usblp->device_id_string[2]);
+	info ("usblp%d Device ID string [%d]='%s'",
+		usblp->minor, length, &usblp->device_id_string[2]);
+
+	str_dev_id = &usblp->device_id_string[2];	
+#if 1//JYWeng 20031212: modified from below
+				parseKeywords(str_dev_id, "MFG:", "MANUFACTURE:", prn_info->mfr, usblpid_info.mfr);	
+				parseKeywords(str_dev_id, "MDL:", "MODEL:", prn_info->model, usblpid_info.model);	
+				parseKeywords(str_dev_id, "CLS:", "CLASS:", prn_info->class_name, usblpid_info.class_name);	
+				parseKeywords(str_dev_id, "DES:", "DESCRIPTION:", prn_info->description, usblpid_info.description);	
+#else
+	if ( (strtmp = strstr(str_dev_id, "MFG:")) == NULL) {
+		if ( (strtmp = strstr(str_dev_id, "MANUFACTURE:")) == NULL) {
+			for (i=0; i<7; i++) {
+				usblpid_info.mfr[i] = strunknown[i];
+			}
+			usblpid_info.mfr[i]='\0';
+			unk=1;
+		}
+		else 
+			strtmp+=12;
+	}
+	else
+		strtmp+=4;
+					
+	i=0;
+	while (unk==0 && strtmp[i] != ';') {
+		usblpid_info.mfr[i] = strtmp[i];
+		i++;
+	}
+	usblpid_info.mfr[i]='\0';
+	unk=0;
+
+	if ( (strtmp = strstr(str_dev_id, "MDL:")) == NULL) {
+		if ( (strtmp = strstr(str_dev_id, "MODEL:")) == NULL) {
+			for (i=0; i<7; i++) {
+				usblpid_info.model[i] = strunknown[i];
+			}
+			usblpid_info.model[i]='\0';
+			unk=1;
+		}
+		else
+			strtmp+=6;
+		}
+	else 
+		strtmp+=4;
+				
+	i=0;
+	while (unk==0 && strtmp[i] != ';') {
+		usblpid_info.model[i] = strtmp[i];
+		i++;
+	}		
+	usblpid_info.model[i]='\0';
+	unk=0;
+	
+	if ( (strtmp = strstr(str_dev_id, "CLS:")) == NULL) {
+		if ( (strtmp = strstr(str_dev_id, "CLASS:")) == NULL) {
+			for (i=0; i<7; i++) {
+				usblpid_info.class_name[i] = strunknown[i];
+			}
+			usblpid_info.class_name[i]='\0';
+			unk=1;
+		}
+		else
+			strtmp+=6;
+	}
+	else 
+		strtmp+=4;
+	
+	i=0;
+	while (unk==0 && strtmp[i] != ';') {
+		usblpid_info.class_name[i]= strtmp[i];
+		i++;
+	}		
+	usblpid_info.class_name[i]='\0';
+	unk=0;
+	
+	if ( (strtmp = strstr(str_dev_id, "DES:")) == NULL) {
+		if ( (strtmp = strstr(str_dev_id, "DESCRIPTION:")) == NULL) {
+			for (i=0; i<7; i++) {
+				usblpid_info.description[i] = strunknown[i];
+			}
+			usblpid_info.description[i]='\0';
+			unk=1;
+		}
+		else
+			strtmp+=12;
+	}
+	else
+		strtmp+=4;
+		
+	i=0;
+	while (unk==0 && strtmp[i] != ';') {
+			usblpid_info.description[i]= strtmp[i];
+			i++;
+	}		
+	usblpid_info.description[i]='\0';
+#endif//JYWeng 20031212: end
+
+done:
+	return retval;
+	
+}
+// End PaN
+
+
 static int usblp_check_status(struct usblp *usblp, int err)
 {
 	unsigned char status, newerr = 0;
@@ -339,7 +527,8 @@
 	int minor = MINOR(inode->i_rdev) - USBLP_MINOR_BASE;
 	struct usblp *usblp;
 	int retval;
+	unsigned int arg = NULL, ioctl_retval; //Added by PaN
 
 	if (minor < 0 || minor >= USBLP_MINORS)
 		return -ENODEV;
 
@@ -384,8 +573,14 @@
 			file->private_data = NULL;
 		}
 	}
+
+	/* Added by PaN */
+	if ((ioctl_retval=usblp_ioctl(inode, file, LPGETID, arg)) <0)
+	{
+		// Update device id failed
+	}	
 out:
 	up (&usblp_sem);
 	return retval;
 }
 
@@ -393,7 +588,12 @@
 {
 	devfs_unregister (usblp->devfs);
 	usblp_table [usblp->minor] = NULL;
-	info("usblp%d: removed", usblp->minor);
+	//info("usblp%d: removed", usblp->minor);
+
+	/* Added by PaN */
+	remove_proc_entry("usblpid", usblp_dir);
+	remove_proc_entry(MODULE_NAME, NULL);
+	/* End PaN */
 
 	kfree (usblp->writebuf);
 	kfree (usblp->readbuf);
@@ -437,6 +639,11 @@
 static int usblp_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct usblp *usblp = file->private_data;
+//JYWeng 20031212: set this as global	struct parport_splink_device_info prn_info_tmp, *prn_info; // Added by PaN
+	struct print_buffer *user_buf; // Added by PaN
+//JYWeng 20031212: set this as global	char *strtmp, *strunknown="unknown"; // Added by PaN
+	char *str_dev_id; // Added by PaN: JYWeng 20031212: modified from the above
+	//int i, unk=0; // Added by PaN
 	int length, err, i;
 	unsigned char newChannel;
 	int status;
@@ -588,18 +796,209 @@
 		}
 	else	/* old-style ioctl value */
 		switch (cmd) {
+			/*=================================================================================== PaN */
+			case LPGETID: /* get the DEVICE_ID string */
+				err = usblp_get_id(usblp, 0, usblp->device_id_string, DEVICE_ID_SIZE - 1);
+				if (err < 0) {
+					dbg ("usblp%d: error = %d reading IEEE-1284 Device ID string",
+						usblp->minor, err);
+					usblp->device_id_string[0] = usblp->device_id_string[1] = '\0';
+					retval = -EIO;
+					goto done;
+				}
+
+				length = (usblp->device_id_string[0] << 8) + usblp->device_id_string[1]; /* big-endian */
+				if (length < DEVICE_ID_SIZE)
+					usblp->device_id_string[length] = '\0';
+				else
+					usblp->device_id_string[DEVICE_ID_SIZE - 1] = '\0';
+
+				dbg ("usblp%d Device ID string [%d/max %d]='%s'",
+					usblp->minor, length, cmd, &usblp->device_id_string[2]);
+				info ("usblp%d Device ID string [%d/max %d]='%s'",
+					usblp->minor, length, cmd, &usblp->device_id_string[2]);
+
+				str_dev_id = &usblp->device_id_string[2];	
+#if 1//JYWeng 20031212: modified from below
+				parseKeywords(str_dev_id, "MFG:", "MANUFACTURE:", prn_info->mfr, usblpid_info.mfr);	
+				parseKeywords(str_dev_id, "MDL:", "MODEL:", prn_info->model, usblpid_info.model);	
+				parseKeywords(str_dev_id, "CLS:", "CLASS:", prn_info->class_name, usblpid_info.class_name);	
+				parseKeywords(str_dev_id, "DES:", "DESCRIPTION:", prn_info->description, usblpid_info.description);	
+#else
+				if ( (strtmp = strstr(str_dev_id, "MFG:")) == NULL) {
+					if ( (strtmp = strstr(str_dev_id, "MANUFACTURE:")) == NULL) {
+						for (i=0; i<7; i++) {
+							prn_info->mfr[i]= strunknown[i];
+							usblpid_info.mfr[i] = strunknown[i];
+						}
+						prn_info->mfr[i]= '\0';
+						usblpid_info.mfr[i]='\0';
+						unk=1;
+					}
+					else 
+						strtmp+=12;
+				}
+				else
+					strtmp+=4;
+					
+				i=0;
+				while (unk==0 && strtmp[i] != ';') {
+					prn_info->mfr[i]= strtmp[i];
+					usblpid_info.mfr[i] = strtmp[i];
+					i++;
+				}
+				prn_info->mfr[i]= '\0';
+				usblpid_info.mfr[i]='\0';
+				unk=0;
+
+				if ( (strtmp = strstr(str_dev_id, "MDL:")) == NULL) {
+					if ( (strtmp = strstr(str_dev_id, "MODEL:")) == NULL) {
+						for (i=0; i<7; i++) {
+							prn_info->model[i]= strunknown[i];
+							usblpid_info.model[i] = strunknown[i];
+						}
+						prn_info->model[i]= '\0';
+						usblpid_info.model[i]='\0';
+						unk=1;
+					}
+					else
+						strtmp+=6;
+				}
+				else 
+					strtmp+=4;
+				
+				i=0;
+				while (unk==0 && strtmp[i] != ';') {
+					prn_info->model[i]= strtmp[i];
+					usblpid_info.model[i] = strtmp[i];
+					i++;
+				}		
+				prn_info->model[i]= '\0';
+				usblpid_info.model[i]='\0';
+				unk=0;
+				
+				if ( (strtmp = strstr(str_dev_id, "CLS:")) == NULL) {
+					if ( (strtmp = strstr(str_dev_id, "CLASS:")) == NULL) {
+						for (i=0; i<7; i++) {
+							prn_info->class_name[i]= strunknown[i];
+							usblpid_info.class_name[i] = strunknown[i];
+						}
+						prn_info->class_name[i]= '\0';
+						usblpid_info.class_name[i]='\0';
+						unk=1;
+					}
+					else
+						strtmp+=6;
+				}
+				else 
+					strtmp+=4;
+				
+				i=0;
+				while (unk==0 && strtmp[i] != ';') {
+					prn_info->class_name[i]= strtmp[i];
+					usblpid_info.class_name[i]= strtmp[i];
+					i++;
+				}		
+				prn_info->class_name[i]= '\0';
+				usblpid_info.class_name[i]='\0';
+				unk=0;
+				
+				if ( (strtmp = strstr(str_dev_id, "DES:")) == NULL) {
+					if ( (strtmp = strstr(str_dev_id, "DESCRIPTION:")) == NULL) {
+						for (i=0; i<7; i++) {
+							prn_info->description[i]= strunknown[i];
+							usblpid_info.description[i] = strunknown[i];
+						}
+						prn_info->description[i]= '\0';
+						usblpid_info.description[i]='\0';
+						unk=1;
+					}
+					else
+						strtmp+=12;
+				}
+				else
+					strtmp+=4;
+				
+				i=0;
+				while (unk==0 && strtmp[i] != ';') {
+						prn_info->description[i]= strtmp[i];
+						usblpid_info.description[i]= strtmp[i];
+						i++;
+				}	
+				prn_info->description[i]= '\0';
+				usblpid_info.description[i]='\0';
+#endif//JYWeng 20031212: end
+				
+				info("Parsing USBLPID...");
+				if (copy_to_user((unsigned char *) arg,
+						prn_info, (unsigned long) length)) {
+					retval = -EFAULT;
+					goto done;
+				}
+				break;
+
+			case LPREADDATA:
+			        up (&usblp->sem);
+				user_buf = (struct print_buffer *)arg;
+				retval = usblp_read(file, user_buf->buf, user_buf->len, NULL);
+				down (&usblp->sem);
+	                        break;
+										
+
+			case LPWRITEDATA:
+			        up (&usblp->sem);
+				user_buf = (struct print_buffer *)arg;
+				retval = usblp_write(file, user_buf->buf, user_buf->len, NULL);
+				down (&usblp->sem);
+	                        break;
+										 
+			case LPRESET:
+                                usblp_reset(usblp);
+				break;
 
 			case LPGETSTATUS:
-				if (usblp_read_status(usblp, usblp->statusbuf)) {
+				/* OLD USB Code Removed by PaN for Printer Server 
+				if (usblp_read_status(usblp, &status)) {
 					err("usblp%d: failed reading printer status", usblp->minor);
 					retval = -EIO;
 					goto done;
 				}
-				status = *usblp->statusbuf;
-				if (copy_to_user ((int *)arg, &status, sizeof(int)))
+				if (copy_to_user ((int *)arg, &status, 2))
+					retval = -EFAULT;
+				*/
+                                status = usblp_check_status(usblp, 0);
+#if 0
+				info("start=%s", usblpid_info.mfr);
+				for (i=0; i< MAX_STATUS_TYPE; i++) {
+				info("compare=%s", usblp_status_type[i]);
+					if ( !( strcmp(usblpid_info.mfr, usblp_status_type[i]) ) )
+						break;
+				}
+				info("%d=%s", i, usblp_status_type[i]);
+				status=usblp_status_maping[i][status];
+				info("STATUS=%x", status);
+#endif
+				status=0;
+				if (copy_to_user ((int *)arg, &status, 2))
 					retval = -EFAULT;
 				break;
 
+/*=================================================================== PaN for Printer Server */
+
+/* Marked by JY 20031118*/
+#if 0
+			case LPGETSTATUS:
+				if (usblp_read_status(usblp, &lpstatus)) {
+					err("usblp%d: failed reading printer status", usblp->minor);
+					retval = -EIO;
+					goto done;
+				}
+				status = lpstatus;
+				if (copy_to_user ((int *)arg, &status, sizeof(int)))
+					retval = -EFAULT;
+				break;
+#endif
+/* Marked by JY 20031118*/			
 			default:
 				retval = -ENOTTY;
 		}
@@ -609,7 +1008,45 @@
 	return retval;
 }
 
+/*********************************************************
+** JYWeng 20031212: parsing the information of printers **
+*********************************************************/
+void parseKeywords(char *str_dev_id, char *keyword1, char *keyword2, char *prn_info_data, char *usblpid_info_data)
+{
+	char *strtmp;
+	int i, unk = 0;
+	
+	if ( (strtmp = strstr(str_dev_id, keyword1)) == NULL) {
+		if ( (strtmp = strstr(str_dev_id, keyword2)) == NULL) {
+			for (i=0; i<7; i++) {
+				prn_info_data[i]= strunknown[i];
+				usblpid_info_data[i] = strunknown[i];
+			}
+			prn_info_data[i]= '\0';
+			usblpid_info_data[i]='\0';
+			unk=1;
+			
+			return;
+		}
+		else 
+			strtmp+=strlen(keyword2);
+	}
+	else
+		strtmp+=strlen(keyword1);
+					
+	i=0;
+	while (unk==0 && strtmp[i] && strtmp[i] != ';') {
+		prn_info_data[i]= strtmp[i];
+		usblpid_info_data[i] = strtmp[i];
+		i++;
+	}
+	prn_info_data[i]= '\0';
+	usblpid_info_data[i]='\0';
+
+	return;
+}
+
 static ssize_t usblp_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)
 {
 	DECLARE_WAITQUEUE(wait, current);
 	struct usblp *usblp = file->private_data;
@@ -662,7 +1097,8 @@
 			/* if the fault was due to disconnect, let khubd's
 			 * call to usblp_disconnect() grab usblp->sem ...
 			 */
-			schedule ();
-			continue;
+			return writecount; 	//Added by PaN
+			//schedule (); 		//Removed by PaN
+			//continue;	
 		}
 
@@ -939,6 +1363,29 @@
 
 	usblp->present = 1;
 
+	/* Added by PaN */
+	/* create directory */
+	usblp_dir = proc_mkdir(MODULE_NAME, NULL);
+	if(usblp_dir == NULL) {
+	        goto outpan;
+	}
+        usblp_dir->owner = THIS_MODULE;
+				
+	usblpid_file = create_proc_read_entry("usblpid", 0444, usblp_dir, proc_read_usblpid, NULL);
+	if(usblpid_file == NULL) {
+		remove_proc_entry(MODULE_NAME, NULL);
+
+		goto outpan;
+	}
+        usblpid_file->owner = THIS_MODULE;
+	/* get device id */
+	if (proc_get_usblpid(usblp) < 0) 
+		info("proc:get usblpid error!!");
+
+outpan:
+	// End PaN 
+
+
 	return usblp;
 
 abort:
