diff -urNBp busybox.orig/examples/udhcp/dhcp6c.conf busybox/examples/udhcp/dhcp6c.conf
--- busybox.orig/examples/udhcp/dhcp6c.conf	1970-01-01 03:00:00.000000000 +0300
+++ busybox/examples/udhcp/dhcp6c.conf	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,230 @@
+# Sample dhcp6c configuration file (/etc/dhcp6c.conf)
+# Values shown are defaults
+#
+# NB! Major limitation of busybox applet
+#  - both keyword & it's arguments MUST reside on the same line
+
+# Interface statement
+#  An interface statement specifies configuration parameters on the interface.
+#  The generic format of an interface statement is as follows:
+#
+#  interface interface { substatements };
+#     send send-options ;
+#			This statement specifies DHCPv6 options to be sent to the
+#			server(s).  Some options can only appear in particular
+#			messages according to the specification, in which case
+#			the appearance of the options is limited to be compliant
+#			with the specification.
+#
+#			send-options is a comma-separated list of options, each
+#			of which should be specified as described above. Multiple
+#			send statements can also be specified, in which case
+#			all the specified options will be sent.
+#
+#	rapid-commit
+#			When rapid-commit is specified, dhcp6c will include a
+#			rapid-commit option in solicit messages and wait for an
+#			immediate reply instead of advertisements.
+#	ia-pd ID
+#			When ia-pd is specified, dhcp6c will initiate prefix del-
+#			egation as a requesting router by including an IA_PD
+#			option with the specified ID in solicit messages.
+#	ia-na ID
+#			When ia-na is specified, dhcp6c will initiate stateful
+#			address assignment by including an IA_NA option with the
+#			specified ID in solicit messages.
+#	authentication authname
+#			means an authentication option. authname is a string specifying
+#			parameters of the authentication protocol. An authentication
+#			statement for authname must be provided.
+#			In either case, a corresponding identity association
+#			statement must exist with the same ID.
+#
+#     request request-options;
+#			This statement specifies DHCPv6 options to be included in
+#			an option-request option. request-options is a comma
+#			separated list of options, which can consist of the fol-
+#			lowing options.
+#
+#		domain-name-servers
+#			requests a list of Domain Name Server addresses.
+#		domain-name
+#			requests a DNS search path.
+#		ntp-servers
+#			requests a list of NTP server addresses. As of
+#			this writing, the option type for this option is
+#			not officially assigned. dhcp6c will reject this
+#			option unless it is explicitly built to accept
+#			the option.
+#		sip-server-address
+#			requests a list of SIP server addresses.
+#		sip-domain-name
+#			requests a SIP server domain name.
+#		nis-server-address
+#			requests a list of NIS server addresses.
+#		nis-domain-name
+#			requests a NIS domain name.
+#		nisp-server-address
+#			requests a list of NIS+ server addresses.
+#		nisp-domain-name
+#			requests a NIS+ domain name.
+#		bcmcs-server-address
+#			requests a list of BCMCS server addresses.
+#		bcmcs-domain-name
+#			requests a BCMCS domain name.
+#		refreshtime
+#			means an information refresh time option. This
+#			can only be specified when sent with information
+#			request messages; dhcp6c will ignore this option
+#			for other messages.
+#			Multiple request statements can also be specified, in
+#			which case all the specified options will be requested.
+#     information-only;
+#  			This statement specifies dhcp6c to only exchange informa-
+#			tional configuration parameters with servers. A list of
+#			DNS server addresses is an example of such parameters.
+#			This statement is useful when the client does not need
+#			stateful configuration parameters such as IPv6 addresses
+#			or prefixes.
+#     script "script-name";
+#			This statement specifies a path to script invoked by
+#			dhcp6c on a certain condition including when the daemon
+#			receives a reply message. script-name must be the absolute
+#			path from root to the script file, be a regular
+#			file, and be created by the same owner who runs the daemon.
+#
+# Identity association statement
+#  Identity association (IA) is a key notion of DHCPv6. An IA is uniquely
+#  identified in a client by a pair of IA type and IA identifier (IAID). An
+#  IA is associated with configuration information dependent on the IA type.
+#  An identity association statement defines a single IA with some client-
+#  side configuration parameters. Its format is as follows:
+#
+#  id-assoc type [ID] { substatements };
+#		type is a string for the type of this IA. The current implemen-
+#		tation supports <oq>na<cq> (non-temporary address allocation) <oq>pd<cq>
+#		(prefix delegation) for the IA type. ID is a decimal number of
+#		IAID. If omitted, the value 0 will be used by default.
+#		substatements is a sequence of statements that specifies configu-
+#		ration parameters for this IA. Each statement may or may not be
+#		specific to the type of IA.
+#
+#	The followings are possible substatements for an IA of type na.
+#     address ipv6-address pltime [vltime];
+#			specifies an address and related parameters that the
+#			client wants to be allocated. Multiple addresses can be
+#			specified, each of which is described as a separate
+#			address substatement. dhcp6c will include all the
+#			addresses (and related parameters) in Solicit messages,
+#			as an IA_NA prefix option encapsulated in the correspond-
+#			ing IA_NA option. Note, however, that the server may or
+#			may not respect the specified prefix parameters.
+#	The followings are possible substatements for an IA of type pd.
+#     prefix_interface_statement
+#			specifies the client's local configuration of how dele-
+#			gated prefixes should be used (see below).
+#     prefix ipv6-prefix pltime [vltime];
+#			specifies a prefix and related parameters that the client
+#			wants to be delegated. Multiple prefixes can be speci-
+#			fied, each of which is described as a separate prefix
+#			substatement. dhcp6c will include all the prefixes (and
+#			related parameters) in Solicit messages, as an IA_PD pre-
+#			fix option encapsulated in the corresponding IA_PD
+#			option. Note, however, that the server may or may not
+#			respect the specified prefix parameters.
+#
+# Prefix interface statement
+#  A prefix interface statement specifies configuration parameters of pre-
+#  fixes on local interfaces that are derived from delegated prefixes. A
+#  prefix interface statement can only appear as a substatement of an iden-
+#  tity association statement with the type pd. The generic format of an
+#  interface statement is as follows:
+#
+#  prefix-interface interface { substatements };
+#		When an IPv6 prefix is delegated from a DHCPv6 server, dhcp6c
+#		will assign a prefix on the interface unless the interface
+#		receives the DHCPv6 message that contains the prefix with the
+#		delegated prefix and the parameters provided in substatements.
+#		Possible substatements are as follows:
+#     sla-id ID ;
+#			This statement specifies the identifier value of the
+#			site-level aggregator (SLA) on the interface.
+#     sla-len length ;
+#			This statement specifies the length of the SLA ID in
+#			bits. length must be a decimal number between 0 and 128.
+#			If the length is not specified by this statement, the
+#			default value 16 will be used.
+#
+# Authentication statement
+#  An authentication statement defines a set of authentication parameters
+#  used in DHCPv6 exchanges with the server(s). The format of an authenti-
+#  cation statement is as follows:
+#
+#  authentication authname { substatements };
+#		authname is a string which is unique among all authentication
+#		statements in the configuration file. It will specify a particu-
+#		lar set of authentication parameters when authentication option
+#		is specified in the interface statement. Possible substatements
+#		of the authentication statement are as follows:
+#     protocol authprotocol ;
+#			specifies the authentication protocol. Currently, the
+#			only available protocol as authprotocol is delayed, which
+#			means the DHCPv6 delayed authentication protocol.
+#     algorithm authalgorithm ;
+#			specifies the algorithm for this authentication. Cur-
+#			rently, the only available algorithm is HMAC-MD5, which
+#			can be specified as one of the followings: hmac-md5,
+#			HMAC-MD5, hmacmd5, or HMACMD5. This substatement can be
+#			omitted. In this case, HMAC-MD5 will be used as the
+#			algorithm.
+#     rdm replay-detection-method ;
+#			specifies the replay protection method for this authenti-
+#			cation. Currently, the only available method is
+#			monocounter, which means the use of a monotonically
+#			increasing counter. If this method is specified, dhcp6c
+#			will use an NTP-format timestamp when it authenticates
+#			the message. This substatement can be omitted, in which
+#			case monocounter will be used as the method.
+#
+# Keyinfo statement
+#  A keyinfo statement defines a secret key shared with the server(s) to
+#  authenticate DHCPv6 messages. The format of a keyinfo statement is as
+#  follows:
+#
+#  keyinfo keyname { substatements };
+#		keyname is an arbitrary string. It does not affect client's
+#		behavior but is provided for readability of log messages. Possi-
+#		ble substatements of the keyinfo statement are as follows:
+#     realm "realmname" ;
+#			specifies the DHCP realm. realmname is an arbitrary
+#			string, but is typically expected to be a domain name
+#			like "kame.net" .
+#     keyid ID ;
+#			specifies the key identifier, ID, as a decimal number. A
+#			secret key is uniquely identified within the client by
+#			the DHCP realm and the key identifier.
+#     secret "secret-value" ;
+#			specifies the shared secret of this key. "secret-value"
+#			is a base-64 encoded string of the secret.
+#     expire "expiration-time" ;
+#			specifies the expiration time of this key.
+#			"expiration-time" should be formatted in one of the fol-
+#			lowings: yyyy-mm-dd HH:MM, mm-dd HH:MM, or HH:MM, where
+#			yyyy is the year with century (e.g., 2004), mm is the
+#			month, dd is the day of the month, HH is the hour of
+#			24-hour clock, and MM is the minute, each of which is
+#			given as a decimal number. Additionally, a special key-
+#			word forever can be specified as expiration-time, which
+#			means the key has an infinite lifetime and never expires.
+#			This substatement can be omitted, in which case forever
+#			will be used by default.
+
+
+interface ppp0 {
+  send ia-pd 0;
+};
+id-assoc pd {
+  prefix-interface ne0 {
+   sla-id 1;
+  };
+};
diff -urNBp busybox.orig/include/applets.src.h busybox/include/applets.src.h
--- busybox.orig/include/applets.src.h	2010-07-25 22:48:26.000000000 +0400
+++ busybox/include/applets.src.h	2011-02-05 13:41:12.000000000 +0300
@@ -112,6 +112,8 @@ IF_DELUSER(APPLET(deluser, _BB_DIR_BIN,
 IF_DEVFSD(APPLET(devfsd, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_DEVMEM(APPLET(devmem, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_DF(APPLET(df, _BB_DIR_BIN, _BB_SUID_DROP))
+IF_DHCP6C(APPLET(dhcp6c, _BB_DIR_SBIN, _BB_SUID_DROP))
+IF_DHCP6RELAY(APPLET(dhcp6relay, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_DHCPRELAY(APPLET(dhcprelay, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_DIFF(APPLET(diff, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_DIRNAME(APPLET_NOFORK(dirname, dirname, _BB_DIR_USR_BIN, _BB_SUID_DROP, dirname))
diff -urNBp busybox.orig/networking/udhcp/auth6.c busybox/networking/udhcp/auth6.c
--- busybox.orig/networking/udhcp/auth6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/auth6.c	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")
+ * Copyright (C) 2000, 2001  Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH
+ * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,
+ * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <sys/param.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+
+#include <netinet/in.h>
+
+#include <syslog.h>
+#include <string.h>
+#include <errno.h>
+
+#include "libbb.h"
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "auth6.h"
+
+#define HMACMD5_KEYLENGTH 64
+
+typedef struct {
+	md5_ctx_t md5ctx;
+	unsigned char key[HMACMD5_KEYLENGTH];
+} hmacmd5_t;
+
+
+static void hmacmd5_init(hmacmd5_t *, const unsigned char *,
+    unsigned int);
+static ALWAYS_INLINE void hmacmd5_invalidate(hmacmd5_t *);
+static ALWAYS_INLINE void hmacmd5_update(hmacmd5_t *, const unsigned char *,
+    unsigned int);
+static void hmacmd5_sign(hmacmd5_t *, unsigned char *);
+static int hmacmd5_verify(hmacmd5_t *, unsigned char *);
+
+
+int dhcp6_validate_key(struct keyinfo *key)
+{
+	time_t now;
+
+	if (key->expire == 0)	/* never expire */
+		return (0);
+
+	if (time(&now) == -1)
+		return (-1);	/* treat it as expiration (XXX) */
+
+	if (now > key->expire)
+		return (-1);
+
+	return (0);
+}
+
+int dhcp6_calc_mac(char *buf, size_t len, int proto __attribute__((unused)),
+		int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return (-1);
+
+	if (off + MD5_DIGESTLENGTH > len) {
+		/*
+		 * this should be assured by the caller, but check it here
+		 * for safety.
+		 */
+		return (-1);
+	}
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	hmacmd5_update(&ctx, (unsigned char *)buf, len);
+	hmacmd5_sign(&ctx, digest);
+
+	memcpy(buf + off, digest, MD5_DIGESTLENGTH);
+
+	return (0);
+}
+
+int dhcp6_verify_mac(char *buf, ssize_t len, int proto __attribute__((unused)),
+		 int alg, size_t off, struct keyinfo *key)
+{
+	hmacmd5_t ctx;
+	unsigned char digest[MD5_DIGESTLENGTH];
+	int result;
+
+	/* right now, we don't care about the protocol */
+
+	if (alg != DHCP6_AUTHALG_HMACMD5)
+		return (-1);
+
+	if (off + MD5_DIGESTLENGTH > len)
+		return (-1);
+
+	/*
+	 * Copy the MAC value and clear the field.
+	 * XXX: should we make a local working copy?
+	 */
+	memcpy(digest, buf + off, sizeof(digest));
+	memset(buf + off, 0, sizeof(digest));
+
+	hmacmd5_init(&ctx, key->secret, key->secretlen);
+	hmacmd5_update(&ctx, (unsigned char *)buf, len);
+	result = hmacmd5_verify(&ctx, digest);
+
+	/* copy back the digest value (XXX) */
+	memcpy(buf + off, digest, sizeof(digest));
+
+	return (result);
+}
+
+int dhcp6_auth_replaycheck(int method, uint64_t prev, uint64_t current)
+{
+
+	if (method != DHCP6_AUTHRDM_MONOCOUNTER) {
+		bb_error_msg("unsupported replay detection "
+		    "method (%d)", method);
+		return (-1);
+	}
+
+	log1("previous: %llx, current: %llx", SWAP_BE64(prev), SWAP_BE64(current));
+
+	prev = SWAP_BE64(prev);
+	current = SWAP_BE64(current);
+
+	/*
+	 * we call the singular point guilty, since we cannot guess
+	 * whether the serial number is increasing or not.
+	 */
+        if (prev == (current ^ 0x8000000000000000ULL)) {
+		bb_info_msg("detected a singular point");
+		return (1);
+	}
+
+	return (((int64_t)(current - prev) > 0) ? 0 : 1);
+}
+
+
+/*
+ * This code implements the HMAC-MD5 keyed hash algorithm
+ * described in RFC 2104.
+ */
+
+#define PADLEN 64
+#define IPAD 0x36
+#define OPAD 0x5C
+
+/*
+ * Start HMAC-MD5 process.  Initialize an md5 context and digest the key.
+ */
+static void hmacmd5_init(hmacmd5_t *ctx,
+				 const unsigned char *key, unsigned int len)
+{
+	unsigned char ipad[PADLEN];
+	int i;
+
+	memset(ctx->key, 0, sizeof(ctx->key));
+	if (len > sizeof(ctx->key)) {
+		md5_ctx_t md5ctx;
+		md5_begin(&md5ctx);
+		md5_hash(&md5ctx, key, len);
+		md5_end(&md5ctx, ctx->key);
+	} else
+		memcpy(ctx->key, key, len);
+
+	md5_begin(&ctx->md5ctx);
+	memset(ipad, IPAD, sizeof(ipad));
+	for (i = 0; i < PADLEN; i++)
+		ipad[i] ^= ctx->key[i];
+	md5_hash(&ctx->md5ctx, ipad, sizeof(ipad));
+}
+
+static ALWAYS_INLINE void hmacmd5_invalidate(hmacmd5_t *ctx)
+{
+	memset(ctx, 0, sizeof(ctx));
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+static ALWAYS_INLINE void hmacmd5_update(hmacmd5_t *ctx,
+				 const unsigned char *buf, unsigned int len)
+{
+	md5_hash(&ctx->md5ctx, buf, len);
+}
+
+/*
+ * Compute signature - finalize MD5 operation and reapply MD5.
+ */
+static void hmacmd5_sign(hmacmd5_t *ctx, unsigned char *digest)
+{
+	unsigned char opad[PADLEN];
+	int i;
+
+	md5_end(&ctx->md5ctx, digest);
+
+	memset(opad, OPAD, sizeof(opad));
+	for (i = 0; i < PADLEN; i++)
+		opad[i] ^= ctx->key[i];
+
+	md5_begin(&ctx->md5ctx);
+	md5_hash(&ctx->md5ctx, opad, sizeof(opad));
+	md5_hash(&ctx->md5ctx, digest, MD5_DIGESTLENGTH);
+	md5_end(&ctx->md5ctx, digest);
+	hmacmd5_invalidate(ctx);
+}
+
+/*
+ * Verify signature - finalize MD5 operation and reapply MD5, then
+ * compare to the supplied digest.
+ */
+static int hmacmd5_verify(hmacmd5_t *ctx, unsigned char *digest) {
+	unsigned char newdigest[MD5_DIGESTLENGTH];
+
+	hmacmd5_sign(ctx, newdigest);
+	return (memcmp(digest, newdigest, MD5_DIGESTLENGTH));
+}
+
diff -urNBp busybox.orig/networking/udhcp/auth6.h busybox/networking/udhcp/auth6.h
--- busybox.orig/networking/udhcp/auth6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/auth6.h	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2004 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#define MD5_DIGESTLENGTH 16
+
+/* secret key information for delayed authentication */
+struct keyinfo {
+	struct keyinfo *next;
+
+	char *name;		/* key name */
+
+	char *realm;		/* DHCP realm */
+	size_t realmlen;	/* length of realm */
+	uint32_t keyid;		/* key ID */
+	unsigned char *secret;	/* binary key */
+	size_t secretlen;	/* length of the key */
+	time_t expire;		/* expiration time (0 means forever) */
+};
+
+int dhcp6_validate_key(struct keyinfo *);
+int dhcp6_calc_mac(char *, size_t, int, int, size_t,
+    struct keyinfo *);
+int dhcp6_verify_mac(char *, ssize_t, int, int, size_t,
+    struct keyinfo *);
+int dhcp6_auth_replaycheck(int, uint64_t, uint64_t);
diff -urNBp busybox.orig/networking/udhcp/common6.c busybox/networking/udhcp/common6.c
--- busybox.orig/networking/udhcp/common6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/common6.c	2011-05-24 20:23:05.000000000 +0400
@@ -0,0 +1,2338 @@
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <sys/queue.h>
+#include <sys/stat.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#ifdef __FreeBSD__
+#include <net/if_var.h>
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <err.h>
+#include <netdb.h>
+#include <ifaddrs.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+
+/* dhcp6c.c */
+extern struct dhcp6_timer *client6_timo(void *);
+extern void destruct_iadata(struct dhcp6_eventdata *evd);
+
+#define MAXDNAME 255
+
+static ALWAYS_INLINE int dhcp6_count_list(struct dhcp6_list *);
+static int copyout_option(char *, char *, struct dhcp6_listval *);
+static int copyin_option(int, struct dhcp6opt *, struct dhcp6opt *,
+    struct dhcp6_list *);
+static int copy_option(uint16_t, uint16_t, void *, struct dhcp6opt **,
+    struct dhcp6opt *, int *);
+static int sa6_plen2mask(struct sockaddr_in6 *, int);
+static int in6_addrscopebyif(const struct in6_addr *, const char *);
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+static char *sprint_auth(struct dhcp6_optinfo *);
+#endif
+
+
+int dhcp6_copy_list(struct dhcp6_list *dst, struct dhcp6_list *src)
+{
+	struct dhcp6_listval *ent;
+
+	for (ent = TAILQ_FIRST(src); ent; ent = TAILQ_NEXT(ent, link)) {
+		if (dhcp6_add_listval(dst, ent->type,
+		    &ent->uv, &ent->sublist) == NULL)
+			goto fail;
+	}
+
+	return (0);
+
+fail:
+	dhcp6_clear_list(dst);
+	return (-1);
+}
+
+void dhcp6_move_list(struct dhcp6_list *dst, struct dhcp6_list *src)
+{
+	struct dhcp6_listval *v;
+
+	while ((v = TAILQ_FIRST(src)) != NULL) {
+		TAILQ_REMOVE(src, v, link);
+		TAILQ_INSERT_TAIL(dst, v, link);
+	}
+}
+
+void dhcp6_clear_list(struct dhcp6_list *head)
+{
+	struct dhcp6_listval *v;
+
+	while ((v = TAILQ_FIRST(head)) != NULL) {
+		TAILQ_REMOVE(head, v, link);
+		dhcp6_clear_listval(v);
+	}
+}
+
+static ALWAYS_INLINE int dhcp6_count_list(struct dhcp6_list *head)
+{
+	struct dhcp6_listval *v;
+	int i;
+
+	for (i = 0, v = TAILQ_FIRST(head); v; v = TAILQ_NEXT(v, link))
+		i++;
+
+	return (i);
+}
+
+void dhcp6_clear_listval(struct dhcp6_listval *lv)
+{
+	dhcp6_clear_list(&lv->sublist);
+	switch (lv->type) {
+	case DHCP6_LISTVAL_VBUF:
+		dhcp6_vbuf_free(&lv->val_vbuf);
+		break;
+	default:		/* nothing to do */
+		break;
+	}
+	free(lv);
+}
+
+/*
+ * Note: this function only searches for the first entry that matches
+ * VAL.  It also does not care about sublists.
+ */
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *head,
+		dhcp6_listval_type_t type, void *val, int option)
+{
+	struct dhcp6_listval *lv;
+
+	for (lv = TAILQ_FIRST(head); lv; lv = TAILQ_NEXT(lv, link)) {
+		if (lv->type != type)
+			continue;
+
+		switch (type) {
+		case DHCP6_LISTVAL_NUM:
+			if (lv->val_num == *(int *)val)
+				return (lv);
+			break;
+		case DHCP6_LISTVAL_STCODE:
+			if (lv->val_num16 == *(uint16_t *)val)
+				return (lv);
+			break;
+		case DHCP6_LISTVAL_ADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_addr6,
+			    (struct in6_addr *)val)) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_PREFIX6:
+			if ((option & MATCHLIST_PREFIXLEN) &&
+			    lv->val_prefix6.plen ==
+			    ((struct dhcp6_prefix *)val)->plen) {
+				return (lv);
+			} else if (IN6_ARE_ADDR_EQUAL(&lv->val_prefix6.addr,
+			    &((struct dhcp6_prefix *)val)->addr) &&
+			    lv->val_prefix6.plen ==
+			    ((struct dhcp6_prefix *)val)->plen) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			if (IN6_ARE_ADDR_EQUAL(&lv->val_statefuladdr6.addr,
+			    &((struct dhcp6_prefix *)val)->addr)) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_IAPD:
+		case DHCP6_LISTVAL_IANA:
+			if (lv->val_ia.iaid ==
+			    ((struct dhcp6_ia *)val)->iaid) {
+				return (lv);
+			}
+			break;
+		case DHCP6_LISTVAL_VBUF:
+			if (dhcp6_vbuf_cmp(&lv->val_vbuf,
+			    (struct dhcp6_vbuf *)val) == 0) {
+				return (lv);
+			}
+			break;
+		}
+	}
+
+	return (NULL);
+}
+
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *head,
+		dhcp6_listval_type_t type, void *val, struct dhcp6_list *sublist)
+{
+	struct dhcp6_listval *lv = NULL;
+
+	lv = xzalloc(sizeof(*lv));
+	lv->type = type;
+	TAILQ_INIT(&lv->sublist);
+
+	switch (type) {
+	case DHCP6_LISTVAL_NUM:
+		lv->val_num = *(int *)val;
+		break;
+	case DHCP6_LISTVAL_STCODE:
+		lv->val_num16 = *(uint16_t *)val;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		lv->val_addr6 = *(struct in6_addr *)val;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		lv->val_prefix6 = *(struct dhcp6_prefix *)val;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		lv->val_statefuladdr6 = *(struct dhcp6_statefuladdr *)val;
+		break;
+	case DHCP6_LISTVAL_IAPD:
+	case DHCP6_LISTVAL_IANA:
+		lv->val_ia = *(struct dhcp6_ia *)val;
+		break;
+	case DHCP6_LISTVAL_VBUF:
+		if (dhcp6_vbuf_copy(&lv->val_vbuf, (struct dhcp6_vbuf *)val))
+			goto fail;
+		break;
+	default:
+		bb_error_msg("unexpected list value type (%d)", type);
+		goto fail;
+	}
+
+	if (sublist && dhcp6_copy_list(&lv->sublist, sublist))
+		goto fail;
+
+	TAILQ_INSERT_TAIL(head, lv, link);
+
+	return (lv);
+
+  fail:
+	free(lv);
+
+	return (NULL);
+}
+
+int dhcp6_vbuf_copy(struct dhcp6_vbuf *dst, struct dhcp6_vbuf *src)
+{
+	dst->dv_buf = malloc_or_warn(src->dv_len);
+	if (dst->dv_buf == NULL)
+		return (-1);
+
+	dst->dv_len = src->dv_len;
+	memcpy(dst->dv_buf, src->dv_buf, dst->dv_len);
+
+	return (0);
+}
+
+void dhcp6_vbuf_free(struct dhcp6_vbuf *vbuf)
+{
+	free(vbuf->dv_buf);
+
+	vbuf->dv_len = 0;
+	vbuf->dv_buf = NULL;
+}
+
+int dhcp6_vbuf_cmp(struct dhcp6_vbuf *vb1, struct dhcp6_vbuf *vb2)
+{
+	if (vb1->dv_len != vb2->dv_len)
+		return (vb1->dv_len - vb2->dv_len);
+
+	return (memcmp(vb1->dv_buf, vb2->dv_buf, vb1->dv_len));
+}
+
+static int dhcp6_get_addr(int optlen, void *cp, dhcp6_listval_type_t type,
+			  struct dhcp6_list *list)
+{
+	void *val;
+
+	if (optlen % sizeof(struct in6_addr) || optlen == 0) {
+		bb_error_msg("malformed DHCP option: type %d, len %d",
+			type, optlen);
+		return -1;
+	}
+
+	for (val = cp; val < cp + optlen; val += sizeof(struct in6_addr)) {
+		struct in6_addr valaddr;
+
+		memcpy(&valaddr, val, sizeof(valaddr));
+		if (dhcp6_find_listval(list,
+		    DHCP6_LISTVAL_ADDR6, &valaddr, 0)) {
+			char a[INET6_ADDRSTRLEN];
+
+			sprint_nip6(a, (const uint8_t *)&valaddr);
+			bb_info_msg("duplicated %s address (%s)",
+			    dhcp6optstr(type), a);
+			continue;
+		}
+
+		if (dhcp6_add_listval(list, DHCP6_LISTVAL_ADDR6,
+		    &valaddr, NULL) == NULL) {
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static int dhcp6_set_addr(dhcp6_listval_type_t type, struct dhcp6_list *list,
+	       struct dhcp6opt **p, struct dhcp6opt *optep, int *len)
+{
+	struct in6_addr *in6;
+	char *tmpbuf;
+	struct dhcp6_listval *d;
+	int optlen;
+
+	if (TAILQ_EMPTY(list))
+		return 0;
+
+	optlen = dhcp6_count_list(list) * sizeof(struct in6_addr);
+	tmpbuf = xmalloc(optlen);
+	in6 = (struct in6_addr *)tmpbuf;
+	for (d = TAILQ_FIRST(list); d; d = TAILQ_NEXT(d, link), in6++)
+		memcpy(in6, &d->val_addr6, sizeof(*in6));
+	if (copy_option(type, optlen, tmpbuf, p, optep, len) != 0) {
+		free(tmpbuf);
+		return -1;
+	}
+
+	free(tmpbuf);
+	return 0;
+}
+#endif
+
+/* Domain names stored in RFC1035 format */
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY
+static int dhcp6_get_domain(int optlen, void *cp, dhcp6_listval_type_t type,
+			    struct dhcp6_list *list)
+{
+	char *names, *p, *n;
+
+	names = dname_dec(cp, optlen, "");
+	if (names == NULL) {
+		bb_info_msg("failed to decode a %s domain name",
+			    dhcp6optstr(type));
+		return -1;
+	}
+
+	p = names;
+	while (*p) {
+		struct dhcp6_vbuf vb;
+
+		n = strchrnul(p, ' ');
+		vb.dv_buf = p;
+		vb.dv_len = n - p;
+		if (*n)
+			*(n++) = '\0';
+
+		if (dhcp6_add_listval(list,
+		    DHCP6_LISTVAL_VBUF, &vb, NULL) == NULL) {
+			free(names);
+			return -2;
+		}
+		p = n;
+	}
+	free(names);
+
+	return 0;
+}
+#else
+static ALWAYS_INLINE int dhcp6_get_domain(int optlen __attribute__((unused)),
+    void *cp __attribute__((unused)),
+    dhcp6_listval_type_t type __attribute__((unused)),
+    struct dhcp6_list *list __attribute__((unused)))
+{
+    return 0;
+}
+#endif /* FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY */
+
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static int dhcp6_set_domain(dhcp6_listval_type_t type, struct dhcp6_list *list,
+			 struct dhcp6opt **p, struct dhcp6opt *optep, int *len)
+{
+	int rest, optlen = 0;
+	struct dhcp6_listval *d;
+	char *tmpbuf, *cp;
+
+	if (TAILQ_EMPTY(list))
+		return 0;
+
+	for (d = TAILQ_FIRST(list); d; d = TAILQ_NEXT(d, link))
+		optlen += (d->val_vbuf.dv_len + 1);
+
+	if (optlen == 0) {
+		return 0;
+	}
+
+	tmpbuf = NULL;
+	if ((tmpbuf = malloc_or_warn(optlen)) == NULL) {
+		return -1;
+	}
+	cp = tmpbuf;
+	rest = optlen;
+	for (d = TAILQ_FIRST(list); d; d = TAILQ_NEXT(d, link)) {
+		uint8_t *name;
+		int nlen;
+
+		name = dname_enc(NULL, 0, (const char *)d->val_vbuf.dv_buf, &nlen);
+		if (name == NULL) {
+			bb_error_msg("failed to encode a %s domain name",
+			    dhcp6optstr(type));
+			goto fail;
+		}
+		if (rest < nlen) {
+			bb_error_msg("buffer length for %s domain name is too short",
+			    dhcp6optstr(type));
+			goto fail;
+		}
+		memcpy(cp, name, nlen);
+		free(name);
+		cp += nlen;
+		rest -= nlen;
+	}
+
+	if (copy_option(type, optlen - rest, tmpbuf, p, optep, len) != 0) {
+		goto fail;
+	}
+
+	free(tmpbuf);
+	return 0;
+
+fail:
+	free(tmpbuf);
+	return -1;
+}
+#endif
+
+struct dhcp6_event *dhcp6_create_event(struct dhcp6_if *ifp, int state)
+{
+	struct dhcp6_event *ev;
+
+	ev = xzalloc(sizeof(*ev));
+	ev->ifp = ifp;
+	ev->state = state;
+	TAILQ_INIT(&ev->data_list);
+
+	TAILQ_INSERT_TAIL(&ifp->event_list, ev, link);
+
+	ev->timer = dhcp6_timer_add(client6_timo, ev);
+
+	return (ev);
+}
+
+void dhcp6_remove_event(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *sp, *sp_next;
+
+	log1("removing an event on %s, state=%s",
+	    ev->ifp->ifname, dhcp6_event_statestr(ev));
+
+	if (ev->timer)
+		dhcp6_timer_remove(&ev->timer);
+
+	dhcp6_remove_evdata(ev);
+	duidfree(&ev->serverid);
+	TAILQ_REMOVE(&ev->ifp->event_list, ev, link);
+
+	sp = ev->servers;
+	while (sp) {
+		sp_next = sp->next;
+
+		log1("removing server (ID: %s)", duidstr(&sp->optinfo.serverID));
+		dhcp6_clear_options(&sp->optinfo);
+		free(sp->authparam);
+		free(sp);
+		sp = sp_next;
+	}
+
+	free(ev->authparam);
+
+	free(ev);
+}
+
+void dhcp6_remove_evdata(struct dhcp6_event *ev)
+{
+	struct dhcp6_eventdata *evd;
+
+	while ((evd = TAILQ_FIRST(&ev->data_list)) != NULL) {
+		TAILQ_REMOVE(&ev->data_list, evd, link);
+		destruct_iadata(evd);
+	}
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+struct authparam *new_authparam(int proto, int alg, int rdm)
+{
+	struct authparam *authparam;
+
+	authparam = xzalloc(sizeof(*authparam));
+
+	authparam->authproto = proto;
+	authparam->authalgorithm = alg;
+	authparam->authrdm = rdm;
+	authparam->key = NULL;
+	authparam->flags |= AUTHPARAM_FLAGS_NOPREVRD;
+	authparam->prevrd = 0;
+
+	return (authparam);
+}
+
+struct authparam *copy_authparam(struct authparam *authparam)
+{
+	struct authparam *dst;
+
+	if ((dst = malloc_or_warn(sizeof(*dst))) == NULL)
+		return (NULL);
+
+	memcpy(dst, authparam, sizeof(*dst));
+
+	return (dst);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+int getifaddr(struct in6_addr *addr, char *ifnam,
+	      const struct in6_addr *prefix, int plen,
+	      int strong /* if strong host model is required or not */)
+{
+	struct ifaddrs *ifap, *ifa;
+	struct sockaddr_in6 sin6;
+	int error = -1;
+
+	if (getifaddrs(&ifap) != 0) {
+		bb_perror_msg("getifaddrs");
+		return (-1);
+	}
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		int s1, s2;
+
+		if (strong && strcmp(ifnam, ifa->ifa_name) != 0)
+			continue;
+
+		/* in any case, ignore interfaces in different scope zones. */
+		if ((s1 = in6_addrscopebyif(prefix, ifnam)) < 0 ||
+		    (s2 = in6_addrscopebyif(prefix, ifa->ifa_name)) < 0 ||
+		     s1 != s2)
+			continue;
+
+		if (ifa->ifa_addr->sa_family != AF_INET6)
+			continue;
+#ifdef HAVE_SA_LEN
+		if (ifa->ifa_addr->sa_len > sizeof(sin6))
+			continue;
+#endif
+
+		memcpy(&sin6, ifa->ifa_addr, sysdep_sa_len(ifa->ifa_addr));
+#ifdef __KAME__
+		if (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr)) {
+			sin6.sin6_addr.s6_addr[2] = 0;
+			sin6.sin6_addr.s6_addr[3] = 0;
+		}
+#endif
+		if (plen % 8 == 0) {
+			if (memcmp(&sin6.sin6_addr, prefix, plen / 8) != 0)
+				continue;
+		} else {
+			struct in6_addr a, m;
+			int i;
+
+			memcpy(&a, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
+			memset(&m, 0, sizeof(m));
+			memset(&m, 0xff, plen / 8);
+			m.s6_addr[plen / 8] = (0xff00 >> (plen % 8)) & 0xff;
+			for (i = 0; i < sizeof(a); i++)
+				a.s6_addr[i] &= m.s6_addr[i];
+
+			if (memcmp(&a, prefix, plen / 8) != 0 ||
+			    a.s6_addr[plen / 8] !=
+			    (prefix->s6_addr[plen / 8] & m.s6_addr[plen / 8]))
+				continue;
+		}
+		memcpy(addr, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
+#ifdef __KAME__
+		if (IN6_IS_ADDR_LINKLOCAL(addr))
+			addr->s6_addr[2] = addr->s6_addr[3] = 0; 
+#endif
+		error = 0;
+		break;
+	}
+
+	freeifaddrs(ifap);
+	return (error);
+}
+
+static int in6_addrscopebyif(const struct in6_addr *addr, const char *ifnam)
+{
+	unsigned ifindex;
+
+	if ((ifindex = if_nametoindex(ifnam)) == 0)
+		return (-1);
+
+	if (IN6_IS_ADDR_LINKLOCAL(addr) || IN6_IS_ADDR_MC_LINKLOCAL(addr))
+		return (ifindex);
+
+	if (IN6_IS_ADDR_SITELOCAL(addr) || IN6_IS_ADDR_MC_SITELOCAL(addr))
+		return (1);	/* XXX */
+
+	if (IN6_IS_ADDR_MC_ORGLOCAL(addr))
+		return (1);	/* XXX */
+
+	return (1);		/* treat it as global */
+}
+
+int prefix6_mask(struct in6_addr *in6, int plen)
+{
+	struct sockaddr_in6 mask6;
+	int i;
+
+	if (sa6_plen2mask(&mask6, plen))
+		return (-1);
+
+	for (i = 0; i < 16; i++)
+		in6->s6_addr[i] &= mask6.sin6_addr.s6_addr[i];
+
+	return (0);
+}
+
+static int sa6_plen2mask(struct sockaddr_in6 *sa6, int plen)
+{
+	u_char *cp;
+
+	if (plen < 0 || plen > 128)
+		return (-1);
+
+	memset(sa6, 0, sizeof(*sa6));
+	sa6->sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	sa6->sin6_len = sizeof(*sa6);
+#endif
+
+	for (cp = (u_char *)&sa6->sin6_addr; plen > 7; plen -= 8)
+		*cp++ = 0xff;
+	*cp = 0xff << (8 - plen);
+
+	return (0);
+}
+
+int get_duid(const char *idfile, struct duid *duid, int duid_type, char *ifname)
+{
+	FILE *fp = NULL;
+	uint16_t len = 0, hwtype = 1;
+	int hwlen = 0;
+	char tmpbuf[64];	/* HWID should be no more than 64 bytes */
+
+	if ((fp = fopen(idfile, "r")) == NULL && errno != ENOENT)
+		bb_info_msg("failed to open DUID file: %s", idfile);
+
+	memset(duid, 0, sizeof(*duid));
+	if (fp) {
+		/* decode length */
+		if (fread(&len, sizeof(len), 1, fp) != 1) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+		duid->duid_len = len;
+	} else {
+		if ((hwlen = gethwid(tmpbuf, ifname, &hwtype)) < 0) {
+			bb_error_msg("failed to get a hardware address");
+			goto fail;
+		}
+		len = hwlen + sizeof(union dhcp6opt_duid_type);
+	}
+
+	duid->duid_id = (char *)xmalloc(len);
+
+	/* copy (and fill) the ID */
+	if (fp) {
+		if (fread(duid->duid_id, len, 1, fp) != 1) {
+			bb_error_msg("DUID file corrupted");
+			goto fail;
+		}
+
+		log1("extracted an existing DUID from %s: %s",
+		    idfile, duidstr(duid));
+	} else {
+		/* we only support the types 1,3 DUID */
+		switch (duid_type) {
+			case 1: {
+				uint64_t t64;
+				struct dhcp6opt_duid_type1 *dp;
+
+				duid->duid_len = hwlen + sizeof(struct dhcp6opt_duid_type1);
+				dp = (struct dhcp6opt_duid_type1 *)duid->duid_id;
+				dp->dh6_duid1_type = htons(1); /* type 1 */
+				dp->dh6_duid1_hwtype = htons(hwtype);
+				/* time is Jan 1, 2000 (UTC), modulo 2^32 */
+				t64 = (uint64_t)(time(NULL) - 946684800);
+				dp->dh6_duid1_time = htonl((u_long)(t64 & 0xffffffff));
+				memcpy((void *)(dp + 1), tmpbuf, hwlen);
+				break;
+				}
+			case 3: {
+				struct dhcp6opt_duid_type3 *dp;
+
+				duid->duid_len = hwlen + sizeof(struct dhcp6opt_duid_type3);
+				dp = (struct dhcp6opt_duid_type3 *)duid->duid_id;
+				dp->dh6_duid3_type = htons(3); /* type 3 */
+				dp->dh6_duid3_hwtype = htons(hwtype);
+				memcpy((void *)(dp + 1), tmpbuf, hwlen);
+				break;
+				}
+		}
+
+		log1("generated a new DUID: %s", duidstr(duid));
+	}
+
+	/* save the (new) ID to the file for next time */
+	if (!fp) {
+		if ((fp = fopen(idfile, "w+")) == NULL) {
+			bb_error_msg("failed to write DUID file");
+			goto fail;
+		}
+		len = duid->duid_len;
+		if ((fwrite(&len, sizeof(len), 1, fp)) != 1) {
+			bb_error_msg("failed to write DUID file");
+			goto fail;
+		}
+		if ((fwrite(duid->duid_id, len, 1, fp)) != 1) {
+			bb_error_msg("failed to write DUID file");
+			goto fail;
+		}
+
+		log1("saved generated DUID to %s", idfile);
+	}
+
+	if (fp)
+		fclose(fp);
+	return (0);
+
+  fail:
+	if (fp)
+		fclose(fp);
+	duidfree(duid);
+	return (-1);
+}
+
+void dhcp6_init_options(struct dhcp6_optinfo *optinfo)
+{
+	memset(optinfo, 0, sizeof(*optinfo));
+
+	optinfo->pref = DH6OPT_PREF_UNDEF;
+	optinfo->elapsed_time = DH6OPT_ELAPSED_TIME_UNDEF;
+	optinfo->refreshtime = DH6OPT_REFRESHTIME_UNDEF;
+
+	TAILQ_INIT(&optinfo->iapd_list);
+	TAILQ_INIT(&optinfo->iana_list);
+	TAILQ_INIT(&optinfo->reqopt_list);
+	TAILQ_INIT(&optinfo->stcode_list);
+	TAILQ_INIT(&optinfo->sip_list);
+	TAILQ_INIT(&optinfo->sipname_list);
+	TAILQ_INIT(&optinfo->dns_list);
+	TAILQ_INIT(&optinfo->dnsname_list);
+	TAILQ_INIT(&optinfo->ntp_list);
+	TAILQ_INIT(&optinfo->prefix_list);
+	TAILQ_INIT(&optinfo->nis_list);
+	TAILQ_INIT(&optinfo->nisname_list);
+	TAILQ_INIT(&optinfo->nisp_list);
+	TAILQ_INIT(&optinfo->nispname_list);
+	TAILQ_INIT(&optinfo->bcmcs_list);
+	TAILQ_INIT(&optinfo->bcmcsname_list);
+
+	optinfo->authproto = DHCP6_AUTHPROTO_UNDEF;
+	optinfo->authalgorithm = DHCP6_AUTHALG_UNDEF;
+	optinfo->authrdm = DHCP6_AUTHRDM_UNDEF;
+}
+
+void dhcp6_clear_options(struct dhcp6_optinfo *optinfo)
+{
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		free(optinfo->delayedauth_realmval);
+		break;
+	}
+
+	duidfree(&optinfo->clientID);
+	duidfree(&optinfo->serverID);
+
+	dhcp6_clear_list(&optinfo->iapd_list);
+	dhcp6_clear_list(&optinfo->iana_list);
+	dhcp6_clear_list(&optinfo->reqopt_list);
+	dhcp6_clear_list(&optinfo->stcode_list);
+	dhcp6_clear_list(&optinfo->sip_list);
+	dhcp6_clear_list(&optinfo->sipname_list);
+	dhcp6_clear_list(&optinfo->dns_list);
+	dhcp6_clear_list(&optinfo->dnsname_list);
+	dhcp6_clear_list(&optinfo->ntp_list);
+	dhcp6_clear_list(&optinfo->prefix_list);
+	dhcp6_clear_list(&optinfo->nis_list);
+	dhcp6_clear_list(&optinfo->nisname_list);
+	dhcp6_clear_list(&optinfo->nisp_list);
+	dhcp6_clear_list(&optinfo->nispname_list);
+	dhcp6_clear_list(&optinfo->bcmcs_list);
+	dhcp6_clear_list(&optinfo->bcmcsname_list);
+
+	free(optinfo->relaymsg_msg);
+	free(optinfo->ifidopt_id);
+
+	dhcp6_init_options(optinfo);
+}
+
+int dhcp6_copy_options(struct dhcp6_optinfo *dst, struct dhcp6_optinfo *src)
+{
+	if (duidcpy(&dst->clientID, &src->clientID))
+		goto fail;
+	if (duidcpy(&dst->serverID, &src->serverID))
+		goto fail;
+	dst->rapidcommit = src->rapidcommit;
+
+	if (dhcp6_copy_list(&dst->iapd_list, &src->iapd_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->iana_list, &src->iana_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->reqopt_list, &src->reqopt_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->stcode_list, &src->stcode_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->sip_list, &src->sip_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->sipname_list, &src->sipname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->dns_list, &src->dns_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->dnsname_list, &src->dnsname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->ntp_list, &src->ntp_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->prefix_list, &src->prefix_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nis_list, &src->nis_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nisname_list, &src->nisname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nisp_list, &src->nisp_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->nispname_list, &src->nispname_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->bcmcs_list, &src->bcmcs_list))
+		goto fail;
+	if (dhcp6_copy_list(&dst->bcmcsname_list, &src->bcmcsname_list))
+		goto fail;
+	dst->elapsed_time = src->elapsed_time;
+	dst->refreshtime = src->refreshtime;
+	dst->pref = src->pref;
+
+	if (src->relaymsg_msg != NULL) {
+		dst->relaymsg_msg = xmalloc(src->relaymsg_len);
+		dst->relaymsg_len = src->relaymsg_len;
+		memcpy(dst->relaymsg_msg, src->relaymsg_msg,
+		    src->relaymsg_len);
+	}
+
+	if (src->ifidopt_id != NULL) {
+		dst->ifidopt_id = xmalloc(src->ifidopt_len);
+		dst->ifidopt_len = src->ifidopt_len;
+		memcpy(dst->ifidopt_id, src->ifidopt_id, src->ifidopt_len);
+	}
+
+	dst->authflags = src->authflags;
+	dst->authproto = src->authproto;
+	dst->authalgorithm = src->authalgorithm;
+	dst->authrdm = src->authrdm;
+	dst->authrd = src->authrd;
+
+	switch (src->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		dst->delayedauth_keyid = src->delayedauth_keyid;
+		dst->delayedauth_offset = src->delayedauth_offset;
+		dst->delayedauth_realmlen = src->delayedauth_realmlen;
+		if (src->delayedauth_realmval != NULL) {
+			if ((dst->delayedauth_realmval =
+			    malloc_or_warn(src->delayedauth_realmlen)) == NULL) {
+				goto fail;
+			}
+			memcpy(dst->delayedauth_realmval,
+			    src->delayedauth_realmval,
+			    src->delayedauth_realmlen);
+		}
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		dst->reconfigauth_type = src->reconfigauth_type;
+		dst->reconfigauth_offset = src->reconfigauth_offset;
+		memcpy(dst->reconfigauth_val, src->reconfigauth_val,
+		    sizeof(dst->reconfigauth_val));
+		break;
+#endif
+	}
+
+	return (0);
+
+  fail:
+	/* cleanup temporary resources */
+	dhcp6_clear_options(dst);
+	return (-1);
+}
+
+int dhcp6_get_options(struct dhcp6opt *p, struct dhcp6opt *ep,
+			struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *np, opth;
+	int i, opt, optlen, reqopts, num;
+	uint16_t num16;
+	char *bp, *cp, *val;
+	uint16_t val16;
+	uint32_t val32;
+	struct dhcp6opt_ia optia;
+	struct dhcp6_ia ia;
+	struct dhcp6_list sublist;
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
+	int authinfolen;
+#endif
+
+	bp = (char *)p;
+	for (; p + 1 <= ep; p = np) {
+		struct duid duid0;
+
+		/*
+		 * get the option header.  XXX: since there is no guarantee
+		 * about the header alignment, we need to make a local copy.
+		 */
+		memcpy(&opth, p, sizeof(opth));
+		optlen = ntohs(opth.dh6opt_len);
+		opt = ntohs(opth.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP option %s, len %d", dhcp6optstr(opt), optlen);
+
+		/* option length field overrun */
+		if (np > ep)
+			goto malformed;
+
+		switch (opt) {
+		case DH6OPT_CLIENTID:
+			if (optlen == 0)
+				goto malformed;
+			duid0.duid_len = optlen;
+			duid0.duid_id = cp;
+			log1("  DUID: %s", duidstr(&duid0));
+			if (duidcpy(&optinfo->clientID, &duid0))
+				goto fail;
+			break;
+		case DH6OPT_SERVERID:
+			if (optlen == 0)
+				goto malformed;
+			duid0.duid_len = optlen;
+			duid0.duid_id = cp;
+			log2("  DUID: %s", duidstr(&duid0));
+			if (duidcpy(&optinfo->serverID, &duid0))
+				goto fail;
+			break;
+		case DH6OPT_STATUS_CODE:
+			if (optlen < sizeof(uint16_t))
+				goto malformed;
+			memcpy(&val16, cp, sizeof(val16));
+			num16 = ntohs(val16);
+			log2("  status code: %s",
+			    dhcp6_stcodestr(num16));
+
+			/* need to check duplication? */
+
+			if (dhcp6_add_listval(&optinfo->stcode_list,
+			    DHCP6_LISTVAL_STCODE, &num16, NULL) == NULL) {
+				goto fail;
+			}
+
+			break;
+		case DH6OPT_ORO:
+			if ((optlen % 2) != 0 || optlen == 0)
+				goto malformed;
+			reqopts = optlen / 2;
+			for (i = 0, val = cp; i < reqopts;
+			     i++, val += sizeof(uint16_t)) {
+				uint16_t opttype;
+
+				memcpy(&opttype, val, sizeof(uint16_t));
+				num = (int)ntohs(opttype);
+
+				log2("  requested option: %s",
+					dhcp6optstr(num));
+
+				if (dhcp6_find_listval(&optinfo->reqopt_list,
+				    DHCP6_LISTVAL_NUM, &num, 0)) {
+					bb_info_msg("duplicated "
+					    "option type (%s)",
+					    dhcp6optstr(opttype));
+					goto nextoption;
+				}
+
+				if (dhcp6_add_listval(&optinfo->reqopt_list,
+				    DHCP6_LISTVAL_NUM, &num, NULL) == NULL) {
+					goto fail;
+				}
+			  nextoption:
+				;
+			}
+			break;
+		case DH6OPT_PREFERENCE:
+			if (optlen != 1)
+				goto malformed;
+			log2("  preference: %d", (int)*(u_char *)cp);
+			if (optinfo->pref != DH6OPT_PREF_UNDEF) {
+				bb_info_msg("duplicated preference option");
+			} else
+				optinfo->pref = (int)*(u_char *)cp;
+			break;
+		case DH6OPT_ELAPSED_TIME:
+			if (optlen != 2)
+				goto malformed;
+			memcpy(&val16, cp, sizeof(val16));
+			val16 = ntohs(val16);
+			log2("  elapsed time: %u", (uint32_t)val16);
+			if (optinfo->elapsed_time !=
+			    DH6OPT_ELAPSED_TIME_UNDEF) {
+				bb_info_msg("duplicated elapsed time option");
+			} else
+				optinfo->elapsed_time = val16;
+			break;
+		case DH6OPT_RELAY_MSG:
+			optinfo->relaymsg_msg = xmalloc(optlen);
+			memcpy(optinfo->relaymsg_msg, cp, optlen);
+			optinfo->relaymsg_len = optlen;
+			break;
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
+		case DH6OPT_AUTH:
+			if (optlen < sizeof(struct dhcp6opt_auth) - 4)
+				goto malformed;
+
+			/*
+			 * Any DHCP message that includes more than one
+			 * authentication option MUST be discarded.
+			 * [RFC3315 Section 21.4.2]
+			 */
+			if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
+				bb_info_msg("found more than one "
+				    "authentication option");
+				goto fail;
+			}
+
+			optinfo->authproto = *cp++;
+			optinfo->authalgorithm = *cp++;
+			optinfo->authrdm = *cp++;
+			memcpy(&optinfo->authrd, cp, sizeof(optinfo->authrd));
+			cp += sizeof(optinfo->authrd);
+
+			log2("  %s", sprint_auth(optinfo));
+
+			authinfolen =
+			    optlen - (sizeof(struct dhcp6opt_auth) - 4);
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				if (authinfolen == 0) {
+					optinfo->authflags |=
+					    DHCP6OPT_AUTHFLAG_NOINFO;
+					break;
+				}
+				/* XXX: should we reject an empty realm? */
+				if (authinfolen <
+				    sizeof(optinfo->delayedauth_keyid) + 16) {
+					goto malformed;
+				}
+
+				optinfo->delayedauth_realmlen = authinfolen -
+				    (sizeof(optinfo->delayedauth_keyid) + 16);
+				optinfo->delayedauth_realmval =
+				    malloc_or_warn(optinfo->delayedauth_realmlen);
+				if (optinfo->delayedauth_realmval == NULL)
+					goto fail;
+				memcpy(optinfo->delayedauth_realmval, cp,
+				    optinfo->delayedauth_realmlen);
+				cp += optinfo->delayedauth_realmlen;
+
+				memcpy(&optinfo->delayedauth_keyid, cp,
+				    sizeof(optinfo->delayedauth_keyid));
+				optinfo->delayedauth_keyid =
+				    ntohl(optinfo->delayedauth_keyid);
+				cp += sizeof(optinfo->delayedauth_keyid);
+
+				optinfo->delayedauth_offset = cp - bp;
+				cp += 16;
+
+				log2("  auth key ID: %x, "
+				    "offset=%d, realmlen=%d",
+				    optinfo->delayedauth_keyid,
+				    optinfo->delayedauth_offset,
+				    optinfo->delayedauth_realmlen);
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+				break;
+#endif
+			default:
+				bb_info_msg("unsupported authentication protocol: %d",
+				    *cp);
+				goto fail;
+			}
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY */
+		case DH6OPT_RAPID_COMMIT:
+			if (optlen != 0)
+				goto malformed;
+			optinfo->rapidcommit = 1;
+			break;
+		case DH6OPT_INTERFACE_ID:
+			optinfo->ifidopt_id = xmalloc(optlen);
+			memcpy(optinfo->ifidopt_id, cp, optlen);
+			optinfo->ifidopt_len = optlen;
+			break;
+		case DH6OPT_SIP_SERVER_D:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->sipname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_DNSNAME:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->dnsname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NIS_DOMAIN_NAME:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->nisname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NISP_DOMAIN_NAME:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->nispname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_BCMCS_SERVER_D:
+			if (dhcp6_get_domain(optlen, cp, opt,
+			    &optinfo->bcmcsname_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_SIP_SERVER_A:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->sip_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_DNS:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->dns_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NIS_SERVERS:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->nis_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NISP_SERVERS:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->nisp_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_BCMCS_SERVER_A:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->bcmcs_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_NTP:
+			if (dhcp6_get_addr(optlen, cp, opt,
+			    &optinfo->ntp_list) == -1)
+				goto fail;
+			break;
+		case DH6OPT_IA_PD:
+			if (optlen + sizeof(struct dhcp6opt) <
+			    sizeof(optia))
+				goto malformed;
+			memcpy(&optia, p, sizeof(optia));
+			ia.iaid = ntohl(optia.dh6_ia_iaid);
+			ia.t1 = ntohl(optia.dh6_ia_t1);
+			ia.t2 = ntohl(optia.dh6_ia_t2);
+
+			log2("  IA_PD: ID=%u, T1=%u, T2=%u",
+			    ia.iaid, ia.t1, ia.t2);
+
+			/* duplication check */
+			if (dhcp6_find_listval(&optinfo->iapd_list,
+			    DHCP6_LISTVAL_IAPD, &ia, 0)) {
+				bb_info_msg("duplicated IA_PD %u", ia.iaid);
+				break; /* ignore this IA_PD */
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p + sizeof(optia)),
+			    (struct dhcp6opt *)(cp + optlen), &sublist)) {
+				goto fail;
+			}
+
+			/* link this option set */
+			if (dhcp6_add_listval(&optinfo->iapd_list,
+			    DHCP6_LISTVAL_IAPD, &ia, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+
+			break;
+		case DH6OPT_REFRESHTIME:
+			if (optlen != 4)
+				goto malformed;
+			memcpy(&val32, cp, sizeof(val32));
+			val32 = ntohl(val32);
+			log2("   information refresh time: %u", val32);
+			if (val32 < DHCP6_IRT_MINIMUM) {
+				/*
+				 * A client MUST use the refresh time
+				 * IRT_MINIMUM if it receives the option with a
+				 * value less than IRT_MINIMUM.
+				 * [draft-ietf-dhc-lifetime-02.txt,
+				 *  Section 3.2]
+				 */
+				bb_info_msg(
+				    "refresh time is too small (%d), adjusted",
+				    val32);
+				val32 = DHCP6_IRT_MINIMUM;
+			}
+			if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+				bb_info_msg("duplicated refresh time option");
+			} else
+				optinfo->refreshtime = (int64_t)val32;
+			break;
+		case DH6OPT_IA_NA:
+			if (optlen + sizeof(struct dhcp6opt) <
+			    sizeof(optia))
+				goto malformed;
+			memcpy(&optia, p, sizeof(optia));
+			ia.iaid = ntohl(optia.dh6_ia_iaid);
+			ia.t1 = ntohl(optia.dh6_ia_t1);
+			ia.t2 = ntohl(optia.dh6_ia_t2);
+
+			log2("  IA_NA: ID=%u, T1=%u, T2=%u",
+			    ia.iaid, ia.t1, ia.t2);
+
+			/* duplication check */
+			if (dhcp6_find_listval(&optinfo->iana_list,
+			    DHCP6_LISTVAL_IANA, &ia, 0)) {
+				bb_info_msg("duplicated IA_NA %u", ia.iaid);
+				break; /* ignore this IA_NA */
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p + sizeof(optia)),
+			    (struct dhcp6opt *)(cp + optlen), &sublist)) {
+				goto fail;
+			}
+
+			/* link this option set */
+			if (dhcp6_add_listval(&optinfo->iana_list,
+			    DHCP6_LISTVAL_IANA, &ia, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+
+			break;
+		default:
+			/* no option specific behavior */
+			bb_info_msg("unexpected DHCP6 option %s, len %d",
+			    dhcp6optstr(opt), optlen);
+			break;
+		}
+	}
+
+	return (0);
+
+  malformed:
+	bb_error_msg("malformed DHCP option: type %d, len %d", opt, optlen);
+  fail:
+	dhcp6_clear_options(optinfo);
+	return (-1);
+}
+
+static int copyin_option(int type, struct dhcp6opt *p, struct dhcp6opt *ep,
+			 struct dhcp6_list *list)
+{
+	int opt, optlen;
+	char *cp;
+	struct dhcp6opt *np, opth;
+	struct dhcp6opt_stcode opt_stcode;
+	struct dhcp6opt_ia_pd_prefix opt_iapd_prefix;
+	struct dhcp6_prefix iapd_prefix;
+	struct dhcp6opt_ia_addr opt_ia_addr;
+	struct dhcp6_prefix ia_addr;
+	struct dhcp6_list sublist;
+	char a[INET6_ADDRSTRLEN];
+
+	TAILQ_INIT(&sublist);
+
+	for (; p + 1 <= ep; p = np) {
+		memcpy(&opth, p, sizeof(opth));
+		optlen = ntohs(opth.dh6opt_len);
+		opt = ntohs(opth.dh6opt_type);
+
+		cp = (char *)(p + 1);
+		np = (struct dhcp6opt *)(cp + optlen);
+
+		log2("get DHCP option %s, len %d", dhcp6optstr(opt), optlen);
+
+		if (np > ep)
+			goto malformed;
+
+		switch (opt) {
+		case DH6OPT_IA_PD_PREFIX:
+			/* check option context */
+			if (type != DH6OPT_IA_PD) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			/* check option length */
+			if (optlen + sizeof(opth) < sizeof(opt_iapd_prefix))
+				goto malformed;
+
+			/* copy and convert option values */
+			memcpy(&opt_iapd_prefix, p, sizeof(opt_iapd_prefix));
+			if (opt_iapd_prefix.dh6_iapd_prefix_prefix_len > 128) {
+				bb_info_msg("invalid prefix length: %d",
+				    opt_iapd_prefix.dh6_iapd_prefix_prefix_len);
+				goto malformed;
+			}
+			iapd_prefix.pltime = ntohl(opt_iapd_prefix.dh6_iapd_prefix_preferred_time);
+			iapd_prefix.vltime = ntohl(opt_iapd_prefix.dh6_iapd_prefix_valid_time);
+			iapd_prefix.plen =  opt_iapd_prefix.dh6_iapd_prefix_prefix_len;
+			memcpy(&iapd_prefix.addr,
+			    &opt_iapd_prefix.dh6_iapd_prefix_prefix_addr,
+			    sizeof(iapd_prefix.addr));
+			/* clear padding bits in the prefix address */
+			prefix6_mask(&iapd_prefix.addr, iapd_prefix.plen);
+
+			
+			sprint_nip6(a, (const uint8_t *)&iapd_prefix.addr),
+			log2("  IA_PD prefix: %s/%d pltime=%u vltime=%u",
+			    a, iapd_prefix.plen,
+			    iapd_prefix.pltime, iapd_prefix.vltime);
+
+			if (dhcp6_find_listval(list, DHCP6_LISTVAL_PREFIX6,
+			    &iapd_prefix, 0)) {
+				bb_info_msg("duplicated %s %s/%d",
+				    dhcp6optstr(opt), a, iapd_prefix.plen );
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p +
+			    sizeof(opt_iapd_prefix)), np, &sublist)) {
+				goto fail;
+			}
+
+			if (dhcp6_add_listval(list, DHCP6_LISTVAL_PREFIX6,
+			    &iapd_prefix, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+			break;
+		case DH6OPT_IAADDR:
+			/* check option context */
+			if (type != DH6OPT_IA_NA) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto fail;
+			}
+			/* check option length */
+			if (optlen + sizeof(opth) < sizeof(opt_ia_addr))
+				goto malformed;
+
+			/* copy and convert option values */
+			memcpy(&opt_ia_addr, p, sizeof(opt_ia_addr));
+			ia_addr.pltime = ntohl(opt_ia_addr.dh6_ia_addr_preferred_time);
+			ia_addr.vltime = ntohl(opt_ia_addr.dh6_ia_addr_valid_time);
+			memcpy(&ia_addr.addr, &opt_ia_addr.dh6_ia_addr_addr,
+			    sizeof(ia_addr.addr));
+
+			sprint_nip6(a, (const uint8_t *)&ia_addr.addr);
+			log2("  IA_NA address: %s pltime=%u vltime=%u",
+			    a, ia_addr.pltime, ia_addr.vltime);
+
+			if (dhcp6_find_listval(list,
+			    DHCP6_LISTVAL_STATEFULADDR6, &ia_addr, 0)) {
+				bb_info_msg("duplicated IA_NA address %s", a);
+				goto nextoption;
+			}
+
+			/* take care of sub-options */
+			TAILQ_INIT(&sublist);
+			if (copyin_option(opt,
+			    (struct dhcp6opt *)((char *)p +
+			    sizeof(opt_ia_addr)), np, &sublist)) {
+				goto fail;
+			}
+
+			if (dhcp6_add_listval(list, DHCP6_LISTVAL_STATEFULADDR6,
+			    &ia_addr, &sublist) == NULL) {
+				dhcp6_clear_list(&sublist);
+				goto fail;
+			}
+			dhcp6_clear_list(&sublist);
+			break;
+		case DH6OPT_STATUS_CODE:
+			/* check option context */
+			if (type != DH6OPT_IA_PD &&
+			    type != DH6OPT_IA_PD_PREFIX &&
+			    type != DH6OPT_IA_NA &&
+			    type != DH6OPT_IAADDR) {
+				bb_info_msg("%s is an invalid position for %s",
+				    dhcp6optstr(type), dhcp6optstr(opt));
+				goto nextoption; /* or discard the message? */
+			}
+			/* check option length */
+			if (optlen + sizeof(opth) < sizeof(opt_stcode))
+				goto malformed;
+
+			/* copy and convert option values */
+			memcpy(&opt_stcode, p, sizeof(opt_stcode));
+			opt_stcode.dh6_stcode_code =
+			    ntohs(opt_stcode.dh6_stcode_code);
+
+			log2("  status code: %s",
+			    dhcp6_stcodestr(opt_stcode.dh6_stcode_code));
+
+			/* duplication check */
+			if (dhcp6_find_listval(list, DHCP6_LISTVAL_STCODE,
+			    &opt_stcode.dh6_stcode_code, 0)) {
+				bb_info_msg("duplicated status code (%d)",
+				    opt_stcode.dh6_stcode_code);
+				goto nextoption;
+			}
+
+			/* copy-in the code value */
+			if (dhcp6_add_listval(list, DHCP6_LISTVAL_STCODE,
+			    &opt_stcode.dh6_stcode_code, NULL) == NULL)
+				goto fail;
+
+			break;
+		}
+	  nextoption:
+		;
+	}
+
+	return (0);
+
+  malformed:
+	bb_info_msg("malformed DHCP option: type %d, len %d", opt, optlen);
+
+  fail:
+	dhcp6_clear_list(&sublist);
+	return (-1);
+}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
+static char *sprint_auth(struct dhcp6_optinfo *optinfo)
+{
+	static char ret[1024];	/* XXX: thread unsafe */
+	const char *proto, *alg, *rdm;
+	char proto0[16], alg0[16], rdm0[16];
+
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_DELAYED:
+		proto = "delayed";
+		break;
+#ifdef notyet
+	case DHCP6_AUTHPROTO_RECONFIG:
+		proto = "reconfig";
+		break;
+#endif
+	default:
+		snprintf(proto0, sizeof(proto0), "unknown(%d)",
+		    optinfo->authproto & 0xff);
+		proto = proto0;
+		break;
+	}
+
+	switch (optinfo->authalgorithm) {
+	case DHCP6_AUTHALG_HMACMD5:
+		alg = "HMAC-MD5";
+		break;
+	default:
+		snprintf(alg0, sizeof(alg0), "unknown(%d)",
+		    optinfo->authalgorithm & 0xff);
+		alg = alg0;
+		break;
+	}
+
+	switch (optinfo->authrdm) {
+	case DHCP6_AUTHRDM_MONOCOUNTER:
+		rdm = "mono counter";
+		break;
+	default:
+		snprintf(rdm0, sizeof(rdm0), "unknown(%d)", optinfo->authrdm);
+		rdm = rdm0;
+	}
+
+	snprintf(ret, sizeof(ret), "proto: %s, alg: %s, RDM: %s, RD: %llx",
+	    proto, alg, rdm,
+	    SWAP_BE64(optinfo->authrd));
+
+	return (ret);
+}
+#endif
+
+static int copy_option(uint16_t type, uint16_t len, void *val,
+		struct dhcp6opt **optp, struct dhcp6opt *ep, int *totallenp)
+{
+	struct dhcp6opt *opt = *optp, opth;
+
+	if ((void *)ep - (void *)optp < len + sizeof(struct dhcp6opt)) {
+		log1("option buffer short for %s", dhcp6optstr(type));
+		return (-1);
+	}
+	opth.dh6opt_type = htons(type);
+	opth.dh6opt_len = htons(len);
+	memcpy(opt, &opth, sizeof(opth));
+	if (len != 0)
+		memcpy(opt + 1, val, len);
+
+	*optp = (struct dhcp6opt *)((char *)(opt + 1) + len);
+ 	*totallenp += sizeof(struct dhcp6opt) + len;
+	log2("set %s (len %d)", dhcp6optstr(type), len);
+
+	return (0);
+}
+
+int dhcp6_set_options(int type, struct dhcp6opt *optbp, struct dhcp6opt *optep,
+		struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6opt *p = optbp;
+	struct dhcp6_listval *stcode, *op;
+	int len = 0, opt_len;
+	char *tmpbuf = NULL;
+
+	if (optinfo->clientID.duid_len) {
+		if (copy_option(DH6OPT_CLIENTID, optinfo->clientID.duid_len,
+		    optinfo->clientID.duid_id, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->serverID.duid_len) {
+		if (copy_option(DH6OPT_SERVERID, optinfo->serverID.duid_len,
+		    optinfo->serverID.duid_id, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	for (op = TAILQ_FIRST(&optinfo->iana_list); op;
+	    op = TAILQ_NEXT(op, link)) {
+		int opt_len1;
+
+		tmpbuf = NULL;
+		if ((opt_len1 = copyout_option(NULL, NULL, op)) < 0) {
+			bb_info_msg("failed to count option length");
+			goto fail;
+		}
+		if ((void *)optep - (void *)p < opt_len1) {
+			bb_info_msg("short buffer");
+			goto fail;
+		}
+		tmpbuf = xmalloc(opt_len1);
+		if (copyout_option(tmpbuf, tmpbuf + opt_len1, op) < 0) {
+			bb_error_msg("failed to construct an %s option", "IA_NA");
+			goto fail;
+		}
+		memcpy(p, tmpbuf, opt_len1);
+		free(tmpbuf);
+		tmpbuf = NULL;
+		p = (struct dhcp6opt *)((char *)p + opt_len1);
+		len += opt_len1;
+	}
+
+	if (optinfo->rapidcommit) {
+		if (copy_option(DH6OPT_RAPID_COMMIT, 0, NULL, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->pref != DH6OPT_PREF_UNDEF) {
+		uint8_t p8 = (uint8_t)optinfo->pref;
+
+		if (copy_option(DH6OPT_PREFERENCE, sizeof(p8), &p8, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->elapsed_time != DH6OPT_ELAPSED_TIME_UNDEF) {
+		uint16_t p16 = (uint16_t)optinfo->elapsed_time;
+
+		p16 = htons(p16);
+		if (copy_option(DH6OPT_ELAPSED_TIME, sizeof(p16), &p16, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	for (stcode = TAILQ_FIRST(&optinfo->stcode_list); stcode;
+	     stcode = TAILQ_NEXT(stcode, link)) {
+		uint16_t code;
+
+		code = htons(stcode->val_num16);
+		if (copy_option(DH6OPT_STATUS_CODE, sizeof(code), &code, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->reqopt_list)) {
+		struct dhcp6_listval *opt;
+		uint16_t *valp;
+		int buflen;
+
+		buflen = dhcp6_count_list(&optinfo->reqopt_list) *
+			sizeof(uint16_t);
+		tmpbuf = xmalloc(buflen);
+		opt_len = 0;
+		valp = (uint16_t *)tmpbuf;
+		for (opt = TAILQ_FIRST(&optinfo->reqopt_list); opt;
+		     opt = TAILQ_NEXT(opt, link)) {
+			/*
+			 * Information request option can only be specified
+			 * in information-request messages.
+			 * [draft-ietf-dhc-lifetime-02.txt, Section 3.2]
+			 */
+			if (opt->val_num == DH6OPT_REFRESHTIME &&
+			    type != DH6_INFORM_REQ) {
+				log1("refresh time option is not requested "
+				    "for %s", dhcp6msgstr(type));
+			}
+
+			*valp = htons((uint16_t)opt->val_num);
+			valp++;
+			opt_len += sizeof(uint16_t);
+		}
+		if (opt_len > 0 &&
+		    copy_option(DH6OPT_ORO, opt_len, tmpbuf, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+		free(tmpbuf);
+		tmpbuf = NULL;
+	}
+
+#if /*ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+	if (dhcp6_set_domain(DH6OPT_SIP_SERVER_D, &optinfo->sipname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_SIP_SERVER_A, &optinfo->sip_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_DNS, &optinfo->dns_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_DNSNAME, &optinfo->dnsname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_NIS_SERVERS, &optinfo->nis_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_NISP_SERVERS, &optinfo->nisp_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_NIS_DOMAIN_NAME, &optinfo->nisname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_NISP_DOMAIN_NAME, &optinfo->nispname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_NTP, &optinfo->ntp_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(DH6OPT_BCMCS_SERVER_D, &optinfo->bcmcsname_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(DH6OPT_BCMCS_SERVER_A, &optinfo->bcmcs_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+#endif /* ENABLE_DHCP6S || ENABLE_DHCP6RELAY */
+
+	for (op = TAILQ_FIRST(&optinfo->iapd_list); op;
+	    op = TAILQ_NEXT(op, link)) {
+		int opt_len1;
+
+		tmpbuf = NULL;
+		if ((opt_len1 = copyout_option(NULL, NULL, op)) < 0) {
+			bb_info_msg("failed to count option length");
+			goto fail;
+		}
+		if ((void *)optep - (void *)p < opt_len1) {
+			bb_info_msg("short buffer");
+			goto fail;
+		}
+		tmpbuf = xmalloc(opt_len1);
+		if (copyout_option(tmpbuf, tmpbuf + opt_len1, op) < 0) {
+			bb_error_msg("failed to construct an %s option", "IA_PD");
+			goto fail;
+		}
+		memcpy(p, tmpbuf, opt_len1);
+		free(tmpbuf);
+		tmpbuf = NULL;
+		p = (struct dhcp6opt *)((char *)p + opt_len1);
+		len += opt_len1;
+	}
+
+	if (optinfo->relaymsg_len) {
+		if (copy_option(DH6OPT_RELAY_MSG, optinfo->relaymsg_len,
+		    optinfo->relaymsg_msg, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->ifidopt_id) {
+		if (copy_option(DH6OPT_INTERFACE_ID, optinfo->ifidopt_len,
+		    optinfo->ifidopt_id, &p, optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+	if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+		uint32_t p32 = (uint32_t)optinfo->refreshtime;
+
+		p32 = htonl(p32);
+		if (copy_option(DH6OPT_REFRESHTIME, sizeof(p32), &p32, &p,
+		    optep, &len) != 0) {
+			goto fail;
+		}
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
+	if (optinfo->authproto != DHCP6_AUTHPROTO_UNDEF) {
+		struct dhcp6opt_auth *auth;
+		int authlen;
+		char *authinfo;
+
+		authlen = sizeof(*auth);
+		if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				/* Realm + key ID + HMAC-MD5 */
+				authlen += optinfo->delayedauth_realmlen +
+				    sizeof(optinfo->delayedauth_keyid) + 16;
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+				/* type + key-or-HAMC */
+				authlen += 17;
+				break;
+#endif
+			default:
+				bb_error_msg("unsupported authentication protocol: %d",
+					    optinfo->authproto);
+				goto fail;
+			}
+		}
+
+		auth = xzalloc(authlen);
+		/* copy_option will take care of type and len later */
+		auth->dh6_auth_proto = (uint8_t)optinfo->authproto;
+		auth->dh6_auth_alg = (uint8_t)optinfo->authalgorithm;
+		auth->dh6_auth_rdm = (uint8_t)optinfo->authrdm;
+		memcpy(auth->dh6_auth_rdinfo, &optinfo->authrd,
+		    sizeof(auth->dh6_auth_rdinfo));
+
+		if (!(optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			uint32_t p32;
+
+			switch (optinfo->authproto) {
+			case DHCP6_AUTHPROTO_DELAYED:
+				authinfo = (char *)(auth + 1);
+
+				/* copy realm */
+				memcpy(authinfo, optinfo->delayedauth_realmval,
+				    optinfo->delayedauth_realmlen);
+				authinfo += optinfo->delayedauth_realmlen;
+
+				/* copy key ID (need memcpy for alignment) */
+				p32 = htonl(optinfo->delayedauth_keyid);
+				memcpy(authinfo, &p32, sizeof(p32));
+
+				/*
+				 * Set the offset so that the caller can
+				 * calculate the HMAC.
+				 */
+				optinfo->delayedauth_offset =
+				    ((char *)p - (char *)optbp) + authlen - 16;
+
+				log1("key ID %x, offset %d",
+				    optinfo->delayedauth_keyid,
+				    optinfo->delayedauth_offset); 
+				break;
+#ifdef notyet
+			case DHCP6_AUTHPROTO_RECONFIG:
+#endif
+			default:
+				bb_error_msg("unsupported authentication protocol: %d",
+					    optinfo->authproto);
+				free(auth);
+				goto fail;
+			}
+		}
+
+		if (copy_option(DH6OPT_AUTH, authlen - 4,
+		    &auth->dh6_auth_proto, &p, optep, &len) != 0) {
+			goto fail;
+		}
+		free(auth);
+	}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY */
+
+	return (len);
+
+  fail:
+	free(tmpbuf);
+	return (-1);
+}
+
+/*
+ * Construct a DHCPv6 option along with sub-options in the wire format.
+ * If the packet buffer is NULL, just calculate the length of the option
+ * (and sub-options) so that the caller can allocate a buffer to store the
+ * option(s).
+ * This function basically assumes that the caller prepares enough buffer to
+ * store all the options.  However, it also takes the buffer end and checks
+ * the possibility of overrun for safety.
+ */
+static int copyout_option(char *p, char *ep, struct dhcp6_listval *optval)
+{
+	union {
+		struct dhcp6opt_stcode stcodeopt;
+		struct dhcp6opt_ia ia;
+		struct dhcp6opt_ia_pd_prefix pd_prefix;
+		struct dhcp6opt_ia_addr ia_addr;
+	} u;
+	struct dhcp6opt *opt = (struct dhcp6opt *)(void *)&u;
+	char *subp;
+	struct dhcp6_listval *subov;
+	int opt_len, headlen, sublen, opttype;
+
+	/* check invariant for safety */
+	if (p && ep <= p)
+		return (-1);
+
+	memset(&u, 0, sizeof(u));
+
+	/* first, detect the length of the option head */
+	switch (optval->type) {
+	case DHCP6_LISTVAL_IAPD:
+		headlen = sizeof(u.ia);
+		opttype = DH6OPT_IA_PD;
+		break;
+	case DHCP6_LISTVAL_IANA:
+		headlen = sizeof(u.ia);
+		opttype = DH6OPT_IA_NA;
+		break;
+	case DHCP6_LISTVAL_ADDR6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = DH6OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		headlen = sizeof(u.pd_prefix);
+		opttype = DH6OPT_IA_PD_PREFIX;
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		headlen = sizeof(u.ia_addr);
+		opttype = DH6OPT_IAADDR;
+		break;
+	case DHCP6_LISTVAL_STCODE:
+		headlen = sizeof(u.stcodeopt);
+		opttype = DH6OPT_STATUS_CODE;
+		break;
+	default:
+		/*
+		 * we encounter an unknown option.  this should be an internal
+		 * error.
+		 */
+		bb_error_msg("unknown option: code %d", optval->type);
+		return (-1);
+	}
+
+	/* then, calculate the length of and/or fill in the sub-options */
+	subp = NULL;
+	sublen = 0;
+	if (p)
+		subp = p + headlen;
+	for (subov = TAILQ_FIRST(&optval->sublist); subov;
+	    subov = TAILQ_NEXT(subov, link)) {
+		int s;
+
+		if ((s = copyout_option(subp, ep, subov)) < 0)
+			return (-1);
+		if (p)
+			subp += s;
+		sublen += s;
+	}
+
+	/* finally, deal with the head part again */
+	opt_len = headlen + sublen;
+	if (!p)
+		return(opt_len);
+
+	log2("set %s", dhcp6optstr(opttype));
+	if (ep - p < headlen) /* check it just in case */
+		return (-1);
+
+	/* fill in the common part */
+	opt->dh6opt_type = htons(opttype);
+	opt->dh6opt_len = htons(opt_len - sizeof(struct dhcp6opt));
+
+	/* fill in type specific fields */
+	switch (optval->type) {
+	case DHCP6_LISTVAL_IAPD:
+	case DHCP6_LISTVAL_IANA:
+		u.ia.dh6_ia_iaid = htonl(optval->val_ia.iaid);
+		u.ia.dh6_ia_t1 = htonl(optval->val_ia.t1);
+		u.ia.dh6_ia_t2 = htonl(optval->val_ia.t2);
+		break;
+	case DHCP6_LISTVAL_PREFIX6:
+		u.pd_prefix.dh6_iapd_prefix_preferred_time =
+		    htonl(optval->val_prefix6.pltime);
+		u.pd_prefix.dh6_iapd_prefix_valid_time =
+		    htonl(optval->val_prefix6.vltime);
+		u.pd_prefix.dh6_iapd_prefix_prefix_len =
+		    optval->val_prefix6.plen;
+		/* XXX: prefix_addr is badly aligned, so we need memcpy */
+		memcpy(&u.pd_prefix.dh6_iapd_prefix_prefix_addr,
+		    &optval->val_prefix6.addr, sizeof(struct in6_addr));
+		break;
+	case DHCP6_LISTVAL_STATEFULADDR6:
+		u.ia_addr.dh6_ia_addr_preferred_time =
+		    htonl(optval->val_statefuladdr6.pltime);
+		u.ia_addr.dh6_ia_addr_valid_time =
+		    htonl(optval->val_statefuladdr6.vltime);
+		u.ia_addr.dh6_ia_addr_addr = optval->val_statefuladdr6.addr;
+		break;
+	case DHCP6_LISTVAL_STCODE:
+		u.stcodeopt.dh6_stcode_code = htons(optval->val_num16);
+		break;
+	default:
+		/*
+		 * XXX: this case should be rejected at the beginning of this
+		 * function.
+		 */
+		return (-1);
+	}
+
+	/* copyout the data (p must be non NULL at this point) */
+	memcpy(p, opt, headlen);
+	return (opt_len);
+}
+
+void dhcp6_set_timeoparam(struct dhcp6_event *ev)
+{
+	ev->retrans = 0;
+	ev->max_retrans_cnt = 0;
+	ev->max_retrans_dur = 0;
+	ev->max_retrans_time = 0;
+
+	switch (ev->state) {
+	case DHCP6S_SOLICIT:
+		ev->init_retrans = SOL_TIMEOUT;
+		ev->max_retrans_time = SOL_MAX_RT;
+		break;
+	case DHCP6S_INFOREQ:
+		ev->init_retrans = INF_TIMEOUT;
+		ev->max_retrans_time = INF_MAX_RT;
+		break;
+	case DHCP6S_REQUEST:
+		ev->init_retrans = REQ_TIMEOUT;
+		ev->max_retrans_time = REQ_MAX_RT;
+		ev->max_retrans_cnt = REQ_MAX_RC;
+		break;
+	case DHCP6S_RENEW:
+		ev->init_retrans = REN_TIMEOUT;
+		ev->max_retrans_time = REN_MAX_RT;
+		break;
+	case DHCP6S_REBIND:
+		ev->init_retrans = REB_TIMEOUT;
+		ev->max_retrans_time = REB_MAX_RT;
+		break;
+	case DHCP6S_RELEASE:
+		ev->init_retrans = REL_TIMEOUT;
+		ev->max_retrans_cnt = REL_MAX_RC;
+		break;
+	default:
+		bb_error_msg_and_die("unexpected event state %d on %s",
+		    ev->state, ev->ifp->ifname);
+	}
+}
+
+void dhcp6_reset_timer(struct dhcp6_event *ev)
+{
+	double n, r;
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		/*
+		 * The first Solicit message from the client on the interface
+		 * MUST be delayed by a random amount of time between
+		 * 0 and SOL_MAX_DELAY.
+		 * [RFC3315 17.1.2]
+		 * XXX: a random delay is also necessary before the first
+		 * information-request message.  Fortunately, the parameters
+		 * and the algorithm for these two cases are the same.
+		 * [RFC3315 18.1.5]
+		 */
+		ev->retrans = (random() % (SOL_MAX_DELAY));
+		break;
+	default:
+		if (ev->state == DHCP6S_SOLICIT && ev->timeouts == 0) {
+			/*
+			 * The first RT MUST be selected to be strictly
+			 * greater than IRT by choosing RAND to be strictly
+			 * greater than 0.
+			 * [RFC3315 17.1.2]
+			 */
+			r = (double)((random() % 1000) + 1) / 10000;
+			n = ev->init_retrans + r * ev->init_retrans;
+		} else {
+			r = (double)((random() % 2000) - 1000) / 10000;
+
+			if (ev->timeouts == 0) {
+				n = ev->init_retrans + r * ev->init_retrans;
+			} else
+				n = 2 * ev->retrans + r * ev->retrans;
+		}
+		if (ev->max_retrans_time && n > ev->max_retrans_time)
+			n = ev->max_retrans_time + r * ev->max_retrans_time;
+		ev->retrans = (long)n;
+		break;
+	}
+
+	dhcp6_timer_set(ev->retrans, ev->timer);
+
+	log1("reset a timer on %s, state=%s, timeo=%d, retrans=%ld",
+		ev->ifp->ifname, dhcp6_event_statestr(ev), ev->timeouts, ev->retrans);
+}
+
+int duidcpy(struct duid *dd, struct duid *ds)
+{
+	dd->duid_len = ds->duid_len;
+	if ((dd->duid_id = malloc_or_warn(dd->duid_len)) == NULL) {
+		return (-1);
+	}
+	memcpy(dd->duid_id, ds->duid_id, dd->duid_len);
+
+	return (0);
+}
+
+int ALWAYS_INLINE duidcmp(struct duid *d1, struct duid *d2)
+{
+	if (d1->duid_len == d2->duid_len)
+		return (memcmp(d1->duid_id, d2->duid_id, d1->duid_len));
+	else
+		return (-1);
+}
+
+void duidfree(struct duid *d)
+{
+	free(d->duid_id);
+	d->duid_id = NULL;
+	d->duid_len = 0;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+/*
+ * Provide an NTP-format timestamp as a replay detection counter
+ * as mentioned in RFC3315.
+ */
+#define JAN_1970        2208988800UL        /* 1970 - 1900 in seconds */
+int get_rdvalue(int rdm, void *rdvalue, size_t rdsize)
+{
+	struct timeval tv;
+	uint32_t pack[2];
+
+	if (rdm != DHCP6_AUTHRDM_MONOCOUNTER ||
+	    rdsize != sizeof(uint64_t)) {
+		bb_info_msg("unsupported RDM (%d) size (%d", rdm, (int )rdsize);
+		return (-1);
+	}
+
+	gettimeofday(&tv, NULL);
+
+	pack[0] = htonl((uint32_t)tv.tv_sec + JAN_1970);
+	pack[1] = htonl((uint32_t)tv.tv_usec);
+
+	memcpy(rdvalue, pack, sizeof(uint64_t));
+
+	return (0);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+#define genstr		(&bb_common_bufsiz1[COMMON_BUFSIZE / 2])
+#define sizeof_genstr	(COMMON_BUFSIZE / 2 - 1)
+const char *dhcp6optstr(int type)
+{
+	if (type > 65535)
+		return ("INVALID option");
+
+	switch (type) {
+	case DH6OPT_CLIENTID:
+		return ("client ID");
+	case DH6OPT_SERVERID:
+		return ("server ID");
+	case DH6OPT_IA_NA:
+		return ("identity association");
+	case DH6OPT_IA_TA:
+		return ("IA for temporary");
+	case DH6OPT_IAADDR:
+		return ("IA address");
+	case DH6OPT_ORO:
+		return ("option request");
+	case DH6OPT_PREFERENCE:
+		return ("preference");
+	case DH6OPT_ELAPSED_TIME:
+		return ("elapsed time");
+	case DH6OPT_RELAY_MSG:
+		return ("relay message");
+	case DH6OPT_AUTH:
+		return ("authentication");
+	case DH6OPT_UNICAST:
+		return ("server unicast");
+	case DH6OPT_STATUS_CODE:
+		return ("status code");
+	case DH6OPT_RAPID_COMMIT:
+		return ("rapid commit");
+	case DH6OPT_USER_CLASS:
+		return ("user class");
+	case DH6OPT_VENDOR_CLASS:
+		return ("vendor class");
+	case DH6OPT_VENDOR_OPTS:
+		return ("vendor specific info");
+	case DH6OPT_INTERFACE_ID:
+		return ("interface ID");
+	case DH6OPT_RECONF_MSG:
+		return ("reconfigure message");
+	case DH6OPT_SIP_SERVER_D:
+		return ("SIP domain name");
+	case DH6OPT_SIP_SERVER_A:
+		return ("SIP server address");
+	case DH6OPT_DNS:
+		return ("DNS");
+	case DH6OPT_DNSNAME:
+		return ("domain search list");
+	case DH6OPT_NTP:
+		return ("NTP server");
+	case DH6OPT_IA_PD:
+		return ("IA_PD");
+	case DH6OPT_IA_PD_PREFIX:
+		return ("IA_PD prefix");
+	case DH6OPT_REFRESHTIME:
+		return ("information refresh time");
+	case DH6OPT_NIS_SERVERS:
+		return ("NIS servers");
+	case DH6OPT_NISP_SERVERS:
+		return ("NIS+ servers");
+	case DH6OPT_NIS_DOMAIN_NAME:
+		return ("NIS domain name");
+	case DH6OPT_NISP_DOMAIN_NAME:
+		return ("NIS+ domain name");
+	case DH6OPT_BCMCS_SERVER_D:
+		return ("BCMCS domain name");
+	case DH6OPT_BCMCS_SERVER_A:
+		return ("BCMCS server address");
+	case DH6OPT_REMOTE_ID:
+		return ("remote ID");
+	case DH6OPT_SUBSCRIBER_ID:
+		return ("subscriber ID");
+	case DH6OPT_CLIENT_FQDN:
+		return ("client FQDN");
+	default:
+		snprintf(genstr, sizeof_genstr, "opt_%d", type);
+		return (genstr);
+	}
+}
+
+const char *dhcp6msgstr(int type)
+{
+	if (type > 255)
+		return ("INVALID msg");
+
+	switch (type) {
+	case DH6_SOLICIT:
+		return ("solicit");
+	case DH6_ADVERTISE:
+		return ("advertise");
+	case DH6_REQUEST:
+		return ("request");
+	case DH6_CONFIRM:
+		return ("confirm");
+	case DH6_RENEW:
+		return ("renew");
+	case DH6_REBIND:
+		return ("rebind");
+	case DH6_REPLY:
+		return ("reply");
+	case DH6_RELEASE:
+		return ("release");
+	case DH6_DECLINE:
+		return ("decline");
+	case DH6_RECONFIGURE:
+		return ("reconfigure");
+	case DH6_INFORM_REQ:
+		return ("information request");
+	case DH6_RELAY_FORW:
+		return ("relay-forward");
+	case DH6_RELAY_REPLY:
+		return ("relay-reply");
+	default:
+		snprintf(genstr, sizeof_genstr, "msg%d", type);
+		return (genstr);
+	}
+}
+
+const char *dhcp6_stcodestr(uint16_t code)
+{
+	if (code > 255)
+		return ("INVALID code");
+
+	switch (code) {
+	case DH6OPT_STCODE_SUCCESS:
+		return ("success");
+	case DH6OPT_STCODE_UNSPECFAIL:
+		return ("unspec failure");
+	case DH6OPT_STCODE_NOADDRSAVAIL:
+		return ("no addresses");
+	case DH6OPT_STCODE_NOBINDING:
+		return ("no binding");
+	case DH6OPT_STCODE_NOTONLINK:
+		return ("not on-link");
+	case DH6OPT_STCODE_USEMULTICAST:
+		return ("use multicast");
+	case DH6OPT_STCODE_NOPREFIXAVAIL:
+		return ("no prefixes");
+	default:
+		snprintf(genstr, sizeof_genstr, "code%d", code);
+		return (genstr);
+	}
+}
+#undef	genstr
+#undef	sizeof_genstr
+
+char *duidstr(struct duid *duid)
+{
+	int i, n, rest;
+	char *cp;
+#define duidbuf		(&bb_common_bufsiz1[COMMON_BUFSIZE / 2])
+//	static char duidbuf[sizeof("xx:") * 128 + sizeof("...")];
+
+	cp = duidbuf;
+	rest = COMMON_BUFSIZE / 2;
+	for (i = 0; i < duid->duid_len && i < 128; i++) {
+		n = snprintf(cp, rest, "%s%02x", i == 0 ? "" : ":",
+		    duid->duid_id[i] & 0xff);
+		if (n < 0)
+			return NULL;
+		cp += n;
+		rest -= n;
+	}
+	if (i < duid->duid_len)
+		snprintf(cp, rest, "%s", "...");
+
+	return (duidbuf);
+}
+#undef duidbuf
+
+const char *iastr(dh6cnfopts_t type)
+{
+	switch (type) {
+	case DHCPOPT_IA_PD:
+		return "PD";
+	case DHCPOPT_IA_NA:
+		return "NA";
+	default:
+		return "???";	/* should be a bug */
+	}
+}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+const char *dhcp6_event_statestr(struct dhcp6_event *ev)
+{
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		return ("INIT");
+	case DHCP6S_SOLICIT:
+		return ("SOLICIT");
+	case DHCP6S_INFOREQ:
+		return ("INFOREQ");
+	case DHCP6S_REQUEST:
+		return ("REQUEST");
+	case DHCP6S_RENEW:
+		return ("RENEW");
+	case DHCP6S_REBIND:
+		return ("REBIND");
+	case DHCP6S_RELEASE:
+		return ("RELEASE");
+	case DHCP6S_IDLE:
+		return ("IDLE");
+	default:
+		return ("???"); /* XXX */
+	}
+}
+#endif
diff -urNBp busybox.orig/networking/udhcp/common6.h busybox/networking/udhcp/common6.h
--- busybox.orig/networking/udhcp/common6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/common6.h	2011-05-24 20:23:10.000000000 +0400
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* XXX: bsdi4 does not have TAILQ_EMPTY */
+#ifndef TAILQ_EMPTY
+#define	TAILQ_EMPTY(head) ((head)->tqh_first == NULL)
+#endif
+
+/* and linux *_FIRST and *_NEXT */
+#ifndef LIST_EMPTY
+#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+#endif
+#ifndef LIST_FIRST
+#define	LIST_FIRST(head)	((head)->lh_first)
+#endif
+#ifndef LIST_NEXT
+#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
+#endif
+#ifndef LIST_FOREACH
+#define	LIST_FOREACH(var, head, field)					\
+	for ((var) = LIST_FIRST((head));				\
+	    (var);							\
+	    (var) = LIST_NEXT((var), field))
+#endif
+#ifndef TAILQ_FIRST
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+#endif
+#ifndef TAILQ_LAST
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+#endif
+#ifndef TAILQ_PREV
+#define	TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+#endif
+#ifndef TAILQ_NEXT
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+#endif
+#ifndef TAILQ_FOREACH
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+#endif
+#ifdef HAVE_TAILQ_FOREACH_REVERSE_OLD
+#undef TAILQ_FOREACH_REVERSE
+#endif
+#ifndef TAILQ_FOREACH_REVERSE
+#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var);							\
+	    (var) = TAILQ_PREV((var), headname, field))
+#endif
+
+
+#ifndef SO_REUSEPORT
+#define SO_REUSEPORT SO_REUSEADDR
+#endif
+
+
+/* s*_len stuff */
+static ALWAYS_INLINE int sysdep_sa_len(const struct sockaddr *sa)
+{
+#ifndef HAVE_SA_LEN
+  switch (sa->sa_family)
+    {
+    case AF_INET6:
+      return sizeof(struct sockaddr_in6);
+    case AF_INET:
+    default:
+      return sizeof(struct sockaddr_in);
+    }
+#else
+  return sa->sa_len;
+#endif
+}
+
+/* search option for dhcp6_find_listval() */
+#define MATCHLIST_PREFIXLEN 0x1
+
+/* common.c */
+typedef enum { IFADDRCONF_ADD, IFADDRCONF_REMOVE } ifaddrconf_cmd_t;
+
+int dhcp6_copy_list(struct dhcp6_list *, struct dhcp6_list *);
+void dhcp6_move_list(struct dhcp6_list *, struct dhcp6_list *);
+void dhcp6_clear_list(struct dhcp6_list *);
+void dhcp6_clear_listval(struct dhcp6_listval *);
+struct dhcp6_listval *dhcp6_find_listval(struct dhcp6_list *,
+    dhcp6_listval_type_t, void *, int);
+struct dhcp6_listval *dhcp6_add_listval(struct dhcp6_list *,
+    dhcp6_listval_type_t, void *, struct dhcp6_list *);
+int dhcp6_vbuf_copy(struct dhcp6_vbuf *, struct dhcp6_vbuf *);
+void dhcp6_vbuf_free(struct dhcp6_vbuf *);
+int dhcp6_vbuf_cmp(struct dhcp6_vbuf *, struct dhcp6_vbuf *);
+struct dhcp6_event *dhcp6_create_event(struct dhcp6_if *, int) RETURNS_MALLOC;
+void dhcp6_remove_event(struct dhcp6_event *);
+void dhcp6_remove_evdata(struct dhcp6_event *);
+struct authparam *new_authparam(int, int, int) RETURNS_MALLOC;
+struct authparam *copy_authparam(struct authparam *);
+int getifaddr(struct in6_addr *, char *, const struct in6_addr *, int, int);
+int prefix6_mask(struct in6_addr *, int);
+int get_duid(const char *, struct duid *, int, char *);
+void dhcp6_init_options(struct dhcp6_optinfo *);
+void dhcp6_clear_options(struct dhcp6_optinfo *);
+int dhcp6_copy_options(struct dhcp6_optinfo *,
+			   struct dhcp6_optinfo *);
+int dhcp6_get_options(struct dhcp6opt *, struct dhcp6opt *,
+			  struct dhcp6_optinfo *);
+int dhcp6_set_options(int, struct dhcp6opt *, struct dhcp6opt *,
+			  struct dhcp6_optinfo *);
+void dhcp6_set_timeoparam(struct dhcp6_event *);
+void dhcp6_reset_timer(struct dhcp6_event *);
+
+const char *dhcp6optstr(int);
+const char *dhcp6msgstr(int);
+const char *dhcp6_stcodestr(uint16_t);
+char *duidstr(struct duid *);
+const char *iastr(dh6cnfopts_t);
+const char *dhcp6_event_statestr(struct dhcp6_event *);
+int get_rdvalue(int, void *, size_t);
+int duidcpy(struct duid *, struct duid *);
+int duidcmp(struct duid *, struct duid *);
+void duidfree(struct duid *);
+int ifaddrconf(ifaddrconf_cmd_t, char *, struct sockaddr_in6 *,
+			   int, int, int);
+/* if6.c */
+extern ssize_t gethwid(char *, const char *, uint16_t *);
+
+/*
+ * compat hacks in case libc and kernel get out of sync:
+ *
+ * glibc 2.4 and uClibc 0.9.29 introduce IPV6_RECVPKTINFO etc. and change IPV6_PKTINFO
+ * This is only supported in Linux kernel >= 2.6.14
+ *
+ * This is only an approximation because the kernel version that libc was compiled against
+ * could be older or newer than the one being run.  But this should not be a problem --
+ * we just keep using the old kernel interface.
+ *
+ * these are placed here because they're needed in all of socket.c, recv.c and send.c
+ */
+#ifdef __linux__
+#  if defined IPV6_RECVHOPLIMIT || defined IPV6_RECVPKTINFO
+#    include <linux/version.h>
+#    if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+#      if defined IPV6_RECVHOPLIMIT && defined IPV6_2292HOPLIMIT
+#        undef IPV6_RECVHOPLIMIT
+#        define IPV6_RECVHOPLIMIT IPV6_2292HOPLIMIT
+#      endif
+#      if defined IPV6_RECVPKTINFO && defined IPV6_2292PKTINFO
+#        undef IPV6_RECVPKTINFO
+#        undef IPV6_PKTINFO
+#        define IPV6_RECVPKTINFO IPV6_2292PKTINFO
+#        define IPV6_PKTINFO IPV6_2292PKTINFO
+#      endif
+#    endif
+#  endif
+#endif
diff -urNBp busybox.orig/networking/udhcp/common.h busybox/networking/udhcp/common.h
--- busybox.orig/networking/udhcp/common.h	2011-05-20 13:54:28.000000000 +0400
+++ busybox/networking/udhcp/common.h	2011-05-20 13:54:28.000000000 +0400
@@ -195,7 +195,7 @@ uint8_t *udhcp_get_option(struct dhcp_pa
 int udhcp_end_option(uint8_t *optionptr) FAST_FUNC;
 void udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt) FAST_FUNC;
 void udhcp_add_simple_option(struct dhcp_packet *packet, uint8_t code, uint32_t data) FAST_FUNC;
-#if ENABLE_FEATURE_UDHCP_RFC3397
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY
 char *dname_dec(const uint8_t *cstr, int clen, const char *pre) FAST_FUNC;
 uint8_t *dname_enc(const uint8_t *cstr, int clen, const char *src, int *retlen) FAST_FUNC;
 #endif
diff -urNBp busybox.orig/networking/udhcp/config6.c busybox/networking/udhcp/config6.c
--- busybox.orig/networking/udhcp/config6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/config6.c	2011-05-24 20:23:18.000000000 +0400
@@ -0,0 +1,1515 @@
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <sys/ioctl.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#ifdef __linux__
+#include <linux/if_packet.h>
+#endif
+
+#include <syslog.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ifaddrs.h>
+#include <errno.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "auth6.h"
+
+
+static int add_pd_pif(struct iapd_conf *, struct cf_list *);
+static int add_options(int, struct dhcp6_if *, struct cf_list *);
+static int add_prefix(struct dhcp6_list *, const char *, int,
+    struct dhcp6_prefix *);
+static void clear_pd_pif(struct iapd_conf *);
+static void clear_iaconf(struct ia_conflist *);
+static void clear_keys(struct keyinfo *);
+static void clear_authinfo(struct authinfo *);
+static int get_default_ifid(struct prefix_ifconf *);
+
+static int configure_interface(struct cf_namelist *);
+static int configure_ia(struct cf_namelist *, dh6cnfopts_t);
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int configure_keys(struct cf_namelist *);
+static int configure_authinfo(struct cf_namelist *);
+static struct authinfo *find_authinfo(struct authinfo *, char *);
+#endif
+static char* FAST_FUNC qstrdup(char *);
+
+static int configure_interface(struct cf_namelist *iflist)
+{
+	struct cf_namelist *cnl;
+	struct dhcp6_if *ifp;
+
+	for (cnl = iflist; cnl; cnl = cnl->next) {
+		struct cf_list *cfl;
+
+		if (if_nametoindex(cnl->name) == 0) {
+			bb_perror_msg("invalid interface(%s)", cnl->name);
+			return -1;
+		}
+
+		if ((ifp = find_ifconf_byname(cnl->name)) == NULL) {
+			log1("Unknown interface(%s), ignoring", cnl->name);
+			continue;
+		}
+
+		ifp->server_pref = DH6OPT_PREF_UNDEF;
+
+		for (cfl = cnl->params; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case DECL_REQUEST:
+			case DECL_SEND:
+#if 0 /*ENABLE_DHCP6S*/
+			case DECL_ALLOW:
+#endif
+				if (add_options(cfl->type, ifp, cfl->list)) {
+					goto bad;
+				}
+				break;
+			case DECL_INFO_ONLY:
+				ifp->send_flags |= DHCIFF_INFO_ONLY;
+				break;
+			case DECL_SCRIPT:
+				if (ifp->scriptpath) {
+					bb_info_msg("%s:%d duplicated option",
+					    client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				ifp->scriptpath = qstrdup(cfl->ptr);
+				if (ifp->scriptpath == NULL)
+					goto wrong;
+				if (ifp->scriptpath[0] != '/') {
+					bb_info_msg(
+					    "script must be an absolute path");
+					goto bad;
+				}
+				break;
+			default:
+wrong:
+				bb_error_msg("%s:%d invalid configuration",
+					client6_config.conffile, cfl->line);
+				goto bad;
+			}
+		} /* for(cf_list) */
+	} /* for(cf_namelist) */
+
+	return (0);
+
+  bad:
+	return (-1);
+}
+
+static int configure_ia(struct cf_namelist *ialist, dh6cnfopts_t iatype)
+{
+	struct cf_namelist *iap;
+	struct ia_conf *iac = NULL;
+	size_t confsize;
+
+	switch (iatype) {
+	case DHCPOPT_IA_PD:
+		confsize = sizeof(struct iapd_conf);
+		break;
+	case DHCPOPT_IA_NA:
+		confsize = sizeof(struct iana_conf);
+		break;
+	default:
+		bb_error_msg("assumption failure %d", iatype);
+		goto bad;
+	}
+
+	for (iap = ialist; iap; iap = iap->next) {
+		struct cf_list *cfl;
+
+		iac = xzalloc(confsize);
+
+		/* common initialization */
+		iac->type = iatype;
+		iac->iaid = (uint32_t)atoi(iap->name);
+		TAILQ_INIT(&iac->iadata);
+		TAILQ_INSERT_TAIL(&client6_config.ia_allconflist, iac, link);
+
+		/* IA-type specific initialization */
+		switch (iatype) {
+		case DHCPOPT_IA_PD:
+			TAILQ_INIT(&((struct iapd_conf *)iac)->iapd_prefix_list);
+			TAILQ_INIT(&((struct iapd_conf *)iac)->iapd_pif_list);
+			break;
+		case DHCPOPT_IA_NA:
+			TAILQ_INIT(&((struct iana_conf *)iac)->iana_address_list);
+			break;
+		default:
+			goto bad;
+		}
+
+		/* set up parameters for the IA */
+		for (cfl = iap->params; cfl; cfl = cfl->next) {
+			struct iapd_conf *pdp = (struct iapd_conf *) iac;
+			struct iana_conf *nap = (struct iana_conf *) iac;
+
+			switch (iatype) {
+			case DHCPOPT_IA_PD:
+				switch (cfl->type) {
+				case IACONF_PIF:
+					if (add_pd_pif(pdp, cfl))
+						goto bad;
+					break;
+				case IACONF_PREFIX:
+					if (add_prefix(&pdp->iapd_prefix_list,
+					    "IA_PD", DHCP6_LISTVAL_PREFIX6,
+					    cfl->ptr)) {
+						bb_error_msg("failed "
+							"to configure prefix");
+						goto bad;
+					}
+					break;
+				default:
+					bb_error_msg("%s:%d invalid configuration",
+					    client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				break;
+			case DHCPOPT_IA_NA:
+				switch (cfl->type) {
+				case IACONF_ADDR:
+					if (add_prefix(&nap->iana_address_list,
+					    "IA_NA", DHCP6_LISTVAL_STATEFULADDR6,
+					    cfl->ptr)) {
+						bb_error_msg("failed "
+							"to configure address");
+						goto bad;
+					}
+					break;
+				default:
+					bb_error_msg("%s:%d invalid configuration",
+					    client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				break;
+			default:
+				bb_error_msg("%s:%d invalid iatype %d",
+				    client6_config.conffile, cfl->line, iatype);
+				goto bad;
+			}
+		}
+	}
+
+	return (0);
+
+  bad:
+	return (-1);
+}
+
+static int add_pd_pif(struct iapd_conf *iapdc, struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	struct prefix_ifconf *pif;
+
+	/* duplication check */
+	for (pif = TAILQ_FIRST(&iapdc->iapd_pif_list); pif;
+	    pif = TAILQ_NEXT(pif, link)) {
+		if (strcmp(pif->ifname, cfl0->ptr) == 0) {
+			bb_info_msg("%s:%d duplicate prefix interface %s",
+			    client6_config.conffile, cfl0->line,
+			    (char *)cfl0->ptr);
+			return (0); /* ignore it */
+		}
+	}
+
+	pif = xzalloc(sizeof(*pif));
+
+	/* validate and copy ifname */
+	if (if_nametoindex(cfl0->ptr) == 0) {
+		bb_perror_msg("%s:%d invalid interface (%s)",
+		    client6_config.conffile, cfl0->line,
+		    (char *)cfl0->ptr);
+		goto bad;
+	}
+	pif->ifname = xstrdup(cfl0->ptr);
+
+	pif->ifid_len = IFID_LEN_DEFAULT;
+	pif->sla_len = SLA_LEN_DEFAULT;
+	if (get_default_ifid(pif)) {
+		bb_info_msg("failed to get IF ID for %s", pif->ifname);
+		goto bad;
+	}
+
+	for (cfl = cfl0->list; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case IFPARAM_SLA_ID:
+			pif->sla_id = (uint32_t)cfl->num;
+			break;
+		case IFPARAM_SLA_LEN:
+			pif->sla_len = (int)cfl->num;
+			if (pif->sla_len < 0 || pif->sla_len > 128) {
+				bb_error_msg("%s:%d invalid SLA length: %d",
+				    client6_config.conffile, cfl->line,
+				    pif->sla_len);
+				goto bad;
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d invalid configuration",
+			    client6_config.conffile, cfl->line);
+			goto bad;
+		}
+	}
+
+	TAILQ_INSERT_TAIL(&iapdc->iapd_pif_list, pif, link);
+	return (0);
+
+  bad:
+	free(pif->ifname);
+	free(pif);
+	return (-1);
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int configure_keys(struct cf_namelist *keylist)
+{
+	struct cf_namelist *key;
+	char secrettmp[1024];
+	struct keyinfo *kinfo;
+	long long keyid;
+	char *expire = NULL;
+
+	for (key = keylist; key; key = key->next) {
+		struct cf_list *cfl;
+
+		kinfo = xzalloc(sizeof(*kinfo));
+		kinfo->next = client6_config.key_list;
+		client6_config.key_list = kinfo;
+		kinfo->name = xstrdup(key->name);
+
+		keyid = -1;
+		expire = NULL;
+		for (cfl = key->params; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case KEYPARAM_REALM:
+				if (kinfo->realm != NULL) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "realm", key->name);
+					continue;
+				}
+				kinfo->realm = qstrdup(cfl->ptr);
+				if (kinfo->realm == NULL)
+					goto wrong;
+				kinfo->realmlen = strlen(kinfo->realm);
+				break;
+			case KEYPARAM_KEYID:
+				if (keyid != -1) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "key ID", key->name);
+					continue;
+				}
+				keyid = cfl->num;
+				if (keyid < 0 || keyid > 0xffffffff) {
+					bb_info_msg("%s:%d key ID overflow",
+					     client6_config.conffile, cfl->line);
+					goto bad;
+				}
+				break;
+			case KEYPARAM_SECRET:
+				/* duplicate check */
+				if (kinfo->secret != NULL) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "secret", key->name);
+					continue; /* ignored */
+				}
+
+				/* convert base64 string to binary secret */
+				kinfo->secretlen = decode_base64(cfl->ptr, secrettmp, sizeof(secrettmp));
+                                if (kinfo->secretlen < 0) {
+					goto wrong;
+                                }
+				/* set the binary secret */
+				kinfo->secret = xmalloc(kinfo->secretlen);
+				memcpy(kinfo->secret, secrettmp, kinfo->secretlen);
+				break;
+			case KEYPARAM_EXPIRE:
+				if (expire != NULL) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for key %s "
+					    "(ignored)", client6_config.conffile, cfl->line,
+					    "expire", key->name);
+					continue;
+				}
+				expire = qstrdup(cfl->ptr);
+				if (expire == NULL)
+					goto wrong;
+				break;
+			default:
+wrong:
+				bb_error_msg("%s:%d invalid parameter for %s",
+				    client6_config.conffile, cfl->line, key->name);
+				goto bad;
+			}
+		}
+
+		/* check for mandatory parameters or use default */
+		if (kinfo->realm == NULL) {
+			bb_error_msg("%s not specified for key %s",
+				"realm", key->name);
+			goto bad;
+		}
+		if (keyid == -1) {
+			bb_error_msg("%s not specified for key %s",
+				"key ID", key->name);
+			goto bad;
+		}
+		kinfo->keyid = keyid;
+		if (kinfo->secret == NULL) {
+			bb_error_msg("%s not specified for key %s",
+				"secret",key->name);
+			goto bad;
+		}
+		kinfo->expire = 0;
+		if (expire != NULL) {
+			if (strcmp(expire, "forever") != 0) {
+				time_t now, expire_time;
+				struct tm lt;
+
+				if (time(&now) == -1) {
+					goto bad;
+				}
+				parse_datestr(expire, &lt);
+				expire_time = mktime(&lt);
+				if (expire_time < now) {
+					bb_error_msg("past "
+					    "expiration time specified: %s",
+					    expire);
+					goto bad;
+				}
+
+				kinfo->expire = expire_time;
+			}
+		}
+	}
+
+	return (0);
+
+  bad:
+	free(expire);
+	return (-1);
+}
+
+static int configure_authinfo(struct cf_namelist *authlist)
+{
+	struct cf_namelist *auth;
+	struct authinfo *ainfo;
+
+	for (auth = authlist; auth; auth = auth->next) {
+		struct cf_list *cfl;
+
+		ainfo = xzalloc(sizeof(*ainfo));
+		ainfo->next = client6_config.auth_list;
+		client6_config.auth_list = ainfo;
+		ainfo->protocol = DHCP6_AUTHPROTO_UNDEF;
+		ainfo->algorithm = DHCP6_AUTHALG_UNDEF;
+		ainfo->rdm = DHCP6_AUTHRDM_UNDEF;
+		ainfo->name = xstrdup(auth->name);
+
+		for (cfl = auth->params; cfl; cfl = cfl->next) {
+			switch (cfl->type) {
+			case AUTHPARAM_PROTO:
+				if (ainfo->protocol != DHCP6_AUTHPROTO_UNDEF) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for auth %s "
+					    "(ignored)",
+					    client6_config.conffile, cfl->line,
+					    "protocol", auth->name);
+					continue; /* ignored */
+				}
+				ainfo->protocol = (int)cfl->num;
+				break;
+			case AUTHPARAM_ALG:
+				if (ainfo->algorithm != DHCP6_AUTHALG_UNDEF) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for auth %s "
+					    "(ignored)",
+					    client6_config.conffile, cfl->line,
+					    "algorithm", auth->name);
+					continue; /* ignored */
+				}
+				ainfo->algorithm = (int)cfl->num;
+				break;
+			case AUTHPARAM_RDM:
+				if (ainfo->rdm != DHCP6_AUTHRDM_UNDEF) {
+					bb_info_msg(
+					    "%s:%d duplicate %s for auth %s "
+					    "(ignored)",
+					    client6_config.conffile, cfl->line,
+					    "RDM", auth->name);
+					continue; /* ignored */
+				}
+				ainfo->rdm = (int)cfl->num;
+				break;
+			case AUTHPARAM_KEY:
+				bb_info_msg(
+				    "%s:%d auth info specific keys "
+				    "are not supported",
+				    client6_config.conffile, cfl->line);
+				break;
+			default:
+				bb_error_msg("%s:%d invalid auth info parameter for %s",
+				    client6_config.conffile, cfl->line, auth->name);
+				goto bad;
+			}
+		}
+
+		/* check for mandatory parameters and consistency */
+		switch (ainfo->protocol) {
+		case DHCP6_AUTHPROTO_UNDEF:
+			bb_error_msg("auth protocol not specified for %s",
+			    auth->name);
+			goto bad;
+		case DHCP6_AUTHPROTO_DELAYED:
+			break;
+		case DHCP6_AUTHPROTO_RECONFIG:
+			goto bad;
+			break;
+		}
+		if (ainfo->algorithm == DHCP6_AUTHALG_UNDEF)
+			ainfo->algorithm = DHCP6_AUTHALG_HMACMD5;
+		if (ainfo->rdm == DHCP6_AUTHRDM_UNDEF)
+			ainfo->rdm = DHCP6_AUTHRDM_MONOCOUNTER;
+	}
+
+	return (0);
+
+  bad:
+	/* there is currently nothing special to recover the error */
+	return (-1);
+}
+
+static struct authinfo *find_authinfo(struct authinfo *head, char *name)
+{
+	struct authinfo *ainfo;
+
+	for (ainfo = head; ainfo; ainfo = ainfo->next) {
+		if (strcmp(ainfo->name, name) == 0)
+			return (ainfo);
+	}
+
+	return (NULL);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+/* Strip quotes from string */
+static char* FAST_FUNC qstrdup(char *qstr)
+{
+	size_t len;
+	char *dst;
+
+	len = strlen(qstr);
+	if (qstr[0] != '"' || len < 2 || qstr[len - 1] != '"')
+		return (NULL);
+
+	dst = xmalloc(len);
+
+	memcpy(dst, qstr + 1, len - 1);
+	dst[len - 2] = '\0';
+
+	return (dst);
+}
+
+/* we currently only construct EUI-64 based interface ID */
+static int get_default_ifid(struct prefix_ifconf *pif)
+{
+	uint16_t hwtype;
+	char buf[64];
+
+	if (pif->ifid_len < 64) {
+		bb_error_msg("ID length too short");
+		return (-1);
+	}
+
+	if (gethwid(buf, pif->ifname, &hwtype) < 0)
+		return (-2);
+
+	memset(pif->ifid, 0, sizeof(pif->ifid));
+	pif->ifid[8]  = buf[0] ^ 0x02; /* reverse the u/l bit*/
+	pif->ifid[9]  = buf[1];
+	pif->ifid[10] = buf[2];
+	pif->ifid[11] = 0xff;
+	pif->ifid[12] = 0xfe;
+	pif->ifid[13] = buf[3];
+	pif->ifid[14] = buf[4];
+	pif->ifid[15] = buf[5];
+
+	return (0);
+}
+
+static void clear_ifconf(struct dhcp6_if *iflist)
+{
+	struct dhcp6_if *ifp;
+
+	for (ifp = iflist; ifp; ifp = ifp->next) {
+
+		ifp->send_flags = 0;
+		ifp->allow_flags = 0;
+
+		ifp->server_pref = DH6OPT_PREF_UNDEF;
+
+		ifp->authproto = DHCP6_AUTHPROTO_UNDEF;
+		ifp->authalgorithm = DHCP6_AUTHALG_UNDEF;
+		ifp->authrdm = DHCP6_AUTHRDM_UNDEF;
+
+		dhcp6_clear_list(&ifp->reqopt_list);
+
+		clear_iaconf(&ifp->iaconf_list);
+
+		free(ifp->scriptpath);
+		ifp->scriptpath = NULL;
+
+		free(ifp->pool.name);
+		ifp->pool.name = NULL;
+	}
+}
+
+static void clear_pd_pif(struct iapd_conf *iapdc)
+{
+	struct prefix_ifconf *pif, *pif_next;
+
+	for (pif = TAILQ_FIRST(&iapdc->iapd_pif_list); pif; pif = pif_next) {
+		pif_next = TAILQ_NEXT(pif, link);
+
+		free(pif->ifname);
+		free(pif);
+	}
+
+	dhcp6_clear_list(&iapdc->iapd_prefix_list);
+}
+
+static void clear_iaconf(struct ia_conflist *ialist)
+{
+	struct ia_conf *iac;
+
+	while ((iac = TAILQ_FIRST(ialist)) != NULL) {
+		TAILQ_REMOVE(ialist, iac, link);
+
+		switch (iac->type) {
+		case DHCPOPT_IA_PD:
+			if (!TAILQ_EMPTY(&iac->iadata)) {
+				bb_error_msg("iadata not empty");
+			}
+			clear_pd_pif((struct iapd_conf *)iac);
+			break;
+		case DHCPOPT_IA_NA:
+			break;
+		default:
+			break;
+		}
+		free(iac);
+	}
+}
+
+static void clear_keys(struct keyinfo *klist)
+{
+	struct keyinfo *key = klist, *key_next;
+
+	while (key) {
+		key_next = key->next;
+
+		free(key->name);
+		free(key->realm);
+		free(key->secret);
+		free(key);
+
+		key = key_next;
+	}
+}
+
+static void clear_authinfo(struct authinfo *alist)
+{
+	struct authinfo *auth = alist, *auth_next;
+
+	while (auth) {
+		auth_next = auth->next;
+		free(auth);
+		auth = auth_next;
+	}
+}
+
+static int add_options(int opcode, struct dhcp6_if *ifp, struct cf_list *cfl0)
+{
+	struct cf_list *cfl;
+	struct ia_conf *iac;
+#if ENABLE_FEATURE_DHCP6_AUTH
+	struct authinfo *ainfo;
+#endif
+
+	for (cfl = cfl0; cfl; cfl = cfl->next) {
+		switch (cfl->type) {
+		case DHCPOPT_RAPID_COMMIT:
+			switch (opcode) {
+			case DECL_SEND:
+				ifp->send_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+#if 0 /*ENABLE_DHCP6S*/
+			case DECL_ALLOW:
+				ifp->allow_flags |= DHCIFF_RAPID_COMMIT;
+				break;
+#endif
+			default:
+				goto inv_op;
+			}
+			break;
+#if ENABLE_FEATURE_DHCP6_AUTH
+		case DHCPOPT_AUTHINFO:
+			if (opcode != DECL_SEND)
+				goto inv_op;
+			ainfo = find_authinfo(client6_config.auth_list, cfl->ptr);
+			if (ainfo == NULL) {
+				bb_error_msg("%s:%d auth info (%s) is not defined",
+				    client6_config.conffile, cfl->line,
+				    (char *)cfl->ptr);
+				return (-1);
+			}
+			if (ifp->authproto != DHCP6_AUTHPROTO_UNDEF) {
+				bb_error_msg("%s:%d duplicate auth info for %s",
+				    client6_config.conffile, cfl->line, ifp->ifname);
+				return (-1);
+			}
+			ifp->authproto = ainfo->protocol;
+			ifp->authalgorithm = ainfo->algorithm;
+			ifp->authrdm = ainfo->rdm;
+			break;
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+		case DHCPOPT_IA_PD:
+		case DHCPOPT_IA_NA:
+			if (opcode != DECL_SEND)
+				goto inv_op;
+			iac = find_iaconf(&client6_config.ia_allconflist, cfl->type,
+				    (uint32_t)cfl->num);
+			if (iac == NULL) {
+				bb_error_msg("%s:%d IA_%s (%llu) is not defined",
+					client6_config.conffile, cfl->line,
+					iastr(cfl->type), cfl->num);
+					return (-1);
+			}
+
+			TAILQ_REMOVE(&client6_config.ia_allconflist, iac, link);
+			TAILQ_INSERT_TAIL(&ifp->iaconf_list, iac, link);
+
+			break;
+		case DHCPOPT_SIP:
+		case DHCPOPT_SIPNAME:
+		case DHCPOPT_DNS:
+		case DHCPOPT_DNSNAME:
+		case DHCPOPT_NTP:
+		case DHCPOPT_NIS:
+		case DHCPOPT_NISNAME:
+		case DHCPOPT_NISP:
+		case DHCPOPT_NISPNAME:
+		case DHCPOPT_BCMCS:
+		case DHCPOPT_BCMCSNAME:
+		case DHCPOPT_REFRESHTIME:
+			if (opcode != DECL_REQUEST)
+				goto inv_op;
+			if (dhcp6_find_listval(&ifp->reqopt_list,
+					DHCP6_LISTVAL_NUM, &cfl->type, 0) != NULL) {
+				bb_info_msg("duplicate request option (%s)",
+				    dhcp6optstr(cfl->type));
+				goto next; /* ignore it */
+			}
+			if (dhcp6_add_listval(&ifp->reqopt_list,
+					DHCP6_LISTVAL_NUM, &cfl->type, NULL) == NULL) {
+				bb_error_msg("failed to configure an option");
+				return (-1);
+			}
+			break;
+		default:
+			bb_error_msg("%s:%d unsupported option (%s)",
+				client6_config.conffile, cfl->line,
+				dhcp6optstr(cfl->type));
+			return (-1);
+		}
+
+	  next:
+		;
+	}
+
+	return (0);
+
+inv_op:
+	bb_error_msg("%s:%d invalid operation (%d) for option (%s)",
+		    client6_config.conffile, cfl->line,
+		    opcode, dhcp6optstr(cfl->type));
+	return (-1);
+}
+
+static int add_prefix(struct dhcp6_list *head, const char *name, int type,
+		   struct dhcp6_prefix *prefix0)
+{
+	struct dhcp6_prefix oprefix;
+	char p[INET6_ADDRSTRLEN];
+
+	oprefix = *prefix0;
+
+	/* additional validation of parameters */
+	if (oprefix.plen < 4 || oprefix.plen > 128) {
+		bb_error_msg("invalid prefix length: %d", oprefix.plen);
+		return (-1);
+	}
+	/* clear trailing bits */
+	prefix6_mask(&oprefix.addr, oprefix.plen);
+	if (!IN6_ARE_ADDR_EQUAL(&prefix0->addr, &oprefix.addr)) {
+		char p0[INET6_ADDRSTRLEN];
+
+		sprint_nip6(p0, (const uint8_t *)&prefix0->addr);
+		sprint_nip6(p, (const uint8_t *)&oprefix.addr);
+		bb_info_msg("prefix %s/%d for %s "
+		    "has a trailing garbage.  It should be %s/%d",
+		    p0, prefix0->plen, name, p, oprefix.plen);
+		/* ignore the error */
+	}
+
+	/* avoid invalid prefix addresses */
+	if (IN6_IS_ADDR_MULTICAST(&oprefix.addr) ||
+	    IN6_IS_ADDR_LINKLOCAL(&oprefix.addr) ||
+	    IN6_IS_ADDR_SITELOCAL(&oprefix.addr)) {
+		sprint_nip6(p, (const uint8_t *)&oprefix.addr);
+		bb_error_msg("invalid prefix address: %s", p);
+		return (-1);
+	}
+
+	/* prefix duplication check */
+	if (dhcp6_find_listval(head, type, &oprefix, 0)) {
+		sprint_nip6(p, (const uint8_t *)&oprefix.addr);
+		if (type == DHCP6_LISTVAL_PREFIX6) {
+			bb_info_msg("duplicated prefix: %s/%d for %s",
+			    p, oprefix.plen, name);
+		} else {
+			bb_info_msg("duplicated address: %s for %s",
+			    p, name);
+		}
+		return (-1);
+	}
+
+	/* validation about relationship of pltime and vltime */
+	if (oprefix.vltime != DHCP6_DURATION_INFINITE &&
+	    (oprefix.pltime == DHCP6_DURATION_INFINITE ||
+	    oprefix.pltime > oprefix.vltime)) {
+		sprint_nip6(p, (const uint8_t *)&oprefix.addr);
+		bb_info_msg(
+		    "%s/%d has larger preferred lifetime "
+		    "than valid lifetime",
+		    p,
+		    (type == DHCP6_LISTVAL_PREFIX6) ? oprefix.plen : 128);
+		return (-1);
+	}
+
+	/* insert the new prefix to the chain */
+	if (dhcp6_add_listval(head, type, &oprefix, NULL) == NULL) {
+		return (-1);
+	}
+
+	return (0);
+}
+
+struct ia_conf *find_iaconf(struct ia_conflist *head, int type, uint32_t iaid)
+{
+	struct ia_conf *iac;
+
+	for (iac = TAILQ_FIRST(head); iac; iac = TAILQ_NEXT(iac, link)) {
+		if (iac->type == type && iac->iaid == iaid)
+			return (iac);
+	}
+
+	return (NULL);
+}
+
+struct dhcp6_prefix *
+find_prefix6(struct dhcp6_list *list, struct dhcp6_prefix *prefix)
+{
+	struct dhcp6_listval *v;
+
+	for (v = TAILQ_FIRST(list); v; v = TAILQ_NEXT(v, link)) {
+		if (v->val_prefix6.plen == prefix->plen &&
+		    IN6_ARE_ADDR_EQUAL(&v->val_prefix6.addr, &prefix->addr)) {
+			return (&v->val_prefix6);
+		}
+	}
+	return (NULL);
+}
+
+struct keyinfo *find_key(char *realm, size_t realmlen, uint32_t id)
+{
+	struct keyinfo *key;
+
+	for (key = client6_config.key_list; key; key = key->next) {
+		if (key->realmlen == realmlen &&
+		    memcmp(key->realm, realm, realmlen) == 0 &&
+		    key->keyid == id) {
+			return (key);
+		}
+	}
+
+	return (NULL);
+}
+
+////////////////////////////////////////////////////////////////////////
+
+
+#define MAKE_NAMELIST(l, n, p) do { \
+	(l) = (struct cf_namelist *)xzalloc(sizeof(*(l))); \
+	l->line   = lineno; \
+	l->name   = xstrdup((n)); \
+	l->params = (p); \
+	} while (0)
+
+#define MAKE_CFLIST(l, t, pp, pl) do { \
+	(l) = (struct cf_list *)xzalloc(sizeof(*(l))); \
+	l->line = lineno; \
+	l->type = (t); \
+	l->ptr  = (pp); \
+	l->list = (pl); \
+	l->tail = (l); \
+	} while (0)
+
+static int add_namelist(struct cf_namelist *, struct cf_namelist **);
+static void cf_cleanup(void);
+static void cleanup_namelist(struct cf_namelist *);
+static void cleanup_cflist(struct cf_list *);
+
+/* supplement routines for configuration */
+static int add_namelist(struct cf_namelist *new, struct cf_namelist **headp)
+{
+	struct cf_namelist *n;
+
+	/* check for duplicated configuration */
+	for (n = *headp; n; n = n->next) {
+		if (strcmp(n->name, new->name) == 0) {
+			bb_info_msg("duplicated name: %s (ignored)",
+			       new->name);
+			cleanup_namelist(new);
+			return (0);
+		}
+	}
+
+	/* insert at first pos */
+	new->next = *headp;
+	*headp = new;
+
+	return (0);
+}
+
+static int add_cfparam(struct cf_list *new, struct cf_namelist *headp)
+{
+	if (headp->params == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		headp->params = new;
+	}
+	else {
+		/* add to the end of list */
+		headp->params->tail->next = new;
+		headp->params->tail = new->tail;
+	}
+	return (0);
+}
+
+static int add_cfsubparam(struct cf_list *new, struct cf_list *parent)
+{
+	if (parent->list == NULL) {
+		new->tail = new;
+		new->next = NULL;
+		parent->list = new;
+	}
+	else {
+		/* add to the end of list */
+		parent->list->tail->next = new;
+		parent->list->tail = new->tail;
+	}
+	return (0);
+}
+
+/* free temporary resources */
+static void cf_cleanup(void)
+{
+	cleanup_namelist(client6_config.iflist_head);
+	client6_config.iflist_head = NULL;
+	cleanup_namelist(client6_config.iapdlist_head);
+	client6_config.iapdlist_head = NULL;
+	cleanup_namelist(client6_config.ianalist_head);
+	client6_config.ianalist_head = NULL;
+	cleanup_namelist(client6_config.authinfolist_head);
+	client6_config.authinfolist_head = NULL;
+	cleanup_namelist(client6_config.keylist_head);
+	client6_config.keylist_head = NULL;
+}
+
+static void cleanup_namelist(struct cf_namelist *head)
+{
+	struct cf_namelist *cfn, *cfn_next;
+
+	for (cfn = head; cfn; cfn = cfn_next) {
+		cfn_next = cfn->next;
+		cleanup_cflist(cfn->params);
+		free(cfn->name);
+		free(cfn);
+	}
+}
+
+static void cleanup_cflist(struct cf_list *p)
+{
+	struct cf_list *n;
+
+	while (p) {
+		n = p->next;
+		free(p->ptr);
+		if (p->list)
+			cleanup_cflist(p->list);
+		free(p);
+		p = n;
+	}
+}
+
+struct dhcp_options {
+    const char *optname;
+    const int optval;
+    const uint8_t paramt; /* 0-none, 1-string, 2-integer */
+};
+
+static const struct dhcp_options dhcp_option_list[] = {
+    { "rapid-commit",             DHCPOPT_RAPID_COMMIT,  0 },
+    { "ia-pd",                    DHCPOPT_IA_PD,         2 },
+    { "ia-na",                    DHCPOPT_IA_NA,         2 },
+    { "authentication",           DHCPOPT_AUTHINFO,      1 },
+    { "domain-name-servers",      DHCPOPT_DNS,           0 },
+    { "ntp-servers",              DHCPOPT_NTP,           0 },
+    { "sip-server-address",       DHCPOPT_SIP,           0 },
+    { "nis-server-address",       DHCPOPT_NIS,           0 },
+    { "nisp-server-address",      DHCPOPT_NISP,          0 },
+    { "bcmcs-server-address",     DHCPOPT_BCMCS,         0 },
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY
+    { "domain-name",              DHCPOPT_DNSNAME,       0 },
+    { "sip-server-domain-name",   DHCPOPT_SIPNAME,       0 },
+    { "nis-domain-name",          DHCPOPT_NISNAME,       0 },
+    { "nisp-domain-name",         DHCPOPT_NISPNAME,      0 },
+    { "bcmcs-server-domain-name", DHCPOPT_BCMCSNAME,     0 },
+#endif
+};
+
+static int FAST_FUNC create_iface(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *ifl;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_NAMELIST(ifl, varr[1], NULL);
+
+    if (add_namelist(ifl, &client6_config.iflist_head))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC create_assoc(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *ia;
+    const char *id;
+
+    if (cnt < 2)
+	return (-2);
+    if (cnt >=3 && strcmp(varr[2], "{"))
+	id = varr[2];
+    else
+	id = "0";
+
+    MAKE_NAMELIST(ia, id, NULL);
+
+    if (strcasecmp(varr[1], "pd") == 0) {
+	if (add_namelist(ia, &client6_config.iapdlist_head))
+            return (-1);
+    }
+    else if (strcasecmp(varr[1], "na") == 0) {
+	if (add_namelist(ia, &client6_config.ianalist_head))
+            return (-1);
+    }
+    else
+        return (-3);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_iface(int lineno, int kw_ind, char **varr, int cnt)
+{
+    struct cf_list *l;
+    int i, j;
+
+    switch (kw_ind) {
+	case 0: /* send */
+		MAKE_CFLIST(l, DECL_SEND, NULL, NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		break;
+	case 1: /* request */
+		MAKE_CFLIST(l, DECL_REQUEST, NULL, NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		break;
+	case 2: /* script */
+		if (cnt < 2)
+		    return (-2);
+		MAKE_CFLIST(l, DECL_SCRIPT, xstrdup(varr[1]), NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		return 0;
+	case 3: /* information-only */
+		MAKE_CFLIST(l, DECL_INFO_ONLY, NULL, NULL);
+		add_cfparam(l, client6_config.iflist_head);
+		return 0;
+	default:
+		return (-1);
+    }
+    /* add params */
+    for (i = 1; i < cnt; i++) {
+
+	for (j = 0; j < ARRAY_SIZE(dhcp_option_list); j++) {
+	    if (strcasecmp(dhcp_option_list[j].optname, varr[i]) == 0) {
+
+		MAKE_CFLIST(l, dhcp_option_list[j].optval, NULL, NULL);
+		if (dhcp_option_list[j].paramt && (i < cnt - 1)) {
+		    switch (dhcp_option_list[j].paramt) {
+		        case 1:
+			    l->ptr = xstrdup(varr[i+1]);
+			    break;
+		        case 2:
+			    l->num = xatou(varr[i+1]);
+			    break;
+		    }
+		    i++;
+		}
+		if (add_cfsubparam(l, client6_config.iflist_head->params->tail))
+		    return (-1);
+		break;
+
+	    }
+	}
+	if (j >= ARRAY_SIZE(dhcp_option_list))
+	    return (-3);
+
+    }
+    return 0;
+}
+
+static int FAST_FUNC create_prefiff(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_list *ifl;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_CFLIST(ifl, IACONF_PIF, xstrdup(varr[1]), NULL);
+
+    if (add_cfparam(ifl, client6_config.iapdlist_head))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_prefiff(int lineno, int kw_ind, char **varr, int cnt)
+{
+    struct cf_list *l;
+
+    if (cnt < 2)
+        return (-2);
+
+    switch (kw_ind) {
+	case 0: /* sla-id */
+		MAKE_CFLIST(l, IFPARAM_SLA_ID, xstrdup(varr[1]), NULL);
+		break;
+	case 1: /* sla-len */
+		MAKE_CFLIST(l, IFPARAM_SLA_LEN, xstrdup(varr[1]), NULL);
+		break;
+	default:
+		return (-1);
+    }
+    if (add_cfsubparam(l, client6_config.iapdlist_head->params->tail))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_assoc(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+	struct dhcp6_prefix *pconf;
+
+	if (cnt < 2)
+		return (-2);
+
+	switch (kw_ind) {
+		case 0: /* address */
+			MAKE_CFLIST(l, IACONF_ADDR, NULL, NULL);
+			break;
+		case 1: /* prefix */
+			MAKE_CFLIST(l, IACONF_PREFIX, NULL, NULL);
+			break;
+		default:
+			return (-1);
+	}
+	pconf = xzalloc(sizeof(*pconf));
+	if (inet_pton(AF_INET6, varr[1], &pconf->addr) != 1) {
+		bb_error_msg("invalid IPv6 address: %s", varr[1]);
+                free(pconf);
+                return (-1);
+        }
+	/* validate other parameters later */
+	pconf->plen = 128; /* XXX this field is ignored */
+	if (cnt < 3)
+		pconf->pltime = DHCP6_DURATION_INFINITE;
+	else {
+		pconf->pltime = xatoul(varr[2]);
+		if (cnt < 4)
+			pconf->vltime = DHCP6_DURATION_INFINITE;
+		else
+			pconf->vltime = xatoul(varr[3]);
+	}
+	l->ptr = pconf;
+
+	if (add_cfparam(l, client6_config.authinfolist_head))
+		return (-1);
+
+	return 0;
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int FAST_FUNC create_auth(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *authinfo;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_NAMELIST(authinfo, varr[1], NULL);
+
+    if (add_namelist(authinfo, &client6_config.authinfolist_head))
+	    return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC create_keyinfo(int lineno, int kw_ind __attribute__((unused)), char **varr, int cnt)
+{
+    struct cf_namelist *key;
+
+    if (cnt < 2)
+        return (-2);
+
+    MAKE_NAMELIST(key, varr[1], NULL);
+
+    if (add_namelist(key, &client6_config.keylist_head))
+        return (-1);
+
+    return 0;
+}
+
+static int FAST_FUNC parse_auth(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return (-2);
+
+	switch (kw_ind) {
+		case 0: /* protocol */
+			MAKE_CFLIST(l, AUTHPARAM_PROTO, NULL, NULL);
+			if (strcasecmp(varr[1], "delayed") == 0)
+				l->num = DHCP6_AUTHPROTO_DELAYED;
+/* server-only
+			else if (strcasecmp(varr[1], "reconfig") == 0)
+				l->num = DHCP6_AUTHPROTO_RECONFIG;
+*/
+			else
+				return (-3);
+			break;
+		case 1: /* algorithm */
+			MAKE_CFLIST(l, AUTHPARAM_ALG, NULL, NULL);
+			if (strcasecmp(varr[1], "hmac-md5") == 0 ||
+			    strcasecmp(varr[1], "hmacmd5") == 0)
+				l->num = DHCP6_AUTHALG_HMACMD5;
+			else
+				return (-3);
+			break;
+		case 2: /* rdm */
+			MAKE_CFLIST(l, AUTHPARAM_RDM, NULL, NULL);
+			if (strcasecmp(varr[1], "monocounter") == 0)
+				l->num = DHCP6_AUTHRDM_MONOCOUNTER;
+			else
+				return (-3);
+			break;
+		default:
+			return (-1);
+	}
+	if (add_cfparam(l, client6_config.authinfolist_head))
+		return (-1);
+
+	return 0;
+}
+
+static int FAST_FUNC parse_keyinfo(int lineno, int kw_ind, char **varr, int cnt)
+{
+	struct cf_list *l;
+
+	if (cnt < 2)
+		return (-2);
+
+	switch (kw_ind) {
+		case 0: /* realm */
+			MAKE_CFLIST(l, KEYPARAM_REALM, xstrdup(varr[1]), NULL);
+			break;
+		case 1: /* keyid */
+			MAKE_CFLIST(l, KEYPARAM_KEYID, NULL, NULL);
+			l->num = xatou(varr[1]);
+			break;
+		case 2: /* secret */
+			MAKE_CFLIST(l, KEYPARAM_SECRET, qstrdup(varr[1]), NULL);
+			break;
+		case 3: /* expire */
+			MAKE_CFLIST(l, KEYPARAM_EXPIRE, xstrdup(varr[1]), NULL);
+			break;
+		default:
+			return (-1);
+	}
+	if (add_cfparam(l, client6_config.keylist_head))
+		return (-1);
+
+	return 0;
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+struct config_keyword;
+
+struct config_keyword {
+	const char *keyword;
+	const struct config_keyword *next_level;
+
+	int (*handler)(int lineno, int kw_ind, char **varr, int cnt) FAST_FUNC;
+};
+
+static const struct config_keyword interface_kw[] = {
+ { "send",             NULL,          &parse_iface    },
+ { "request",          NULL,          &parse_iface    },
+ { "script",           NULL,          &parse_iface    },
+ { "information-only", NULL,          &parse_iface    },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword prefiff_kw[] = {
+ { "sla-id",           NULL,          &parse_prefiff  },
+ { "sla-len",          NULL,          &parse_prefiff  },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword assoc_kw[] = {
+ { "address",          NULL,          &parse_assoc    },
+ { "prefix",           NULL,          &parse_assoc    },
+ { "prefix-interface", prefiff_kw,    &create_prefiff },
+ { NULL,               NULL,          NULL },
+};
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static const struct config_keyword auth_kw[] = {
+ { "protocol",         NULL,          &parse_auth     },
+ { "algorithm",        NULL,          &parse_auth     },
+ { "rdm",              NULL,          &parse_auth     },
+ { NULL,               NULL,          NULL },
+};
+
+static const struct config_keyword keyinfo_kw[] = {
+ { "realm",            NULL,          &parse_keyinfo  },
+ { "keyid",            NULL,          &parse_keyinfo  },
+ { "secret",           NULL,          &parse_keyinfo  },
+ { "expire",           NULL,          &parse_keyinfo  },
+ { NULL,               NULL,          NULL },
+};
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static const struct config_keyword level0_kw[] = {
+ { "interface",        interface_kw,  &create_iface   },
+ { "id-assoc",         assoc_kw,      &create_assoc   },
+#if ENABLE_FEATURE_DHCP6_AUTH
+ { "authentication",   auth_kw,       &create_auth    },
+ { "keyinfo",          keyinfo_kw,    &create_keyinfo },
+#endif
+ { NULL,               NULL,          NULL            },
+};
+
+TAILQ_HEAD(keyword6_list, keywords6);
+struct keywords6 {
+        TAILQ_ENTRY(keywords6) link;
+
+	const struct config_keyword *kw;
+};
+
+
+int FAST_FUNC read_config6(const char *file)
+{
+        parser_t *parser;
+	struct keyword6_list kwq_head;
+        struct keywords6 *kl;
+        unsigned i = 0, j, m, n;
+#define MAX_TOKENS	15
+        char *token[MAX_TOKENS];
+        const struct config_keyword *req_next_level = NULL;
+	int ret = 0;
+
+	/* cleanup config */
+	client6_config.iflist_head = NULL;
+	TAILQ_INIT(&client6_config.ia_allconflist);
+	clear_keys(client6_config.key_list);
+	client6_config.key_list = NULL;
+	clear_authinfo(client6_config.auth_list);
+	client6_config.auth_list = NULL;
+	clear_ifconf(client6_config.dhcp6c_if);
+
+	TAILQ_INIT(&kwq_head);
+	kl = xzalloc(sizeof(*kl));
+	kl->kw = level0_kw;
+	TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+	parser = config_open(file);
+	while ((n = config_read(parser, token, MAX_TOKENS, 1, "# \t,", PARSE_NORMAL))) {
+		const struct config_keyword *k;
+		int was_found;
+
+		kl = TAILQ_LAST(&kwq_head, keyword6_list);
+		i = 0;
+restart_scan:
+		if (kl == NULL)
+			goto scan_fail;
+		k = kl->kw;
+		j = 0;
+		was_found = 0;
+		/* Just skip alone ';' */
+	        if (strcmp(token[i], ";") == 0)
+		    i++;
+		while (i < n && k[j].keyword != NULL) {
+		    if (strcasecmp(token[i], k[j].keyword) == 0) {
+			if (k[j].handler != NULL) {
+			    /* scan for ';' statement trailer */
+			    char *lc;
+			    for (m = i+1; m < n; m++) {
+				if (strcmp(token[m], "{") == 0 || strcmp(token[m], ";") == 0)
+				    break;
+				lc = last_char_is(token[m], ';');
+				if (lc) {
+				    *lc = '\0';
+				    m++;
+				    break;
+				}
+			    }
+			    if ((*k[j].handler)(parser->lineno, j, &token[i], m-i) < 0)
+				goto scan_fail;
+
+			    i = m;
+			} else
+			    i++;
+			req_next_level = k[j].next_level;
+			was_found = 1;
+			break;
+		    }
+		    j++;
+		}
+		if (i >= n)	// EOL
+		    continue;
+
+		if (req_next_level != NULL) {
+		    if (strcmp(token[i], "{") != 0)
+			goto scan_fail;
+		    kl = xzalloc(sizeof(*kl));
+		    kl->kw = req_next_level;
+		    TAILQ_INSERT_TAIL(&kwq_head, kl, link);
+		    req_next_level = NULL;
+		    if (++i >= n)	// EOL
+		        continue;
+		    goto restart_scan;
+		}
+		if (strncmp(token[i], "}", 1) == 0) {
+		    TAILQ_REMOVE(&kwq_head, kl, link);
+		    free(kl);
+		    kl = TAILQ_LAST(&kwq_head, keyword6_list);
+		    if (++i >= n)	// EOL
+		        continue;
+		    goto restart_scan;
+		}
+		if (was_found)
+		    goto restart_scan;
+
+scan_fail:
+		bb_error_msg("%s: can't parse line %u near token '%s'", file, parser->lineno, token[i]);
+		break;
+	}
+	config_close(parser);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (configure_keys(client6_config.keylist_head))
+		goto cf_fail;
+
+	if (configure_authinfo(client6_config.authinfolist_head))
+		goto cf_fail;
+#endif
+
+	if (configure_ia(client6_config.iapdlist_head, DHCPOPT_IA_PD))
+		goto cf_fail;
+
+	if (configure_ia(client6_config.ianalist_head, DHCPOPT_IA_NA))
+		goto cf_fail;
+
+	if (configure_interface(client6_config.iflist_head))
+		goto cf_fail;
+
+	/* unused IA configurations */
+	if (!TAILQ_EMPTY(&client6_config.ia_allconflist)) {
+		bb_info_msg("some IA defined but not used!");
+	}
+
+cf_ret:
+	clear_iaconf(&client6_config.ia_allconflist);
+	cf_cleanup();
+	return (ret);
+
+cf_fail:
+	ret = -1;
+	goto cf_ret;
+}
diff -urNBp busybox.orig/networking/udhcp/config6.h busybox/networking/udhcp/config6.h
--- busybox.orig/networking/udhcp/config6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/config6.h	2011-05-24 20:23:23.000000000 +0400
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include "timer.h"
+
+typedef enum {
+	DHCPOPT_IA_NA		= DH6OPT_IA_NA,
+	DHCPOPT_AUTHINFO	= DH6OPT_AUTH,
+	DHCPOPT_RAPID_COMMIT	= DH6OPT_RAPID_COMMIT,
+	DHCPOPT_SIPNAME		= DH6OPT_SIP_SERVER_D,
+	DHCPOPT_SIP		= DH6OPT_SIP_SERVER_A,
+	DHCPOPT_DNS		= DH6OPT_DNS,
+	DHCPOPT_DNSNAME		= DH6OPT_DNSNAME,
+	DHCPOPT_IA_PD		= DH6OPT_IA_PD,
+	DHCPOPT_NIS		= DH6OPT_NIS_SERVERS,
+	DHCPOPT_NISP		= DH6OPT_NISP_SERVERS,
+	DHCPOPT_NISNAME		= DH6OPT_NIS_DOMAIN_NAME,
+	DHCPOPT_NISPNAME	= DH6OPT_NISP_DOMAIN_NAME,
+	DHCPOPT_NTP		= DH6OPT_NTP,
+	DHCPOPT_REFRESHTIME	= DH6OPT_REFRESHTIME,
+	DHCPOPT_BCMCSNAME	= DH6OPT_BCMCS_SERVER_D,
+	DHCPOPT_BCMCS		= DH6OPT_BCMCS_SERVER_A,
+
+	DECL_SEND = 100, DECL_REQUEST, DECL_SCRIPT, DECL_INFO_ONLY,
+/* server only start */
+	DECL_ALLOW, DECL_DUID, DECL_PREFIX, DECL_PREFERENCE,
+	DECL_DELAYEDKEY, DECL_ADDRESS, DECL_RANGE, DECL_ADDRESSPOOL,
+/* server only  end */
+	IACONF_PIF, IACONF_PREFIX, IACONF_ADDR,
+	IFPARAM_SLA_ID, IFPARAM_SLA_LEN,
+	AUTHPARAM_PROTO, AUTHPARAM_ALG, AUTHPARAM_RDM, AUTHPARAM_KEY,
+	KEYPARAM_REALM, KEYPARAM_KEYID, KEYPARAM_SECRET, KEYPARAM_EXPIRE
+} dh6cnfopts_t;
+
+/* definitions of tail-queue types */
+TAILQ_HEAD(ia_conflist, ia_conf);
+TAILQ_HEAD(pifc_list, prefix_ifconf);
+
+struct dhcp6_poolspec {
+	char* name;
+	uint32_t pltime;
+	uint32_t vltime;
+};
+
+struct dhcp6_range {
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+struct pool_conf {
+	struct pool_conf *next;
+
+	char* name;
+
+	struct in6_addr min;
+	struct in6_addr max;
+};
+
+/* per-interface information */
+struct dhcp6_if {
+	struct dhcp6_if *next;
+
+	/* timer for the interface */
+	struct dhcp6_timer *timer;
+
+	/* event queue */
+	TAILQ_HEAD(, dhcp6_event) event_list;
+
+	/* static parameters of the interface */
+	char *ifname;
+	unsigned int ifid;
+	uint32_t linkid;	/* to send link-local packets */
+	/* multiple global address configuration is not supported now */
+	struct in6_addr addr; 	/* global address */
+
+	/* configuration parameters */
+	u_long send_flags;
+	u_long allow_flags;
+#define DHCIFF_INFO_ONLY 0x1
+#define DHCIFF_RAPID_COMMIT 0x2
+
+	int server_pref;	/* server preference (server only) */
+	struct dhcp6_poolspec pool;	/* address pool (server only) */
+	char *scriptpath;	/* path to config script (client only) */
+
+	struct dhcp6_list reqopt_list;
+	struct ia_conflist iaconf_list;
+
+	/* authentication information */
+	int authproto;		/* protocol */
+	/* the followings are valid only if authproto is not UNDEF */
+	int authalgorithm;	/* algorithm */
+	int authrdm;		/* replay attack detection method */
+};
+
+/* run-time authentication parameters */
+struct authparam {
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	struct keyinfo *key;
+	int flags;
+#define AUTHPARAM_FLAGS_NOPREVRD	0x1
+
+	uint64_t prevrd;	/* previous RD value provided by the peer */
+};
+
+struct dhcp6_event {
+	TAILQ_ENTRY(dhcp6_event) link;
+
+	struct dhcp6_if *ifp;
+	struct dhcp6_timer *timer;
+
+	struct duid serverid;
+
+	unsigned long long t_start; /* timestamp(ms) when the 1st msg is sent */
+
+	/* internal timer parameters */
+	unsigned long retrans;
+	unsigned long init_retrans;
+	long max_retrans_cnt;
+	long max_retrans_time;
+	long max_retrans_dur;
+	int timeouts;		/* number of timeouts */
+
+	uint32_t xid;		/* current transaction ID */
+	int state;
+
+	/* list of known servers */
+	struct dhcp6_serverinfo *current_server;
+	struct dhcp6_serverinfo *servers;
+
+	/* authentication parameters */
+	struct authparam *authparam;
+
+	TAILQ_HEAD(, dhcp6_eventdata) data_list;
+};
+
+struct dhcp6_eventdata {
+	TAILQ_ENTRY(dhcp6_eventdata) link;
+
+	struct dhcp6_event *event;
+	dh6cnfopts_t type;
+	void *data;
+};
+
+struct dhcp6_serverinfo {
+	struct dhcp6_serverinfo *next;
+
+	/* option information provided in the advertisement */
+	struct dhcp6_optinfo optinfo;
+
+	int pref;		/* preference */
+	int active;		/* bool; if this server is active or not */
+
+	struct authparam *authparam; /* authentication parameters */
+
+	/* TODO: remember available information from the server */
+};
+
+/* client status code */
+enum {DHCP6S_INIT, DHCP6S_SOLICIT, DHCP6S_INFOREQ, DHCP6S_REQUEST,
+      DHCP6S_RENEW, DHCP6S_REBIND, DHCP6S_RELEASE, DHCP6S_IDLE};
+
+struct prefix_ifconf {
+	TAILQ_ENTRY(prefix_ifconf) link;
+
+	char *ifname;		/* interface name such as ne0 */
+	int sla_len;		/* SLA ID length in bits */
+	uint32_t sla_id;	/* need more than 32bits? */
+	int ifid_len;		/* interface ID length in bits */
+	int ifid_type;		/* EUI-64 and manual (unused?) */
+	char ifid[16];		/* Interface ID, up to 128bits */
+};
+#define IFID_LEN_DEFAULT 64
+#define SLA_LEN_DEFAULT 16
+
+struct ia_conf {
+	TAILQ_ENTRY(ia_conf) link;
+	/*struct ia_conf *next;*/
+	dh6cnfopts_t type;
+	uint32_t iaid;
+
+	TAILQ_HEAD(, ia) iadata; /* struct ia is an opaque type */
+
+	/* type dependent values follow */
+};
+
+struct iapd_conf {
+	struct ia_conf iapd_ia;
+
+	/* type dependent values follow */
+	struct dhcp6_list iapd_prefix_list;
+	struct pifc_list iapd_pif_list;
+};
+#define iapd_next iapd_ia.next
+#define iapd_type iapd_ia.type
+#define iapd_id iapd_ia.iaid
+
+struct iana_conf {
+	struct ia_conf iana_ia;
+
+	/* type dependent values follow */
+	struct dhcp6_list iana_address_list;
+};
+#define iana_next iana_ia.next
+
+/* per-host configuration */
+struct host_conf {
+	struct host_conf *next;
+
+	char *name;		/* host name to identify the host */
+	struct duid duid;	/* DUID for the host */
+
+	/* prefixes to be delegated to the host */
+	struct dhcp6_list prefix_list;
+	/* address to be assigned for the host */
+	struct dhcp6_list addr_list;
+	/* address pool from which addresses are assigned for the host */
+	struct dhcp6_poolspec pool;
+
+	/* secret key shared with the client for delayed authentication */
+	struct keyinfo *delayedkey;
+	/* previous replay detection value from the client */
+	int saw_previous_rd;	/* if we remember the previous value */
+	uint64_t previous_rd;
+};
+
+/* DHCPv6 authentication information */
+struct authinfo {
+	struct authinfo *next;
+
+	char *name;		/* auth info name */
+
+	int protocol;		/* authentication protocol */
+	int algorithm;		/* authentication algorithm */
+	int rdm;		/* random attack detection method */
+
+	/* keys specific to this info? */
+};
+
+/* structures and definitions used in the config file parser */
+struct cf_namelist {
+	struct cf_namelist *next;
+	char *name;
+	int line;		/* the line number of the config file */
+	struct cf_list *params;
+};
+
+struct cf_list {
+	struct cf_list *next;
+	struct cf_list *tail;
+	int type;
+	int line;		/* the line number of the config file */
+
+	/* type dependent values: */
+	long long num;
+	struct cf_list *list;
+	void *ptr;
+};
+
+struct client6_config_t {
+	const char *conffile;
+
+	struct dhcp6_if *dhcp6c_if;
+
+	struct ia_conflist ia_allconflist;
+	struct keyinfo *key_list;
+	struct authinfo *auth_list;
+
+	struct cf_namelist *iflist_head, *iapdlist_head, *ianalist_head;
+	struct cf_namelist *authinfolist_head, *keylist_head;
+
+	LIST_HEAD(, dhcp6_timer) timer_head;
+	unsigned long long tm_sentinel;
+	struct timeval tm_check;
+};
+
+#define client6_config (*(struct client6_config_t*)(&bb_common_bufsiz1))
+
+
+struct dhcp6_if *if6init(char *);
+int if6reset(struct dhcp6_if *);
+int sock6_init(struct addrinfo *res);
+
+struct dhcp6_if *find_ifconf_byid(unsigned int );
+struct dhcp6_if *find_ifconf_byname(char *ifname);
+struct prefix_ifconf *find_prefixifconf(char *);
+struct dhcp6_prefix *find_prefix6(struct dhcp6_list *, struct dhcp6_prefix *);
+struct ia_conf *find_iaconf(struct ia_conflist *, int, uint32_t);
+struct keyinfo *find_key(char *, size_t, uint32_t);
+
+int FAST_FUNC read_config6(const char *file);
diff -urNBp busybox.orig/networking/udhcp/Config.src busybox/networking/udhcp/Config.src
--- busybox.orig/networking/udhcp/Config.src	2011-05-20 22:32:00.000000000 +0400
+++ busybox/networking/udhcp/Config.src	2011-02-11 12:10:37.000000000 +0300
@@ -82,7 +82,7 @@ config UDHCP_DEBUG
 	int "Maximum verbosity level for udhcp applets (0..9)"
 	default 9
 	range 0 9
-	depends on UDHCPD || UDHCPC || DHCPRELAY
+	depends on UDHCPD || UDHCPC || DHCPRELAY || DHCP6C || DHCP6RELAY
 	help
 	  Verbosity can be increased with multiple -v options.
 	  This option controls how high it can be cranked up.
@@ -137,3 +137,27 @@ config UDHCPC_SLACK_FOR_BUGGY_SERVERS
 	    maximum size of entire IP packet, and sends packets which are
 	    28 bytes too large.
 	  Seednet (ISP) VDSL: sends packets 2 bytes too large.
+
+config DHCP6C
+	bool "DHCPv6 client daemon (dhcp6c)"
+	default n
+	depends on PLATFORM_LINUX && FEATURE_IPV6
+	help
+	  dhcp6c is a DHCPv6 client geared primarily toward embedded systems,
+	  while striving to be fully functional and RFC compliant.
+
+config FEATURE_DHCP6_AUTH
+	bool "Support DHCPv6 messages authentication"
+	default n
+	depends on DHCP6C
+	help
+	  If selected, client will support DHCPv6 messages authentication,
+	  currently HMAC-MD5 only.
+
+config DHCP6RELAY
+	bool "dhcp6relay"
+	default n
+	depends on FEATURE_IPV6 && DHCP6C
+	help
+	  dhcp6relay listens for DHCPv6 requests on one or more interfaces
+	  and forwards these requests to a different interface.
diff -urNBp busybox.orig/networking/udhcp/dhcp6c.c busybox/networking/udhcp/dhcp6c.c
--- busybox.orig/networking/udhcp/dhcp6c.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c.c	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,1484 @@
+/*
+ * DHCPv6 client
+ *
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Original code taken from wide-dhcpv6-20080615 and converted into
+ * a busybox applet by Leonid Lisovskiy <lly@sf.net>
+ */
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/queue.h>
+#include <errno.h>
+#include <limits.h>
+#include <net/if.h>
+#ifdef __FreeBSD__
+#include <net/if_var.h>
+#endif
+
+#include <netinet/in.h>
+
+#include <arpa/inet.h>
+#include <netdb.h>
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <err.h>
+#include <ifaddrs.h>
+
+/* Override ENABLE_FEATURE_PIDFILE */
+#define WANT_PIDFILE 1
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+#include "dhcp6c_ia.h"
+#include "auth6.h"
+
+#define DHCP6C_CONF     "/etc/dhcp6c.conf"
+#define DHCP6C_PIDFILE  "/var/run/dhcp6c.pid"
+#define DUID_FILE       "/var/state/dhcp6c_duid"
+
+struct globals {
+	struct sockaddr_in6 sa6_allagent;
+
+	const char *pid_file;
+
+	int csock;	/* inbound/outbound udp port */
+	int rtsock;	/* routing socket */
+
+	char rbuf[BUFSIZ], sbuf[BUFSIZ], cmsgbuf[BUFSIZ];
+
+	struct duid client_duid;
+	int duid_type;
+};
+
+#define G (*ptr_to_globals)
+#define csock		(G.csock        )
+#define rtsock		(G.rtsock       )
+#define client_duid	(G.client_duid  )
+#define duid_type	(G.duid_type    )
+#define INIT_G() do { \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	G.pid_file = DHCP6C_PIDFILE; \
+	duid_type = 1; \
+} while (0)
+
+
+static void client6_init(struct dhcp6_if *);
+static void client6_startall(int);
+static void free_resources(struct dhcp6_if *);
+static void client6_mainloop(void);
+static void check_exit(int);
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *,
+						 struct duid *);
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *);
+static void client6_recv(void);
+static int client6_recvadvert(struct dhcp6_if *, struct dhcp6_event *,
+				   struct dhcp6_optinfo *);
+static int client6_recvreply(struct dhcp6_if *, struct dhcp6_event *,
+				  struct dhcp6_optinfo *);
+static struct dhcp6_event *find_event_withid(struct dhcp6_if *,
+						  uint32_t);
+static int construct_confdata(struct dhcp6_if *, struct dhcp6_event *);
+static int construct_reqdata(struct dhcp6_if *, struct dhcp6_optinfo *,
+    struct dhcp6_event *);
+static struct dhcp6_timer *client6_expire_refreshtime(void *);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int process_auth(struct authparam *, struct dhcp6 *dh6, ssize_t,
+    struct dhcp6_optinfo *);
+static int set_auth(struct dhcp6_event *, struct dhcp6_optinfo *);
+#endif
+
+#define MAX_ELAPSED_TIME 0xffff
+
+//usage:#define dhcp6c_trivial_usage
+//usage:       "[-vfi] [-c FILE] [-D LL|LLT] [-p FILE] interface [interfaces...]"
+//usage:#define dhcp6c_full_usage "\n"
+//usage:      "\n	-v         Print debugging messages(may be repeated)"
+//usage:      "\n	-f         Foreground mode"
+//usage:      "\n	-i         Info-req(information-only) mode"
+//usage:      "\n	-c FILE    Use FILE as the configuration file"
+//usage:      "\n	-D LL|LLT  Use LL or LLT to override default(LLT) DUID type generation"
+//usage:      "\n	-p FILE    Use FILE to dump the process ID of dhcp6c"
+
+enum {
+        OPT_FOREGROUND = 1 << 0,
+        OPT_i = 1 << 1,
+        OPT_c = 1 << 2,
+        OPT_D = 1 << 3,
+        OPT_p = 1 << 4,
+        OPT_VERBOSE = 1 << 5,
+};
+
+int dhcp6c_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dhcp6c_main(int argc, char **argv)
+{
+	int opt;
+	const char *str_D;
+
+	INIT_G();
+	client6_config.conffile = DHCP6C_CONF;
+
+#ifndef HAVE_ARC4RANDOM
+	srandom(time(NULL) & getpid());
+#endif
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	opt_complementary = ":vv";
+#endif
+
+	opt = getopt32(argv, "fic:D:p:v",
+			&client6_config.conffile, &str_D, &G.pid_file
+			IF_UDHCP_VERBOSE(, &dhcp_verbose)
+			);
+	if (opt & OPT_D) {
+		if (!strcasecmp(str_D, "LL"))
+			duid_type = 3;
+		else if (!strcasecmp(str_D, "LLT"))
+			duid_type = 1;
+	}
+
+	argv += optind;
+	argc -= optind;
+	if (argc < 1)
+		bb_show_usage();
+
+	if (!(opt & OPT_FOREGROUND) && !(opt & OPT_i)) {
+		bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
+		openlog(applet_name, LOG_PID, LOG_DAEMON);
+		logmode = LOGMODE_SYSLOG;
+	}
+
+	bb_signals(0 + (1 << SIGHUP) + (1 << SIGTERM) + (1 << SIGQUIT),
+		  record_signo);
+
+	while (*argv) { 
+		if (if6init(*argv) == NULL) {
+			bb_error_msg_and_die("failed to initialize %s", *argv);
+		}
+		argv++;
+	}
+	client6_init(client6_config.dhcp6c_if);
+
+	if (!(opt & OPT_i) && (read_config6(client6_config.conffile)) != 0) {
+		bb_error_msg_and_die("failed to parse configuration file");
+	}
+
+	/* dump current PID */
+	write_pidfile(G.pid_file);
+
+	client6_startall(0);
+	bb_info_msg("started");
+	client6_mainloop();
+	return (0);
+}
+
+
+/*------------------------------------------------------------*/
+
+void client6_init(struct dhcp6_if *ifp)
+{
+	struct addrinfo hints, *res;
+	int error;
+
+	/* get our DUID */
+	if (get_duid(DUID_FILE, &client_duid, duid_type, ifp->ifname)) {
+		bb_error_msg_and_die("failed to get a DUID");
+	}
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(NULL, DH6PORT_DOWNSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	csock = sock6_init(res);
+	if (setsockopt(csock, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, &const_int_1,
+			sizeof(const_int_1)) < 0) {
+		bb_perror_msg_and_die("setsockopt(IPV6_MULTICAST_LOOP)");
+	}
+
+	/* open a routing socket to watch the routing table */
+	if ((rtsock = socket(PF_ROUTE, SOCK_RAW, 0)) < 0) {
+		bb_perror_msg_and_die("open a routing socket");
+	}
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	error = getaddrinfo(DH6ADDR_ALLAGENT, DH6PORT_UPSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	memcpy(&G.sa6_allagent, res->ai_addr, res->ai_addrlen);
+	freeaddrinfo(res);
+}
+
+int client6_start(struct dhcp6_if *ifp)
+{
+	struct dhcp6_event *ev;
+
+	/* make sure that the interface does not have a timer */
+	if (ifp->timer)
+		dhcp6_timer_remove(&ifp->timer);
+
+	/* create an event for the initial delay */
+	ev = dhcp6_create_event(ifp, DHCP6S_INIT);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	ev->authparam = new_authparam(ifp->authproto,
+	    ifp->authalgorithm, ifp->authrdm);
+#endif
+
+	dhcp6_reset_timer(ev);
+
+	return (0);
+}
+
+static void client6_startall(int isrestart)
+{
+	struct dhcp6_if *ifp;
+
+	if (isrestart) {
+		/* reload the configuration file */
+		if (read_config6(client6_config.conffile))
+			bb_error_msg_and_die("failed to parse configuration file");
+	}
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		if (isrestart && if6reset(ifp)) {
+			bb_info_msg("failed to reset %s", ifp->ifname);
+			continue; /* XXX: try to recover? */
+		}
+		if (client6_start(ifp))
+			exit(1); /* initialization failure.  we give up. */
+	}
+}
+
+static void free_resources(struct dhcp6_if *freeifp)
+{
+	struct dhcp6_if *ifp;
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		struct dhcp6_event *ev, *ev_next;
+
+		if (freeifp != NULL && freeifp != ifp)
+			continue;
+
+		/* release all IAs as well as send RELEASE message(s) */
+		release_all_ia(ifp);
+
+		/*
+		 * Cancel all outstanding events for each interface except
+		 * ones being released.
+		 */
+		for (ev = TAILQ_FIRST(&ifp->event_list); ev; ev = ev_next) {
+			ev_next = TAILQ_NEXT(ev, link);
+
+			if (ev->state == DHCP6S_RELEASE)
+				continue; /* keep it for now */
+
+			dhcp6_remove_event(ev);
+		}
+	}
+}
+
+static void check_exit(int force)
+{
+	struct dhcp6_if *ifp;
+
+	if (!force) {
+		if (!bb_got_signal)
+			return;
+
+		for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		/*
+		 * Check if we have an outstanding event.  If we do, we cannot
+		 * exit for now.
+		 */
+			if (!TAILQ_EMPTY(&ifp->event_list))
+				return;
+		}
+	}
+
+	/* We have no existing event.  Do exit. */
+	bb_info_msg("exiting");
+	free_resources(NULL);
+	remove_pidfile(G.pid_file);
+
+	exit(0);
+}
+
+static void client6_mainloop(void)
+{
+	struct timeval *w;
+	int ret, maxsock;
+	fd_set r;
+
+	while (1) {
+		if (bb_got_signal) {
+			switch (bb_got_signal) {
+			case SIGQUIT:
+			case SIGTERM:
+				check_exit(1);
+				break;
+			case SIGHUP:
+				bb_info_msg("restarting");
+				bb_got_signal = 0;
+				free_resources(NULL);
+				client6_startall(1);
+				break;
+			}
+		}
+
+		w = dhcp6_timer_check();
+
+		FD_ZERO(&r);
+		FD_SET(csock, &r);
+		maxsock = csock;
+
+		ret = select(maxsock + 1, &r, NULL, NULL, w);
+
+		switch (ret) {
+		case -1:
+			if (errno != EINTR) {
+				bb_perror_msg_and_die("select");
+			}
+			continue;
+		case 0:	/* timeout */
+			break;	/* dhcp6_timer_check() will treat the case */
+		default:
+			break;
+		}
+		if (FD_ISSET(csock, &r))
+			client6_recv();
+	}
+}
+
+static struct dhcp6_timer *client6_expire_refreshtime(void *arg)
+{
+	struct dhcp6_if *ifp = (struct dhcp6_if *)arg;
+
+	log1("information refresh time on %s expired", ifp->ifname);
+
+	dhcp6_timer_remove(&ifp->timer);
+	client6_start(ifp);
+
+	return (NULL);
+}
+
+struct dhcp6_timer *client6_timo(void *arg)
+{
+	struct dhcp6_event *ev = (struct dhcp6_event *)arg;
+	struct dhcp6_if *ifp;
+	int state = ev->state;
+
+	ifp = ev->ifp;
+	ev->timeouts++;
+
+	/*
+	 * Unless MRC is zero, the message exchange fails once the client has
+	 * transmitted the message MRC times.
+	 * [RFC3315 14.]
+	 */
+	if (ev->max_retrans_cnt && ev->timeouts >= ev->max_retrans_cnt) {
+		bb_info_msg("no responses were received");
+		dhcp6_remove_event(ev);
+
+		if (state == DHCP6S_RELEASE)
+			check_exit(0);
+
+		return (NULL);
+	}
+
+	switch (ev->state) {
+	case DHCP6S_INIT:
+		ev->timeouts = 0; /* indicate to generate a new XID. */
+		if ((ifp->send_flags & DHCIFF_INFO_ONLY) || (option_mask32 & OPT_i))
+			ev->state = DHCP6S_INFOREQ;
+		else {
+			ev->state = DHCP6S_SOLICIT;
+			if (construct_confdata(ifp, ev)) {
+				bb_error_msg_and_die("can't send solicit"); /* XXX */
+			}
+		}
+		dhcp6_set_timeoparam(ev); /* XXX */
+		/* fall through */
+	case DHCP6S_REQUEST:
+	case DHCP6S_RELEASE:
+	case DHCP6S_INFOREQ:
+		client6_send(ev);
+		break;
+	case DHCP6S_RENEW:
+	case DHCP6S_REBIND:
+		if (!TAILQ_EMPTY(&ev->data_list))
+			client6_send(ev);
+		else {
+			bb_info_msg("all information to be updated was canceled");
+			dhcp6_remove_event(ev);
+			return (NULL);
+		}
+		break;
+	case DHCP6S_SOLICIT:
+		if (ev->servers) {
+			/*
+			 * Send a Request to the best server.
+			 * Note that when we set Rapid-commit in Solicit,
+			 * but a direct Reply has been delayed (very much),
+			 * the transition to DHCP6S_REQUEST (and the change of
+			 * transaction ID) will invalidate the reply even if it
+			 * ever arrives.
+			 */
+			ev->current_server = select_server(ev);
+			if (ev->current_server == NULL) {
+				/* this should not happen! */
+				bb_error_msg_and_die("can't find a server");
+			}
+			if (duidcpy(&ev->serverid,
+			    &ev->current_server->optinfo.serverID))
+				return (NULL); /* XXX: better recovery? */
+			ev->timeouts = 0;
+			ev->state = DHCP6S_REQUEST;
+			dhcp6_set_timeoparam(ev);
+
+			free(ev->authparam);
+			ev->authparam = ev->current_server->authparam;
+			ev->current_server->authparam = NULL;
+
+			if (construct_reqdata(ifp,
+			    &ev->current_server->optinfo, ev)) {
+				bb_info_msg("failed to construct request");
+				break;
+			}
+		}
+		client6_send(ev);
+		break;
+	}
+
+	dhcp6_reset_timer(ev);
+
+	return (ev->timer);
+}
+
+static int construct_confdata(struct dhcp6_if *ifp, struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL, pl;
+	struct dhcp6_ia iaparam;
+
+	TAILQ_INIT(&pl);	/* for safety */
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		evd = xzalloc(sizeof(*evd));
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+		ial = xmalloc(sizeof(*ial));
+		TAILQ_INIT(ial);
+
+		TAILQ_INIT(&pl);
+
+		switch (iac->type) {
+		case DHCPOPT_IA_PD:
+			dhcp6_copy_list(&pl,
+			    &((struct iapd_conf *)iac)->iapd_prefix_list);
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD,
+			    &iaparam, &pl) == NULL) {
+				goto fail;
+			}
+			break;
+		case DHCPOPT_IA_NA:
+			dhcp6_copy_list(&pl,
+			    &((struct iana_conf *)iac)->iana_address_list);
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA,
+			    &iaparam, &pl) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("internal error");
+		}
+
+		dhcp6_clear_list(&pl);
+
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return (0);
+
+  fail:
+	free(evd);
+	free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return (-1);
+}
+
+static int construct_reqdata(struct dhcp6_if *ifp, struct dhcp6_optinfo *optinfo,
+		  struct dhcp6_event *ev)
+{
+	struct ia_conf *iac;
+	struct dhcp6_eventdata *evd = NULL;
+	struct dhcp6_list *ial = NULL;
+	struct dhcp6_ia iaparam;
+
+	/* discard previous event data */
+	dhcp6_remove_evdata(ev);
+
+	if (optinfo == NULL)
+		return (0);
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		struct dhcp6_listval *v;
+
+		/* ignore IA config currently used */
+		if (!TAILQ_EMPTY(&iac->iadata))
+			continue;
+
+		memset(&iaparam, 0, sizeof(iaparam));
+		iaparam.iaid = iac->iaid;
+
+		switch (iac->type) {
+		case DHCPOPT_IA_PD:
+			if ((v = dhcp6_find_listval(&optinfo->iapd_list,
+			    DHCP6_LISTVAL_IAPD, &iaparam, 0)) == NULL)
+				continue;
+
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD,
+			    &iaparam, &v->sublist) == NULL) {
+				goto fail;
+			}
+			break;
+		case DHCPOPT_IA_NA:
+			if ((v = dhcp6_find_listval(&optinfo->iana_list,
+			    DHCP6_LISTVAL_IANA, &iaparam, 0)) == NULL)
+				continue;
+
+			ial = xmalloc(sizeof(*ial));
+			TAILQ_INIT(ial);
+
+			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA,
+			    &iaparam, &v->sublist) == NULL) {
+				goto fail;
+			}
+			break;
+		default:
+			bb_error_msg_and_die("internal error");
+		}
+
+		evd = xzalloc(sizeof(*evd));
+		evd->type = iac->type;
+		evd->data = ial;
+		evd->event = ev;
+		TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+	}
+
+	return (0);
+
+  fail:
+	free(evd);
+	free(ial);
+	dhcp6_remove_event(ev);	/* XXX */
+
+	return (-1);
+}
+
+static struct dhcp6_serverinfo *select_server(struct dhcp6_event *ev)
+{
+	struct dhcp6_serverinfo *s = ev->servers;
+
+	/*
+	 * pick the best server according to RFC3315 Section 17.1.3.
+	 * XXX: we currently just choose the one that is active and has the
+	 * highest preference.
+	 */
+	while (s) {
+		if (s->active) {
+			log1("picked a server (ID: %s)",
+			    duidstr(&s->optinfo.serverID));
+			return (s);
+		}
+		s = s->next;
+	}
+
+	return (NULL);
+}
+
+static struct dhcp6_serverinfo *find_server(struct dhcp6_event *ev,
+					 struct duid *duid)
+{
+	struct dhcp6_serverinfo *s = ev->servers;
+
+	while (s) {
+		if (duidcmp(&s->optinfo.serverID, duid) == 0)
+			return (s);
+
+		s = s->next;
+	}
+
+	return (NULL);
+}
+
+void client6_send(struct dhcp6_event *ev)
+{
+	struct dhcp6_if *ifp;
+	struct sockaddr_in6 dst;
+	struct dhcp6 *dh6;
+	struct dhcp6_optinfo optinfo;
+	ssize_t optlen, len;
+	struct dhcp6_list *dstlist;
+	struct dhcp6_eventdata *evd;
+
+	ifp = ev->ifp;
+
+	dh6 = (struct dhcp6 *)G.sbuf;
+	memset(dh6, 0, sizeof(*dh6));
+
+	switch (ev->state) {
+	case DHCP6S_SOLICIT:
+		dh6->dh6_msgtype = DH6_SOLICIT;
+		break;
+	case DHCP6S_REQUEST:
+		dh6->dh6_msgtype = DH6_REQUEST;
+		break;
+	case DHCP6S_RENEW:
+		dh6->dh6_msgtype = DH6_RENEW;
+		break;
+	case DHCP6S_REBIND:
+		dh6->dh6_msgtype = DH6_REBIND;
+		break;
+	case DHCP6S_RELEASE:
+		dh6->dh6_msgtype = DH6_RELEASE;
+		break;
+	case DHCP6S_INFOREQ:
+		dh6->dh6_msgtype = DH6_INFORM_REQ;
+		break;
+	default:
+		bb_error_msg_and_die("unexpected state");
+	}
+
+	if (ev->timeouts == 0) {
+		/*
+		 * A client SHOULD generate a random number that cannot easily
+		 * be guessed or predicted to use as the transaction ID for
+		 * each new message it sends.
+		 *
+		 * A client MUST leave the transaction-ID unchanged in
+		 * retransmissions of a message. [RFC3315 15.1]
+		 */
+#ifdef HAVE_ARC4RANDOM
+		ev->xid = arc4random() & DH6_XIDMASK;
+#else
+		ev->xid = random() & DH6_XIDMASK;
+#endif
+		log1("a new XID (%x) is generated",
+		    ev->xid);
+	}
+	dh6->dh6_xid &= ~ntohl(DH6_XIDMASK);
+	dh6->dh6_xid |= htonl(ev->xid);
+	len = sizeof(*dh6);
+
+	/*
+	 * construct options
+	 */
+	dhcp6_init_options(&optinfo);
+
+	/* server ID */
+	switch (ev->state) {
+	case DHCP6S_REQUEST:
+	case DHCP6S_RENEW:
+	case DHCP6S_RELEASE:
+		if (duidcpy(&optinfo.serverID, &ev->serverid))
+			goto end;
+		break;
+	}
+
+	/* client ID */
+	if (duidcpy(&optinfo.clientID, &client_duid))
+		goto end;
+
+	/* rapid commit (in Solicit only) */
+	if (ev->state == DHCP6S_SOLICIT &&
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT)) {
+		optinfo.rapidcommit = 1;
+	}
+
+	/* elapsed time */
+	if (ev->timeouts == 0) {
+		ev->t_start = monotonic_ms();
+		optinfo.elapsed_time = 0;
+	} else {
+		long long t_diff;
+		long et;
+
+		t_diff = monotonic_ms() - ev->t_start;
+
+		/*
+		 * The client uses the value 0xffff to represent any elapsed
+		 * time values greater than the largest time value that can be
+		 * represented in the Elapsed Time option (hundredths of a second).
+		 * [RFC3315 22.9.]
+		 */
+		if (t_diff >= (MAX_ELAPSED_TIME + 100LL) * 10LL) {
+			/*
+			 * Perhaps we are nervous too much, but without this
+			 * additional check, we would see an overflow in 248
+			 * days (of no responses). 
+			 */
+			et = MAX_ELAPSED_TIME;
+		} else {
+			et = t_diff / 10LL;
+			if (et >= MAX_ELAPSED_TIME)
+				et = MAX_ELAPSED_TIME;
+		}
+		optinfo.elapsed_time = (int32_t )et;
+	}
+
+	/* option request options */
+	if (ev->state != DHCP6S_RELEASE &&
+	    dhcp6_copy_list(&optinfo.reqopt_list, &ifp->reqopt_list)) {
+		bb_error_msg("failed to copy requested options");
+		goto end;
+	}
+
+	/* configuration information specified as event data */
+	evd = TAILQ_FIRST(&ev->data_list);
+	while (evd) {
+		switch (evd->type) {
+		case DHCPOPT_IA_PD:
+			dstlist = &optinfo.iapd_list;
+			break;
+		case DHCPOPT_IA_NA:
+			dstlist = &optinfo.iana_list;
+			break;
+		default:
+			bb_error_msg_and_die("unexpected event data (%d)",
+			    evd->type);
+		}
+		if (dhcp6_copy_list(dstlist, (struct dhcp6_list *)evd->data)) {
+			bb_info_msg("failed to add an IANA");
+			goto end;
+		}
+		evd = TAILQ_NEXT(evd, link);
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* authentication information */
+	if (set_auth(ev, &optinfo)) {
+		goto end;
+	}
+#endif
+
+	/* set options in the message */
+	if ((optlen = dhcp6_set_options(dh6->dh6_msgtype,
+	    (struct dhcp6opt *)(dh6 + 1),
+	    (struct dhcp6opt *)(G.sbuf + sizeof(G.sbuf)), &optinfo)) < 0) {
+		bb_error_msg("failed to construct options");
+		goto end;
+	}
+	len += optlen;
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* calculate MAC if necessary, and put it to the message */
+	if (ev->authparam != NULL) {
+		switch (ev->authparam->authproto) {
+		case DHCP6_AUTHPROTO_DELAYED:
+			if (ev->authparam->key == NULL)
+				break;
+
+			if (dhcp6_calc_mac((char *)dh6, len,
+			    optinfo.authproto, optinfo.authalgorithm,
+			    optinfo.delayedauth_offset + sizeof(*dh6),
+			    ev->authparam->key)) {
+				bb_error_msg("failed to calculate MAC");
+				goto end;
+			}
+			break;
+		default:
+			break;	/* do nothing */
+		}
+	}
+#endif
+
+	/*
+	 * Unless otherwise specified in this document or in a document that
+	 * describes how IPv6 is carried over a specific type of link (for link
+	 * types that do not support multicast), a client sends DHCP messages
+	 * to the All_DHCP_Relay_Agents_and_Servers.
+	 * [RFC3315 Section 13.]
+	 */
+	dst = G.sa6_allagent;
+	dst.sin6_scope_id = ifp->linkid;
+
+	if (sendto(csock, G.sbuf, len, 0, (struct sockaddr *)&dst,
+	    sysdep_sa_len((struct sockaddr *)&dst)) == -1) {
+		bb_perror_msg("sendto");
+		goto end;
+	}
+
+	log1("send %s to %s", dhcp6msgstr(dh6->dh6_msgtype),
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&dst));
+
+  end:
+	dhcp6_clear_options(&optinfo);
+	return;
+}
+
+static void client6_recv(void)
+{
+	struct msghdr mhdr;
+	struct iovec iov;
+	struct sockaddr_storage from;
+	struct dhcp6_if *ifp;
+	struct dhcp6opt *p, *ep;
+	struct dhcp6_optinfo optinfo;
+	ssize_t len;
+	struct dhcp6 *dh6;
+	struct cmsghdr *cm;
+	struct in6_pktinfo *pi = NULL;
+	struct dhcp6_event *ev;
+
+	memset(&iov, 0, sizeof(iov));
+	memset(&mhdr, 0, sizeof(mhdr));
+
+	iov.iov_base = (caddr_t)G.rbuf;
+	iov.iov_len = sizeof(G.rbuf);
+	mhdr.msg_name = (caddr_t)&from;
+	mhdr.msg_namelen = sizeof(from);
+	mhdr.msg_iov = &iov;
+	mhdr.msg_iovlen = 1;
+	mhdr.msg_control = (caddr_t)G.cmsgbuf;
+	mhdr.msg_controllen = sizeof(G.cmsgbuf);
+	if ((len = recvmsg(csock, &mhdr, 0)) < 0) {
+		bb_perror_msg("recvmsg");
+		return;
+	}
+
+	/* detect receiving interface */
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&mhdr); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(&mhdr, cm)) {
+		if (cm->cmsg_level == IPPROTO_IPV6 &&
+		    cm->cmsg_type == IPV6_PKTINFO &&
+		    cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {
+			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
+		}
+	}
+	if (pi == NULL) {
+		bb_info_msg("failed to get packet info");
+		return;
+	}
+
+	if ((ifp = find_ifconf_byid((unsigned int)pi->ipi6_ifindex)) == NULL) {
+		bb_info_msg("unexpected interface (%d)",
+		    (unsigned int)pi->ipi6_ifindex);
+		return;
+	}
+
+	if (len < sizeof(*dh6)) {
+		bb_info_msg("short packet (%d bytes)", (int )len);
+		return;
+	}
+
+	dh6 = (struct dhcp6 *)G.rbuf;
+
+	log1("receive %s from %s on %s", dhcp6msgstr(dh6->dh6_msgtype),
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from), ifp->ifname);
+
+	/* get options */
+	dhcp6_init_options(&optinfo);
+	p = (struct dhcp6opt *)(dh6 + 1);
+	ep = (struct dhcp6opt *)((char *)dh6 + len);
+	if (dhcp6_get_options(p, ep, &optinfo) < 0) {
+		bb_info_msg("failed to parse options");
+		return;
+	}
+
+	if (dh6->dh6_msgtype != DH6_ADVERTISE &&
+	    dh6->dh6_msgtype != DH6_REPLY) {
+		char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+		bb_info_msg("received an unexpected message (%s) from %s",
+			dhcp6msgstr(dh6->dh6_msgtype), a);
+		free(a);
+		goto fail;
+	}
+
+	/* find the corresponding event based on the received xid */
+	ev = find_event_withid(ifp, ntohl(dh6->dh6_xid) & DH6_XIDMASK);
+	if (ev == NULL) {
+		bb_error_msg("XID mismatch");
+		goto fail;
+	}
+
+	/* packet validation based on Section 15.3 of RFC3315. */
+	if (optinfo.serverID.duid_len == 0) {
+		bb_error_msg("no server ID option");
+		goto fail;
+	}
+
+	if (optinfo.clientID.duid_len == 0) {
+		bb_error_msg("no client ID option");
+		goto fail;
+	}
+	/*
+	 * DUID in the Client ID option (which must be contained for our
+	 * client implementation) must match ours.
+	 */
+	if (duidcmp(&optinfo.clientID, &client_duid)) {
+		bb_error_msg("client DUID mismatch");
+		goto fail;
+	}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* validate authentication */
+	if (process_auth(ev->authparam, dh6, len, &optinfo)) {
+		bb_error_msg("failed to process authentication");
+		goto fail;
+	}
+#endif
+
+	switch (dh6->dh6_msgtype) {
+	case DH6_ADVERTISE:
+		client6_recvadvert(ifp, ev, &optinfo);
+		break;
+	case DH6_REPLY:
+		client6_recvreply(ifp, ev, &optinfo);
+		break;
+	}
+
+fail:
+	dhcp6_clear_options(&optinfo);
+	return;
+}
+
+static int client6_recvadvert(struct dhcp6_if *ifp, struct dhcp6_event *ev,
+				struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_serverinfo *newserver, **sp;
+	struct dhcp6_eventdata *evd;
+
+	/*
+	 * The requesting router MUST ignore any Advertise message that
+	 * includes a Status Code option containing the value NoPrefixAvail
+	 * [RFC3633 Section 11.1].
+	 * Likewise, the client MUST ignore any Advertise message that includes
+	 * a Status Code option containing the value NoAddrsAvail. 
+	 * [RFC3315 Section 17.1.3].
+	 * We only apply this when we are going to request an address or
+	 * a prefix.
+	 */
+	for (evd = TAILQ_FIRST(&ev->data_list); evd;
+	    evd = TAILQ_NEXT(evd, link)) {
+		uint16_t stcode;
+		const char *stcodestr;
+
+		switch (evd->type) {
+		case DHCPOPT_IA_PD:
+			stcode = DH6OPT_STCODE_NOPREFIXAVAIL;
+			stcodestr = "NoPrefixAvail";
+			break;
+		case DHCPOPT_IA_NA:
+			stcode = DH6OPT_STCODE_NOADDRSAVAIL;
+			stcodestr = "NoAddrsAvail";
+			break;
+		default:
+			continue;
+		}
+		if (dhcp6_find_listval(&optinfo->stcode_list,
+		    DHCP6_LISTVAL_STCODE, &stcode, 0)) {
+			bb_error_msg("advertise contains %s status", stcodestr);
+			return (-1);
+		}
+	}
+
+	if (ev->state != DHCP6S_SOLICIT ||
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) || (option_mask32 & OPT_i)) {
+		/*
+		 * We expected a reply message, but do actually receive an
+		 * Advertise message.  The server should be configured not to
+		 * allow the Rapid Commit option.
+		 * We process the message as if we expected the Advertise.
+		 * [RFC3315 Section 17.1.4]
+		 */
+		bb_info_msg("unexpected advertise");
+		/* proceed anyway */
+	}
+
+	/* ignore the server if it is known */
+	if (find_server(ev, &optinfo->serverID)) {
+		bb_info_msg("duplicated server (ID: %s)",
+		    duidstr(&optinfo->serverID));
+		return (-1);
+	}
+
+	/* keep the server */
+	newserver = xzalloc(sizeof(*newserver));
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	/* remember authentication parameters */
+	newserver->authparam = ev->authparam;
+
+	/* allocate new authentication parameter for the soliciting event */
+	ev->authparam = new_authparam(ev->authparam->authproto,
+		ev->authparam->authalgorithm, ev->authparam->authrdm);
+#endif
+
+	/* copy options */
+	dhcp6_init_options(&newserver->optinfo);
+	if (dhcp6_copy_options(&newserver->optinfo, optinfo)) {
+		bb_error_msg("failed to copy options");
+		free(newserver->authparam);
+		free(newserver);
+		return (-1);
+	}
+	if (optinfo->pref != DH6OPT_PREF_UNDEF)
+		newserver->pref = optinfo->pref;
+	newserver->active = 1;
+	for (sp = &ev->servers; *sp; sp = &(*sp)->next) {
+		if ((*sp)->pref != DH6OPT_PREF_MAX &&
+		    (*sp)->pref < newserver->pref) {
+			break;
+		}
+	}
+	newserver->next = *sp;
+	*sp = newserver;
+
+	if (newserver->pref == DH6OPT_PREF_MAX) {
+		/*
+		 * If the client receives an Advertise message that includes a
+		 * Preference option with a preference value of 255, the client
+		 * immediately begins a client-initiated message exchange.
+		 * [RFC3315 Section 17.1.2]
+		 */
+		ev->current_server = newserver;
+		if (duidcpy(&ev->serverid, &ev->current_server->optinfo.serverID))
+			return (-1); /* XXX: better recovery? */
+		if (construct_reqdata(ifp, &ev->current_server->optinfo, ev)) {
+			bb_info_msg("failed to construct request");
+			return (-1); /* XXX */
+		}
+
+		ev->timeouts = 0;
+		ev->state = DHCP6S_REQUEST;
+
+		free(ev->authparam);
+		ev->authparam = newserver->authparam;
+		newserver->authparam = NULL;
+
+		client6_send(ev);
+
+		dhcp6_set_timeoparam(ev);
+		dhcp6_reset_timer(ev);
+	} else if (ev->servers->next == NULL) {
+		unsigned long long elapsed, timo;
+
+		/*
+		 * If this is the first advertise, adjust the timer so that
+		 * the client can collect other servers until IRT elapses.
+		 */
+		elapsed = ev->retrans - dhcp6_timer_rest(ev->timer);
+		if (elapsed <= ev->init_retrans)
+			timo = ev->init_retrans - elapsed;
+		else
+			timo = 0;
+
+		log1("reset timer for %s to %d.%03d",
+		    ifp->ifname, (int )(timo/1000ULL), (int )(timo%1000ULL));
+
+		dhcp6_timer_set(timo, ev->timer);
+	}
+
+	return (0);
+}
+
+static int client6_recvreply(struct dhcp6_if *ifp, struct dhcp6_event *ev,
+				struct dhcp6_optinfo *optinfo)
+{
+	struct dhcp6_listval *lv;
+	int state;
+
+	state = ev->state;
+	if (state != DHCP6S_INFOREQ &&
+	    state != DHCP6S_REQUEST &&
+	    state != DHCP6S_RENEW &&
+	    state != DHCP6S_REBIND &&
+	    state != DHCP6S_RELEASE &&
+	    (state != DHCP6S_SOLICIT || !(ifp->send_flags & DHCIFF_RAPID_COMMIT))
+	    ) {
+		bb_info_msg("unexpected reply");
+		return (-1);
+	}
+
+	/*
+	 * If the client included a Rapid Commit option in the Solicit message,
+	 * the client discards any Reply messages it receives that do not
+	 * include a Rapid Commit option.
+	 * (should we keep the server otherwise?)
+	 * [RFC3315 Section 17.1.4]
+	 */
+	if (state == DHCP6S_SOLICIT &&
+	    (ifp->send_flags & DHCIFF_RAPID_COMMIT) &&
+	    !optinfo->rapidcommit) {
+		bb_info_msg("no rapid commit");
+		return (-1);
+	}
+
+	/*
+	 * The client MAY choose to report any status code or message from the
+	 * status code option in the Reply message.
+	 * [RFC3315 Section 18.1.8]
+	 */
+	for (lv = TAILQ_FIRST(&optinfo->stcode_list); lv;
+	     lv = TAILQ_NEXT(lv, link)) {
+		bb_info_msg("status code: %s", dhcp6_stcodestr(lv->val_num16));
+	}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	if (!TAILQ_EMPTY(&optinfo->dns_list)) {
+		struct dhcp6_listval *d;
+		int i = 0;
+		char a[INET6_ADDRSTRLEN];
+
+		for (d = TAILQ_FIRST(&optinfo->dns_list); d;
+		     d = TAILQ_NEXT(d, link), i++) {
+			sprint_nip6(a, (const uint8_t *)&d->val_addr6);
+			log1("nameserver[%d] %s", i, a);
+		}
+	}
+
+	if (!TAILQ_EMPTY(&optinfo->dnsname_list)) {
+		struct dhcp6_listval *d;
+		int i = 0;
+
+		for (d = TAILQ_FIRST(&optinfo->dnsname_list); d;
+		     d = TAILQ_NEXT(d, link), i++) {
+			log1("Domain search list[%d] %s",
+			    i, d->val_vbuf.dv_buf);
+		}
+	}
+#endif /* CONFIG_UDHCP_DEBUG */
+
+	/*
+	 * Set refresh timer for configuration information specified in
+	 * information-request.  If the timer value is specified by the server
+	 * in an information refresh time option, use it; use the protocol
+	 * default otherwise.
+	 */
+	if (state == DHCP6S_INFOREQ) {
+		unsigned long long refreshtime = DHCP6_IRT_DEFAULT;
+
+		if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF)
+			refreshtime = optinfo->refreshtime;
+
+		ifp->timer = dhcp6_timer_add(client6_expire_refreshtime, ifp);
+
+		if (refreshtime > 0x7fffffffULL) {
+			/*
+			 * XXX: tv_sec can overflow for an
+			 * unsigned 32bit value.
+			 */
+			bb_info_msg("refresh time is too large: %llu", refreshtime);
+			refreshtime = 0x7fffffffULL * 1000ULL;
+		}
+		else
+			refreshtime *= 1000ULL;
+		dhcp6_timer_set(refreshtime, ifp->timer);
+
+	} else if (optinfo->refreshtime != DH6OPT_REFRESHTIME_UNDEF) {
+		/*
+		 * draft-ietf-dhc-lifetime-02 clarifies that refresh time
+		 * is only used for information-request and reply exchanges.
+		 */
+		bb_info_msg("unexpected information refresh time option (ignored)");
+	}
+
+	/* update stateful configuration information */
+	if (state != DHCP6S_RELEASE) {
+		update_ia(DHCPOPT_IA_PD, &optinfo->iapd_list, ifp,
+		    &optinfo->serverID, ev->authparam);
+		update_ia(DHCPOPT_IA_NA, &optinfo->iana_list, ifp,
+		    &optinfo->serverID, ev->authparam);
+	}
+
+	/*
+	 * Call the configuration script, if specified, to handle various
+	 * configuration parameters.
+	 */
+	if (ifp->scriptpath != NULL) {
+		log1("executes %s", ifp->scriptpath);
+		dhcp6_script(ifp->scriptpath,
+			     fill_envp_client6(optinfo, ifp->ifname));
+	}
+
+	dhcp6_remove_event(ev);
+
+	if (state == DHCP6S_RELEASE) {
+		/*
+		 * When the client receives a valid Reply message in response
+		 * to a Release message, the client considers the Release event
+		 * completed, regardless of the Status Code option(s) returned
+		 * by the server.
+		 * [RFC3315 Section 18.1.8]
+		 */
+		check_exit(0);
+	}
+
+	log1("got an expected reply, sleeping.");
+
+	if (option_mask32 & OPT_i) {
+		check_exit(1);
+	}
+	return (0);
+}
+
+static struct dhcp6_event *find_event_withid(struct dhcp6_if *ifp, uint32_t xid)
+{
+	struct dhcp6_event *ev;
+
+	for (ev = TAILQ_FIRST(&ifp->event_list); ev;
+	     ev = TAILQ_NEXT(ev, link)) {
+		if (ev->xid == xid)
+			return (ev);
+	}
+
+	return (NULL);
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int
+process_auth(struct authparam *authparam, struct dhcp6 *dh6, ssize_t len,
+	     struct dhcp6_optinfo *optinfo)
+{
+	struct keyinfo *key = NULL;
+	int authenticated = 0;
+
+	switch (optinfo->authproto) {
+	case DHCP6_AUTHPROTO_UNDEF:
+		/* server did not provide authentication option */
+		break;
+	case DHCP6_AUTHPROTO_DELAYED:
+		if ((optinfo->authflags & DHCP6OPT_AUTHFLAG_NOINFO)) {
+			bb_info_msg("server did not include "
+			    "authentication information");
+			break;
+		}
+
+		if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
+			bb_info_msg("unknown authentication algorithm: %d",
+				 optinfo->authalgorithm);
+			break;
+		}
+
+		if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
+			bb_info_msg("unknown RDM (%d)",
+			    optinfo->authrdm);
+			break;
+		}
+
+		/*
+		 * Replay protection.  If we do not know the previous RD value,
+		 * we accept the message anyway (XXX).
+		 */
+		if ((authparam->flags & AUTHPARAM_FLAGS_NOPREVRD)) {
+			bb_info_msg("previous RD value is unknown (accept it)");
+		} else {
+			if (dhcp6_auth_replaycheck(optinfo->authrdm,
+			    authparam->prevrd, optinfo->authrd)) {
+				bb_info_msg("possible replay attack detected");
+				break;
+			}
+		}
+
+		/* identify the secret key */
+		if ((key = authparam->key) != NULL) {
+			/*
+			 * If we already know a key, its identification should
+			 * match that contained in the received option.
+			 * (from Section 21.4.5.1 of RFC3315)
+			 */
+			if (optinfo->delayedauth_keyid != key->keyid ||
+			    optinfo->delayedauth_realmlen != key->realmlen ||
+			    memcmp(optinfo->delayedauth_realmval, key->realm,
+			    key->realmlen) != 0) {
+				bb_info_msg("authentication key mismatch");
+				break;
+			}
+		} else {
+			key = find_key(optinfo->delayedauth_realmval,
+			    optinfo->delayedauth_realmlen,
+			    optinfo->delayedauth_keyid);
+			if (key == NULL) {
+				bb_info_msg("failed to find key "
+				    "provided by the server (ID: %x)",
+				    optinfo->delayedauth_keyid);
+				break;
+			} else {
+				log1("found key for "
+				    "authentication: %s", key->name);
+			}
+			authparam->key = key;
+		}
+
+		/* check for the key lifetime */
+		if (dhcp6_validate_key(key)) {
+			bb_info_msg("key %s has expired", key->name);
+			break;
+		}
+
+		/* validate MAC */
+		if (dhcp6_verify_mac((char *)dh6, len, optinfo->authproto,
+		    optinfo->authalgorithm,
+		    optinfo->delayedauth_offset + sizeof(*dh6), key) == 0) {
+			log1("message authentication validated");
+			authenticated = 1;
+		} else {
+			bb_info_msg("invalid message authentication");
+		}
+
+		break;
+	default:
+		bb_info_msg("unsupported authentication protocol: %d",
+			 optinfo->authproto);
+		break;
+	}
+
+	if (authenticated == 0) {
+		if (authparam->authproto != DHCP6_AUTHPROTO_UNDEF) {
+			bb_info_msg("message not authenticated "
+			    "while authentication required");
+
+			/*
+			 * Right now, we simply discard unauthenticated
+			 * messages.
+			 */
+			return (-1);
+		}
+	} else {
+		/* if authenticated, update the "previous" RD value */
+		authparam->prevrd = optinfo->authrd;
+		authparam->flags &= ~AUTHPARAM_FLAGS_NOPREVRD;
+	}
+
+	return (0);
+}
+
+static int set_auth(struct dhcp6_event *ev, struct dhcp6_optinfo *optinfo)
+{
+	struct authparam *authparam = ev->authparam;
+
+	if (authparam == NULL)
+		return (0);
+
+	optinfo->authproto = authparam->authproto;
+	optinfo->authalgorithm = authparam->authalgorithm;
+	optinfo->authrdm = authparam->authrdm;
+
+	switch (authparam->authproto) {
+	case DHCP6_AUTHPROTO_UNDEF: /* we simply do not need authentication */
+		return (0);
+	case DHCP6_AUTHPROTO_DELAYED:
+		if (ev->state == DHCP6S_INFOREQ) {
+			/*
+			 * In the current implementation, delayed
+			 * authentication for Information-request and Reply
+			 * exchanges doesn't work.  Specification is also
+			 * unclear on this usage.
+			 */
+			bb_info_msg("delayed authentication "
+			    "cannot be used for Information-request yet");
+			return (-1);
+		}
+
+		if (ev->state == DHCP6S_SOLICIT) {
+			optinfo->authflags |= DHCP6OPT_AUTHFLAG_NOINFO;
+			return (0); /* no auth information is needed */
+		}
+
+		if (authparam->key == NULL) {
+			bb_info_msg("no authentication key");
+			return (-1);
+		}
+
+		if (dhcp6_validate_key(authparam->key)) {
+			bb_info_msg("key %s is invalid",
+			    authparam->key->name);
+			return (-1);
+		}
+
+		if (get_rdvalue(optinfo->authrdm, &optinfo->authrd,
+		    sizeof(optinfo->authrd))) {
+			bb_error_msg("failed to get a replay detection value");
+			return (-1);
+		}
+
+		optinfo->delayedauth_keyid = authparam->key->keyid;
+		optinfo->delayedauth_realmlen = authparam->key->realmlen;
+		optinfo->delayedauth_realmval =
+		    malloc_or_warn(optinfo->delayedauth_realmlen);
+		if (optinfo->delayedauth_realmval == NULL)
+			return (-1);
+		memcpy(optinfo->delayedauth_realmval, authparam->key->realm,
+		    optinfo->delayedauth_realmlen);
+
+		break;
+	default:
+		bb_error_msg("unsupported authentication protocol: %d",
+		    authparam->authproto);
+		return (-1);
+	}
+
+	return (0);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH*/
+
diff -urNBp busybox.orig/networking/udhcp/dhcp6c.h busybox/networking/udhcp/dhcp6c.h
--- busybox.orig/networking/udhcp/dhcp6c.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c.h	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifdef __GNUC__
+#define DHCP6_AUTH_ATTR(x)	IF_NOT_FEATURE_DHCP6_AUTH(__attribute__(x))
+#else
+#define DHCP6_AUTH_ATTR(x)
+#endif
+
+struct dhcp6_timer *client6_timo(void *);
+int client6_start(struct dhcp6_if *);
+void client6_send(struct dhcp6_event *);
+
+
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, char *ifname);
+char **fill_envp_relay6(struct dhcp6_optinfo *optinfo, char *clientaddr);
+int dhcp6_script(const char *scriptpath, char **envp);
diff -urNBp busybox.orig/networking/udhcp/dhcp6c_ia.c busybox/networking/udhcp/dhcp6c_ia.c
--- busybox.orig/networking/udhcp/dhcp6c_ia.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c_ia.c	2011-05-24 20:23:28.000000000 +0400
@@ -0,0 +1,896 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/queue.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+
+#include <netinet/in.h>
+
+#include <syslog.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+#include "dhcp6c_ia.h"
+
+typedef enum {IAS_ACTIVE, IAS_RENEW, IAS_REBIND} iastate_t;
+
+struct ia {
+	TAILQ_ENTRY(ia) link;
+
+	/* back pointer to configuration */
+	struct ia_conf *conf;
+
+	/* common parameters of IA */
+	uint32_t t1;		/* duration for renewal */
+	uint32_t t2;		/* duration for rebind  */
+
+	/* internal parameters for renewal/rebinding */
+	iastate_t state;
+	struct dhcp6_timer *timer;
+
+	/* DHCP related parameters */
+	struct dhcp6_if *ifp;	/* DHCP interface */
+	struct duid serverid;	/* the server ID that provided this IA */
+
+	/* control information shared with each particular config routine */
+	struct iactl *ctl;
+
+	/* authentication parameters for transaction with servers on this IA */
+	struct authparam *authparam;
+};
+
+void destruct_iadata(struct dhcp6_eventdata *evd);
+
+static int prepare_iaevent(struct ia *, int);
+static int reestablish_ia(struct ia *);
+static void remove_ia(struct ia *);
+static struct ia *get_ia(dh6cnfopts_t, struct dhcp6_if *, struct ia_conf *,
+    struct dhcp6_listval *, struct duid *);
+static struct ia *find_ia(struct ia_conf *, dh6cnfopts_t, uint32_t);
+static struct dhcp6_timer *ia_timo(void *);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int update_authparam(struct ia *, struct authparam *);
+#endif
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *iastatestr(iastate_t);
+#endif
+
+static int update_prefix6(dh6cnfopts_t, struct ia *, struct dhcp6_listval *,
+        struct pifc_list *, struct dhcp6_if *, struct iactl **);
+static struct iaprefix *find_iaprefix(struct iaprefix_list *,
+    struct dhcp6_prefix *, int);
+static int remove_iaprefix(struct iaprefix *, dh6cnfopts_t);
+
+static int iapref_renew(struct iactl *, struct dhcp6_ia *,
+        struct dhcp6_eventdata *);
+static ALWAYS_INLINE int pref_isvalid(struct iactl *);
+static uint32_t pref_duration(struct iactl *);
+static void pref_cleanup(struct iactl *);
+static struct dhcp6_timer *iapref_timo(void *);
+static int add_ifprefix(struct iaprefix *,
+    struct dhcp6_prefix *, struct prefix_ifconf *);
+
+static ALWAYS_INLINE int pd_ifaddrconf(ifaddrconf_cmd_t, struct dhcp6_ifprefix *ifpfx);
+static int na_ifaddrconf(ifaddrconf_cmd_t, struct iaprefix *);
+
+
+void update_ia(dh6cnfopts_t iatype, struct dhcp6_list *ialist, struct dhcp6_if *ifp,
+	  struct duid *serverid,
+	  struct authparam *authparam DHCP6_AUTH_ATTR((unused)))
+{
+	struct ia *ia;
+	struct ia_conf *iac;
+	struct iapd_conf *iapdc;
+	struct dhcp6_listval *iav, *siav;
+
+	for (iav = TAILQ_FIRST(ialist); iav; iav = TAILQ_NEXT(iav, link)) {
+		/* if we're not interested in this IA, ignore it. */
+		if ((iac = find_iaconf(&ifp->iaconf_list, iatype,
+		    iav->val_ia.iaid)) == NULL) {
+			continue;
+		}
+
+		/* validate parameters */
+		/*
+		 * If a client receives an IA_NA with T1 greater than T2, and
+		 * both T1 and T2 are greater than 0, the client discards the
+		 * IA_NA option and processes the remainder of the message as
+		 * though the server had not included the invalid IA_NA option.
+		 * [RFC3315 22.4]
+		 * We apply the same rule to IA_PD as well.
+		 */
+		if (iav->val_ia.t2 != 0 && iav->val_ia.t1 > iav->val_ia.t2) {
+			bb_info_msg("invalid IA: T1(%u) > T2(%u)",
+			    iav->val_ia.t1, iav->val_ia.t2);
+			continue;
+		}
+
+		/* locate the local IA or make a new one */
+		ia = get_ia(iatype, ifp, iac, iav, serverid);
+		if (ia == NULL) {
+			bb_info_msg("failed to get an IA "
+			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
+			continue;
+		}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+		/* update authentication parameters */
+		if (update_authparam(ia, authparam)) {
+			bb_info_msg("failed to update "
+			    "authentication param for IA "
+			    "type: %s, ID: %u", iastr(iac->type), iac->iaid);
+			remove_ia(ia);
+			continue;
+		}
+#endif
+
+		/* update IA configuration information */
+		for (siav = TAILQ_FIRST(&iav->sublist); siav;
+		    siav = TAILQ_NEXT(siav, link)) {
+			char p[INET6_ADDRSTRLEN];
+
+			switch (siav->type) {
+			case DHCP6_LISTVAL_PREFIX6:
+				/* add or update the prefix */
+				iapdc = (struct iapd_conf *)iac;
+				if (update_prefix6(DHCPOPT_IA_PD, ia, siav,
+				    &iapdc->iapd_pif_list, ifp, &ia->ctl)) {
+					sprint_nip6(p, (const uint8_t *)&siav->val_prefix6.addr);
+					bb_error_msg("failed to update a prefix %s/%d",
+					    p, siav->val_prefix6.plen);
+				}
+				break;
+			case DHCP6_LISTVAL_STATEFULADDR6:
+				if (update_prefix6(DHCPOPT_IA_NA, ia, siav,
+				    NULL, ifp, &ia->ctl)) {
+					sprint_nip6(p, (const uint8_t *)&siav->val_statefuladdr6.addr);
+					bb_error_msg("failed to update an address %s",
+					    p);
+				}
+				break;
+			case DHCP6_LISTVAL_STCODE:
+				bb_info_msg("status code for %s-%u: %s",
+				    iastr(iatype), iav->val_ia.iaid,
+				    dhcp6_stcodestr(siav->val_num16));
+				if ((ia->state == IAS_RENEW ||
+				    ia->state == IAS_REBIND) &&
+				    siav->val_num16 == DH6OPT_STCODE_NOBINDING) {
+					/*
+					 * For each IA in the original Renew or
+					 * Rebind message, the client
+					 * sends a Request message if the IA
+					 * contained a Status Code option
+					 * with the NoBinding status.
+					 * [RFC3315 18.1.8]
+					 * XXX: what about the PD case?
+					 */
+					bb_info_msg("receive NoBinding against "
+					    "renew/rebind for %s-%u",
+					    iastr(ia->conf->type),
+					    ia->conf->iaid);
+					reestablish_ia(ia);
+					goto nextia;
+				}
+				break;
+			default:
+				bb_error_msg("impossible subopt");
+				goto nextia;
+			}
+		}
+
+		/* see if this IA is still valid.  if not, remove it. */
+		if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+			log1("IA %s-%u invalidated",
+			    iastr(ia->conf->type), ia->conf->iaid);
+			remove_ia(ia);
+			continue;
+		}
+
+		/* if T1 or T2 is 0, determine appropriate values locally. */
+		if (ia->t1 == 0 || ia->t2 == 0) {
+			uint32_t duration;
+
+			if (ia->ctl)
+				duration = pref_duration(ia->ctl);
+			else
+				duration = 1800; /* 30min. XXX: no rationale */
+
+			if (ia->t1 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t1 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t1 = duration / 2;
+			}
+			if (ia->t2 == 0) {
+				if (duration == DHCP6_DURATION_INFINITE)
+					ia->t2 = DHCP6_DURATION_INFINITE;
+				else
+					ia->t2 = duration * 4 / 5;
+			}
+
+			/* make sure T1 <= T2 */
+			if (ia->t1 > ia->t2)
+				ia->t1 = ia->t2 * 5 / 8;
+
+			bb_info_msg("T1(%u) and/or T2(%u) "
+			    "is locally determined",  ia->t1, ia->t2);
+		}
+
+		/*
+		 * Be proactive for too-small timeout values.  Note that
+		 * the adjusted values may make some information expire
+		 * without renewal.
+		 */
+		if (ia->t2 < DHCP6_DURATION_MIN) {
+			bb_info_msg("T1 (%u) or T2 (%u) "
+			    "is too small", ia->t1, ia->t2);
+			ia->t2 = DHCP6_DURATION_MIN;
+			ia->t1 = ia->t2 * 5 / 8;
+			bb_info_msg(" adjusted to %u and %u", ia->t1, ia->t2);
+		}
+
+		/* set up a timer for this IA. */
+		if (ia->t1 == DHCP6_DURATION_INFINITE) {
+			if (ia->timer)
+				dhcp6_timer_remove(&ia->timer);
+		} else {
+			if (ia->timer == NULL)
+				ia->timer = dhcp6_timer_add(ia_timo, ia);
+			dhcp6_timer_set(ia->t1 * 1000ULL, ia->timer);
+		}
+
+		ia->state = IAS_ACTIVE;
+
+	  nextia:
+		;
+	}
+}
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+static int update_authparam(struct ia *ia, struct authparam *authparam)
+{
+	if (authparam == NULL)
+		return (0);
+
+	if (ia->authparam == NULL) {
+		if ((ia->authparam = copy_authparam(authparam)) == NULL) {
+			return (-1);
+		}
+		return (0);
+	}
+
+	/* update the previous RD value and flags */
+	ia->authparam->prevrd = authparam->prevrd;
+	ia->authparam->flags = authparam->flags;
+
+	return (0);
+}
+#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+
+static int prepare_iaevent(struct ia *ia, int dhcpstate)
+{
+	struct dhcp6_event *ev;
+	struct dhcp6_ia iaparam;
+	struct dhcp6_eventdata *evd;
+
+	ev = dhcp6_create_event(ia->ifp, dhcpstate);
+
+	if (dhcpstate == DHCP6S_RELEASE ||
+	    dhcpstate == DHCP6S_REQUEST ||
+	    dhcpstate == DHCP6S_RENEW   ) {
+		if (duidcpy(&ev->serverid, &ia->serverid))
+			goto fail;
+	}
+
+	evd = xzalloc(sizeof(*evd));
+	evd->event = ev;
+	memset(&iaparam, 0, sizeof(iaparam));
+	iaparam.iaid = ia->conf->iaid;
+	/* XXX: should we set T1/T2 to 0 on release?  spec is silent on this. */
+	iaparam.t1 = ia->t1;
+	iaparam.t2 = ia->t2;
+
+	if (ia->ctl && iapref_renew(ia->ctl, &iaparam, evd)) {
+		bb_error_msg("failed to prepare IA data");
+			goto fail;
+	}
+	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+
+#if ENABLE_FEATURE_DHCP6_AUTH
+	if (ia->authparam != NULL) {
+		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
+			goto fail;
+		}
+	}
+#endif
+
+	ev->timeouts = 0;
+	dhcp6_set_timeoparam(ev);
+	dhcp6_reset_timer(ev);
+
+	client6_send(ev);
+	return (0);
+
+fail:
+	if (ev)
+		dhcp6_remove_event(ev);
+	return (-1);
+}
+
+static int reestablish_ia(struct ia *ia)
+{
+
+	log1("re-establishing IA: %s-%u", 
+	    iastr(ia->conf->type), ia->conf->iaid);
+
+	if (ia->state != IAS_RENEW && ia->state != IAS_REBIND) {
+		bb_error_msg_and_die("invalid IA status");
+	}
+
+	/* we don't need a timer for the IA (see comments in ia_timo()) */
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	return (prepare_iaevent(ia, DHCP6S_REQUEST));
+}
+
+void release_all_ia(struct dhcp6_if *ifp)
+{
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
+			ia_next = TAILQ_NEXT(ia, link);
+
+			log1("release an IA: %s-%u",
+				iastr(ia->conf->type), ia->conf->iaid);
+
+			prepare_iaevent(ia, DHCP6S_RELEASE);
+
+			/*
+			 * The client MUST stop using all of the addresses
+			 * being released as soon as the client begins the
+			 * Release message exchange process.
+			 * [RFC3315 Section 18.1.6]
+			 */
+			remove_ia(ia);
+		}
+	}
+}
+
+static void remove_ia(struct ia *ia)
+{
+	struct ia_conf *iac = ia->conf;
+	struct dhcp6_if *ifp = ia->ifp;
+
+	log1("remove an IA: %s-%u", iastr(ia->conf->type), ia->conf->iaid);
+
+	TAILQ_REMOVE(&iac->iadata, ia, link);
+
+	duidfree(&ia->serverid);
+
+	if (ia->timer)
+		dhcp6_timer_remove(&ia->timer);
+
+	if (ia->ctl)
+		pref_cleanup(ia->ctl);
+
+	free(ia->authparam);
+	free(ia);
+
+	(void)client6_start(ifp);
+}
+
+static struct dhcp6_timer *ia_timo(void *arg)
+{
+	struct ia *ia = (struct ia *)arg;
+	int dhcpstate;
+
+	log1("IA timeout for %s-%u, state=%s",
+	    iastr(ia->conf->type), ia->conf->iaid, iastatestr(ia->state));
+
+	switch (ia->state) {
+	case IAS_ACTIVE:
+		ia->state = IAS_RENEW;
+		dhcpstate = DHCP6S_RENEW;
+		dhcp6_timer_set((ia->t1 < ia->t2) ? (ia->t2 - ia->t1) * 1000ULL
+						  : 0,
+				ia->timer);
+		break;
+	case IAS_RENEW:
+		ia->state = IAS_REBIND;
+		dhcpstate = DHCP6S_REBIND;
+
+		/*
+		 * We need keep DUID for sending Release in this state.
+		 * But we don't need a timer for the IA.  We'll just wait for a
+		 * reply for the REBIND until all associated configuration
+		 * parameters for this IA expire.
+		 */
+		dhcp6_timer_remove(&ia->timer);
+		break;
+	default:
+		bb_error_msg("invalid IA state (%d)", (int)ia->state);
+		return (NULL);	/* XXX */
+	}
+
+	if (prepare_iaevent(ia, dhcpstate) == 0)
+		return (ia->timer);
+	else
+		return (NULL);
+}
+
+static struct ia *get_ia(dh6cnfopts_t type, struct dhcp6_if *ifp,
+	struct ia_conf *iac, struct dhcp6_listval *iaparam,
+	struct duid *serverid)
+{
+	struct ia *ia;
+	int create;
+
+	if ((ia = find_ia(iac, type, iaparam->val_ia.iaid)) == NULL) {
+		ia = xzalloc(sizeof(*ia));
+		ia->state = IAS_ACTIVE;
+
+		TAILQ_INSERT_TAIL(&iac->iadata, ia, link);
+		ia->conf = iac;
+
+		create = 1;
+	} else {
+		duidfree(&ia->serverid);
+
+		create = 0;
+	}
+
+	ia->t1 = iaparam->val_ia.t1;
+	ia->t2 = iaparam->val_ia.t2;
+	ia->ifp = ifp;
+	if (duidcpy(&ia->serverid, serverid))
+		return (NULL);
+
+	log1("%s an IA: %s-%u",
+	    create ? "make" : "update", iastr(type), ia->conf->iaid);
+
+	return (ia);
+}
+
+static struct ia *find_ia(struct ia_conf *iac, dh6cnfopts_t type, uint32_t iaid)
+{
+	struct ia *ia;
+
+	for (ia = TAILQ_FIRST(&iac->iadata); ia;
+	    ia = TAILQ_NEXT(ia, link)) {
+		if (ia->conf->type == type && ia->conf->iaid == iaid)
+			return (ia);
+	}
+
+	return (NULL);
+}
+
+void destruct_iadata(struct dhcp6_eventdata *evd)
+{
+	struct dhcp6_list *ial;
+
+	if (evd->type != DHCPOPT_IA_PD && evd->type != DHCPOPT_IA_NA) {
+		bb_error_msg_and_die("assumption failure %d", evd->type);
+	}
+
+	ial = (struct dhcp6_list *)evd->data;
+	dhcp6_clear_list(ial);
+	free(ial);
+
+	free(evd);
+}
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+static const char *iastatestr(iastate_t state)
+{
+	switch (state) {
+	case IAS_ACTIVE:
+		return "ACTIVE";
+	case IAS_RENEW:
+		return "RENEW";
+	case IAS_REBIND:
+		return "REBIND";
+	default:
+		return "???";	/* should be a bug */
+	}
+}
+#endif
+
+
+static int update_prefix6(dh6cnfopts_t type, struct ia *ia, struct dhcp6_listval *lv,
+		struct pifc_list *pifc,	struct dhcp6_if * dhcpifp,
+		struct iactl **ctlp)
+{
+	struct iactl *iac = (struct iactl *)*ctlp;
+	struct iaprefix *sp;
+	struct dhcp6_prefix pinfo;
+	struct prefix_ifconf *pif;
+	int spcreate = 0;
+	char p[INET6_ADDRSTRLEN];
+
+	switch (type) {
+		case DHCPOPT_IA_PD:
+			memcpy(&pinfo, &lv->uv.uv_prefix6, sizeof(pinfo));
+			break;
+		case DHCPOPT_IA_NA:
+			memcpy(&pinfo, &lv->uv.uv_statefuladdr6, sizeof(struct dhcp6_statefuladdr));
+			pinfo.plen = 128;
+			break;
+		default:
+			break;
+	}
+
+	/*
+	 * A client discards any addresses for which the preferred
+         * lifetime is greater than the valid lifetime.
+	 * [RFC3315 22.6] 
+	 */
+	sprint_nip6(p, (const uint8_t *)&pinfo.addr);
+	if (pinfo.vltime != DHCP6_DURATION_INFINITE &&
+	    (pinfo.pltime == DHCP6_DURATION_INFINITE ||
+	    pinfo.pltime > pinfo.vltime)) {
+		bb_info_msg("%s/%d has larger preferred lifetime "
+		    "than valid lifetime",
+		    p, pinfo.plen);
+		return (-1);
+	}
+
+	if (iac == NULL) {
+		iac = xzalloc(sizeof(*iac));
+		iac->iactl_ia = ia;
+		iac->type = type;
+
+		iac->pifc_head = pifc;
+		TAILQ_INIT(&iac->iaprefix_head);
+		*ctlp = (struct iactl *)iac;
+	}
+
+	/* search for the given prefix, and make a new one if it fails */
+	if ((sp = find_iaprefix(&iac->iaprefix_head, &pinfo, (type==DHCPOPT_IA_PD))) == NULL) {
+		sp = xzalloc(sizeof(*sp));
+		sp->pa.addr = pinfo.addr;
+		sp->pa.plen = pinfo.plen;
+		sp->ctl = iac;
+
+		if (type == DHCPOPT_IA_PD)
+			TAILQ_INIT(&sp->u.ifprefix_list);
+
+		TAILQ_INSERT_TAIL(&iac->iaprefix_head, sp, link);
+
+		spcreate = 1;
+	}
+
+	/* update the timestamp of update */
+	sp->updatetime = time(NULL);
+
+	/* update the prefix according to pinfo */
+	sp->pa.pltime = pinfo.pltime;
+	sp->pa.vltime = pinfo.vltime;
+	if (type == DHCPOPT_IA_NA)
+		sp->u.dhcpif = dhcpifp;
+
+	log2("%s a address %s/%d pltime=%u, vltime=%u",
+	    spcreate ? "create" : "update",
+	    p, pinfo.plen, pinfo.pltime, pinfo.vltime);
+
+	/* update prefix interfaces if necessary */
+	if (sp->pa.vltime != 0) {
+		if (type == DHCPOPT_IA_PD && spcreate) {
+			for (pif = TAILQ_FIRST(iac->pifc_head); pif;
+			    pif = TAILQ_NEXT(pif, link)) {
+			/*
+			 * The requesting router MUST NOT assign any delegated
+			 * prefixes or subnets from the delegated prefix(es) to
+			 * the link through which it received the DHCP message
+			 * from the delegating router.
+			 * [RFC3633 Section 12.1]
+			 */
+				if (strcmp(pif->ifname, dhcpifp->ifname) == 0) {
+					bb_info_msg("skip %s as a prefix interface",
+					    dhcpifp->ifname);
+					continue;
+				}
+
+				add_ifprefix(sp, &pinfo, pif);
+			}
+		}
+		else if (type == DHCPOPT_IA_NA) {
+			if (na_ifaddrconf(IFADDRCONF_ADD, sp) < 0)
+				return (-1);
+		}
+	}
+
+	/*
+	 * If the new vltime is 0, this prefix immediately expires.
+	 * Otherwise, set up or update the associated timer.
+	 */
+	switch (sp->pa.vltime) {
+	case 0:
+		remove_iaprefix(sp, type);
+		break;
+	case DHCP6_DURATION_INFINITE:
+		if (sp->timer)
+			dhcp6_timer_remove(&sp->timer);
+		break;
+	default:
+		if (sp->timer == NULL) {
+			sp->timer = dhcp6_timer_add(iapref_timo, sp);
+		}
+		/* update the timer */
+		dhcp6_timer_set(sp->pa.vltime * 1000ULL, sp->timer);
+		break;
+	}
+
+	return (0);
+}
+
+static struct iaprefix *find_iaprefix(struct iaprefix_list *head, struct dhcp6_prefix *addr,
+		int match_plen)
+{
+	struct iaprefix *sp;
+
+	for (sp = TAILQ_FIRST(head); sp; sp = TAILQ_NEXT(sp, link)) {
+		if (!IN6_ARE_ADDR_EQUAL(&sp->pa.addr, &addr->addr))
+			continue;
+		if (match_plen == 0 || sp->pa.plen == addr->plen)
+			return (sp);
+	}
+
+	return (NULL);
+}
+
+static int remove_iaprefix(struct iaprefix *sp, dh6cnfopts_t type)
+{
+	int ret = 0;
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a, (const uint8_t *)&sp->pa.addr);
+	log2("remove an address %s/%d", a, sp->pa.plen);
+#endif
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	if (type == DHCPOPT_IA_PD) {
+		struct dhcp6_ifprefix *ip;
+
+		/* remove all interface prefixes */
+		while ((ip = TAILQ_FIRST(&sp->u.ifprefix_list)) != NULL) {
+			TAILQ_REMOVE(&sp->u.ifprefix_list, ip, plink);
+			pd_ifaddrconf(IFADDRCONF_REMOVE, ip);
+			free(ip);
+		}
+	}
+	else {
+		ret = na_ifaddrconf(IFADDRCONF_REMOVE, sp);
+	}
+
+	TAILQ_REMOVE(&sp->ctl->iaprefix_head, sp, link);
+	free(sp);
+	return ret;
+}
+
+static ALWAYS_INLINE int pref_isvalid(struct iactl *iac)
+{
+	if (TAILQ_EMPTY(&iac->iaprefix_head))
+		return (0);	/* this IA is invalid */
+	return (1);
+}
+
+static uint32_t pref_duration(struct iactl *iac)
+{
+	struct iaprefix *sp;
+	uint32_t base = DHCP6_DURATION_INFINITE, pltime, passed;
+	time_t now;
+
+	/* Determine the smallest period until pltime expires. */
+	now = time(NULL);
+	for (sp = TAILQ_FIRST(&iac->iaprefix_head); sp;
+	    sp = TAILQ_NEXT(sp, link)) {
+		passed = now > sp->updatetime ?
+		    (uint32_t)(now - sp->updatetime) : 0;
+		pltime = sp->pa.pltime > passed ?
+		    sp->pa.pltime - passed : 0;
+
+		if (base == DHCP6_DURATION_INFINITE || pltime < base)
+			base = pltime;
+	}
+
+	return (base);
+}
+
+static void pref_cleanup(struct iactl *iac)
+{
+	struct iaprefix *sp;
+
+	while ((sp = TAILQ_FIRST(&iac->iaprefix_head)) != NULL) {
+		TAILQ_REMOVE(&iac->iaprefix_head, sp, link);
+		remove_iaprefix(sp, iac->type);
+	}
+
+	free(iac);
+}
+
+static int iapref_renew(struct iactl *iac, struct dhcp6_ia *iaparam,
+		struct dhcp6_eventdata *evd)
+{
+	struct iaprefix *sp;
+	struct dhcp6_list *ial = NULL, pl;
+
+	TAILQ_INIT(&pl);
+	for (sp = TAILQ_FIRST(&iac->iaprefix_head); sp;
+	    sp = TAILQ_NEXT(sp, link)) {
+		if (dhcp6_add_listval(&pl,
+		    (iac->type == DHCPOPT_IA_PD) ? DHCP6_LISTVAL_PREFIX6 : DHCP6_LISTVAL_STATEFULADDR6,
+		    &sp->pa, NULL) == NULL)
+			goto fail;
+	}
+
+	ial = xmalloc(sizeof(*ial));
+	TAILQ_INIT(ial);
+	if (dhcp6_add_listval(ial,
+		 (iac->type == DHCPOPT_IA_PD) ? DHCP6_LISTVAL_IAPD : DHCP6_LISTVAL_IANA,
+		 iaparam, &pl) == NULL)
+		goto fail;
+	dhcp6_clear_list(&pl);
+
+	evd->type = iac->type;
+	evd->data = ial;
+
+	return (0);
+
+  fail:
+	dhcp6_clear_list(&pl);
+	free(ial);
+	return (-1);
+}
+
+static struct dhcp6_timer *iapref_timo(void *arg)
+{
+	struct iaprefix *sp = (struct iaprefix *)arg;
+	struct ia *ia = sp->ctl->iactl_ia;
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a, (const uint8_t *)&sp->pa.addr);
+	log1("address timeout for %s/%d", a, sp->pa.plen);
+#endif
+
+	if (sp->timer)
+		dhcp6_timer_remove(&sp->timer);
+
+	remove_iaprefix(sp, sp->ctl->type);
+
+	/* see if this IA is still valid.  if not, remove it. */
+	if (ia->ctl == NULL || !pref_isvalid(ia->ctl)) {
+		log1("IA %s-%u is invalidated",
+		    iastr(ia->conf->type), ia->conf->iaid);
+		remove_ia(ia);
+	}
+
+	return (NULL);
+}
+
+static int add_ifprefix(struct iaprefix *iaprefix,
+		struct dhcp6_prefix *prefix, struct prefix_ifconf *pconf)
+{
+	struct dhcp6_ifprefix *ifpfx = NULL;
+	struct in6_addr *a;
+	u_long sla_id;
+	char *sp;
+	int b, i;
+
+	ifpfx = xzalloc(sizeof(*ifpfx));
+
+	ifpfx->ifconf = pconf;
+
+	ifpfx->paddr.sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	ifpfx->paddr.sin6_len = sizeof(struct sockaddr_in6);
+#endif
+	ifpfx->paddr.sin6_addr = prefix->addr;
+	ifpfx->plen = prefix->plen + pconf->sla_len;
+	/*
+	 * XXX: our current implementation assumes ifid len is a multiple of 8
+	 */
+	if ((pconf->ifid_len % 8) != 0) {
+		bb_error_msg("length of interface ID must be multiple of 8");
+		goto bad;
+	}
+	if (ifpfx->plen + pconf->ifid_len < 0 ||
+	    ifpfx->plen + pconf->ifid_len > 128) {
+		bb_info_msg("invalid prefix length: %d + %d + %d",
+			prefix->plen, pconf->sla_len, pconf->ifid_len);
+		goto bad;
+	}
+
+	/* copy prefix and SLA ID */
+	a = &ifpfx->paddr.sin6_addr;
+	b = prefix->plen;
+	for (i = 0, b = prefix->plen; b > 0; b -= 8, i++)
+		a->s6_addr[i] = prefix->addr.s6_addr[i];
+	sla_id = htonl(pconf->sla_id);
+	sp = ((char *)&sla_id + 3);
+	i = (128 - pconf->ifid_len) / 8;
+	for (b = pconf->sla_len; b > 7; b -= 8, sp--)
+		a->s6_addr[--i] = *sp;
+	if (b)
+		a->s6_addr[--i] |= *sp;
+
+	/* configure the corresponding address */
+	ifpfx->ifaddr = ifpfx->paddr;
+	for (i = 15; i >= pconf->ifid_len / 8; i--)
+		ifpfx->ifaddr.sin6_addr.s6_addr[i] = pconf->ifid[i];
+	if (pd_ifaddrconf(IFADDRCONF_ADD, ifpfx))
+		goto bad;
+
+	/* TODO: send a control message for other processes */
+
+	TAILQ_INSERT_TAIL(&iaprefix->u.ifprefix_list, ifpfx, plink);
+
+	return (0);
+
+  bad:
+	free(ifpfx);
+	return (-1);
+}
+
+static ALWAYS_INLINE int pd_ifaddrconf(ifaddrconf_cmd_t cmd, struct dhcp6_ifprefix *ifpfx)
+{
+	return (ifaddrconf(cmd, ifpfx->ifconf->ifname,
+	    &ifpfx->ifaddr, ifpfx->plen,
+	    DHCP6_DURATION_INFINITE, DHCP6_DURATION_INFINITE));
+}
+
+static int na_ifaddrconf(ifaddrconf_cmd_t cmd, struct iaprefix *sa)
+{
+	struct sockaddr_in6 sin6;
+
+	memset(&sin6, 0, sizeof(sin6));
+	sin6.sin6_family = AF_INET6;
+#ifdef HAVE_SA_LEN
+	sin6.sin6_len = sizeof(sin6);
+#endif
+	sin6.sin6_addr = sa->pa.addr;
+
+	return (ifaddrconf(cmd, sa->u.dhcpif->ifname, &sin6, 128,
+		sa->pa.pltime, sa->pa.vltime));
+}
diff -urNBp busybox.orig/networking/udhcp/dhcp6c_ia.h busybox/networking/udhcp/dhcp6c_ia.h
--- busybox.orig/networking/udhcp/dhcp6c_ia.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c_ia.h	2011-05-24 20:23:35.000000000 +0400
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+struct ia;			/* this is an opaque type */
+
+TAILQ_HEAD(iaprefix_list, iaprefix);
+
+struct iaprefix {
+	TAILQ_ENTRY(iaprefix) link;
+
+	struct dhcp6_prefix pa;
+	time_t updatetime;
+	struct dhcp6_timer *timer;
+	struct iactl *ctl;
+
+	union {
+		TAILQ_HEAD(, dhcp6_ifprefix) ifprefix_list; /* interface prefixes */
+		struct dhcp6_if *dhcpif;
+	} u;
+};
+
+struct dhcp6_ifprefix {
+	TAILQ_ENTRY(dhcp6_ifprefix) plink;
+
+	/* interface configuration */
+	struct prefix_ifconf *ifconf;
+
+	/* interface prefix parameters */
+	struct sockaddr_in6 paddr;
+	int plen;
+
+	/* address assigned on the interface based on the prefix */
+	struct sockaddr_in6 ifaddr;
+};
+
+struct iactl {
+	struct ia *iactl_ia;	/* back pointer to IA */
+
+	dh6cnfopts_t type;
+
+        struct pifc_list *pifc_head;
+        struct iaprefix_list iaprefix_head;
+};
+
+void update_ia(dh6cnfopts_t, struct dhcp6_list *,
+	struct dhcp6_if *, struct duid *, struct authparam *);
+void release_all_ia(struct dhcp6_if *);
diff -urNBp busybox.orig/networking/udhcp/dhcp6c_script.c busybox/networking/udhcp/dhcp6c_script.c
--- busybox.orig/networking/udhcp/dhcp6c_script.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6c_script.c	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2003 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+
+#include <netinet/in.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <errno.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+
+static int safefile(const char *);
+
+
+typedef struct {
+	const char *name;
+	int elem_type;               /* ==0 for strlen() */
+	size_t list_off;
+} envp_list_t;
+
+static const envp_list_t client6_envp_list[] = {
+    { "new_sip_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, sip_list)       },
+    { "new_sip_name",				    0, offsetof(struct dhcp6_optinfo, sipname_list)   },
+    { "new_domain_name_servers",  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, dns_list)       },
+    { "new_domain_name", 			    0, offsetof(struct dhcp6_optinfo, dnsname_list)   },
+    { "new_ntp_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, ntp_list)       },
+    { "new_nis_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, nis_list)       },
+    { "new_nis_name", 				    0, offsetof(struct dhcp6_optinfo, nisname_list)   },
+    { "new_nisp_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, nisp_list)      },
+    { "new_nisp_name",				    0, offsetof(struct dhcp6_optinfo, nispname_list)  },
+    { "new_bcmcs_servers",	  DHCP6_LISTVAL_ADDR6, offsetof(struct dhcp6_optinfo, bcmcs_list)     },
+    { "new_bcmcs_name",				    0, offsetof(struct dhcp6_optinfo, bcmcsname_list) },
+};
+
+char **fill_envp_client6(struct dhcp6_optinfo *optinfo, char *ifname)
+{
+	char reason[] = "REASON=NBI";
+	int i, sz, envc, elen;
+	char **envp, **curr;
+	struct dhcp6_listval *v;
+	int elens[ARRAY_SIZE(client6_envp_list)];
+
+	envc = 3;     /* we at least include the interface,reason and the terminator */
+
+	/* count the number of variables & total env. length */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++)
+	{
+	    sz = 0;
+	    v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + client6_envp_list[i].list_off));
+	    while (v)
+	    {
+		switch (client6_envp_list[i].elem_type) {
+		    case 0:
+			    sz += v->val_vbuf.dv_len + 1;
+			    break;
+		    case DHCP6_LISTVAL_ADDR6:
+			    sz += INET6_ADDRSTRLEN + 1 + 1;
+			    break;
+		}
+		v = TAILQ_NEXT(v, link);
+	    }
+	    elens[i] = sz;
+	    envc += (sz ? 1 : 0);
+	}
+
+	/* allocate an environments array */
+	curr = envp = xzalloc(sizeof(char *) * envc);
+
+	/*
+	 * Copy the parameters as environment variables
+	 */
+	/* reason */
+	*curr = xstrdup(reason);
+	putenv(*curr++);
+	/* interface name */
+	*curr = xasprintf("interface=%s", ifname);
+	putenv(*curr++);
+
+	/* "var=addr1 addr2 ... addrN" + null char for termination */
+	for (i=0; i < ARRAY_SIZE(client6_envp_list); i++) {
+	    if (elens[i] > 0) {
+		char a[INET6_ADDRSTRLEN];
+
+		elen = strlen(client6_envp_list[i].name) + 1 + elens[i];
+		*curr = xzalloc(elen);
+		snprintf(*curr, elen, "%s=", client6_envp_list[i].name);
+
+		for (v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + client6_envp_list[i].list_off)); v;
+		    v = TAILQ_NEXT(v, link)) {
+			/* since we count total length above, it is safely to use strcat() */
+			switch (client6_envp_list[i].elem_type) {
+			    case 0:
+				    strcat(*curr, v->val_vbuf.dv_buf);
+				    strcat(*curr, " ");
+				    break;
+			    case DHCP6_LISTVAL_ADDR6:
+				    sprint_nip6(a, (const uint8_t *)&v->val_addr6);
+				    strcat(*curr, a);
+				    strcat(*curr, " ");
+				    break;
+			}
+		}
+		putenv(*curr++);
+	    }
+	}
+
+	return envp;
+}
+
+#if ENABLE_DHCP6RELAY
+static const envp_list_t relay6_envp_list[] = {
+    { "iapd_%d=",        DHCP6_LISTVAL_PREFIX6, offsetof(struct dhcp6_optinfo, iapd_list) },
+    { "iana_%d=",  DHCP6_LISTVAL_STATEFULADDR6, offsetof(struct dhcp6_optinfo, iana_list) },
+};
+
+static char *ia2str(int, struct dhcp6_listval *, const char *);
+
+char **fill_envp_relay6(struct dhcp6_optinfo *optinfo, char *clientaddr)
+{
+	int i, j, envc;
+	char **envp, **curr;
+	struct dhcp6_listval *v;
+
+	envc = 2;     /* we at least include the address and the terminator */
+
+	/* count the number of variables */
+	for (i=0; i < ARRAY_SIZE(relay6_envp_list); i++) {
+		v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + relay6_envp_list[i].list_off));
+		while (v) {
+			envc++;
+			v = TAILQ_NEXT(v, link);
+		}
+	}
+
+	/* allocate an environments array */
+	curr = envp = xzalloc(sizeof(char *) * envc);
+
+	/*
+	 * Copy the parameters as environment variables
+	 */
+	/* address */
+	*curr = xasprintf("client=%s", clientaddr);
+	putenv(*curr++);
+	/* IAs */
+	for (i=0; i < ARRAY_SIZE(relay6_envp_list); i++) {
+		j = 0;
+		v = TAILQ_FIRST((struct dhcp6_list *)(((void *)optinfo) + relay6_envp_list[i].list_off));
+		while (v) {
+
+			if ((*curr = ia2str(j++, v, relay6_envp_list[i].name)) == NULL)
+				return NULL;
+
+			putenv(*curr++);
+			v = TAILQ_NEXT(v, link);
+		}
+	}
+
+	return envp;
+}
+
+
+static char *ia2str(int num, struct dhcp6_listval *iav, const char *fmt)
+{
+	struct dhcp6_listval *siav;
+	char *s;
+	const char *comma;
+	int len;
+	char a[INET6_ADDRSTRLEN];
+
+#define IASTR_MAXSIZE	((16/*name*/ + (INET6_ADDRSTRLEN + 1)/*addr6*/ + 4/*prefix*/ + 1) * 32)
+	if ((s = malloc_or_warn(IASTR_MAXSIZE)) == NULL)
+		return NULL;
+	memset(s, 0, IASTR_MAXSIZE);
+	len = 0;
+
+	len += snprintf(s, IASTR_MAXSIZE, fmt, num);
+	comma = "";
+
+	for (siav = TAILQ_FIRST(&iav->sublist); siav;
+	    siav = TAILQ_NEXT(siav, link)) {
+		if (len >= IASTR_MAXSIZE)
+			goto out;
+		switch (siav->type) {
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			sprint_nip6(a, (const uint8_t *)&siav->val_statefuladdr6.addr);
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s%s", comma, a);
+			break;
+
+		case DHCP6_LISTVAL_PREFIX6:
+			sprint_nip6(a, (const uint8_t *)&siav->val_prefix6.addr);
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s%s/%d", comma, a, siav->val_prefix6.plen);
+			break;
+
+		case DHCP6_LISTVAL_STCODE:
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s#%d", comma, siav->val_num16);
+			break;
+
+		default:
+			bb_error_msg("impossible subopt");
+		}
+		comma = ",";
+	}
+ out:
+	return s;
+}
+#endif /* ENABLE_DHCP6RELAY */
+
+static int safefile(const char *path)
+{
+	struct stat s;
+	uid_t myuid = getuid();
+
+	/* no setuid */
+	if (myuid != geteuid()) {
+		bb_info_msg("setuid'ed execution not allowed");
+		return (-1);
+	}
+
+	if (access(path, X_OK) || lstat(path, &s))
+		return (-1);
+
+	if (!S_ISREG(s.st_mode) && !S_ISLNK(s.st_mode)) {
+		return (-1);
+	}
+
+	/* the file must be owned by the running uid */
+	if (s.st_uid != myuid) {
+		bb_info_msg("script has invalid owner uid");
+		return (-1);
+	}
+
+	return (0);
+}
+
+int dhcp6_script(const char *scriptpath, char **envp)
+{
+	char *argv[2];
+
+        /* if a script is not specified, do nothing */
+        if (strlen(scriptpath) == 0)
+                return -2;
+
+	if (safefile(scriptpath)) {
+		bb_error_msg("script \"%s\" cannot be executed safely",
+			    scriptpath);
+		return -2;
+	}
+	/* launch the script */
+	argv[0] = (char *)scriptpath;
+	argv[1] = NULL;
+	spawn_and_wait(argv);
+
+	/* free env */
+	if (envp != NULL) {
+		char **curr;
+
+		for (curr = envp; *curr; curr++) {
+			bb_unsetenv_and_free(*curr);
+		}
+		free(envp);
+	}
+	return 0;
+}
diff -urNBp busybox.orig/networking/udhcp/dhcp6.h busybox/networking/udhcp/dhcp6.h
--- busybox.orig/networking/udhcp/dhcp6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6.h	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 1998 and 1999 WIDE Project.
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __DHCP6_H_DEFINED
+#define __DHCP6_H_DEFINED
+
+#ifdef __sun__
+#ifndef CMSG_SPACE
+#define	CMSG_SPACE(l) \
+	((unsigned int)_CMSG_HDR_ALIGN(sizeof(struct cmsghdr) + (l)))
+#endif
+#ifndef CMSG_LEN
+#define	CMSG_LEN(l) \
+	((unsigned int)_CMSG_DATA_ALIGN(sizeof(struct cmsghdr)) + (l))
+#endif
+#endif
+
+/* Error Values */
+#define DH6ERR_FAILURE		16
+#define DH6ERR_AUTHFAIL		17
+#define DH6ERR_POORLYFORMED	18
+#define DH6ERR_UNAVAIL		19
+#define DH6ERR_OPTUNAVAIL	20
+
+/* Message type */
+#define DH6_SOLICIT	1
+#define DH6_ADVERTISE	2
+#define DH6_REQUEST	3
+#define DH6_CONFIRM	4
+#define DH6_RENEW	5
+#define DH6_REBIND	6
+#define DH6_REPLY	7
+#define DH6_RELEASE	8
+#define DH6_DECLINE	9
+#define DH6_RECONFIGURE	10
+#define DH6_INFORM_REQ	11
+#define DH6_RELAY_FORW	12
+#define DH6_RELAY_REPLY	13
+
+/* Predefined addresses */
+#define DH6ADDR_ALLAGENT	"ff02::1:2"
+#define DH6ADDR_ALLSERVER	"ff05::1:3"
+#define DH6PORT_DOWNSTREAM	"546"
+#define DH6PORT_UPSTREAM	"547"
+
+/* Protocol constants */
+
+/* timer parameters (msec, unless explicitly commented) */
+#define SOL_MAX_DELAY	1000
+#define SOL_TIMEOUT	1000
+#define SOL_MAX_RT	120000
+#define INF_TIMEOUT	1000
+#define INF_MAX_RT	120000
+#define REQ_TIMEOUT	1000
+#define REQ_MAX_RT	30000
+#define REQ_MAX_RC	10	/* Max Request retry attempts */
+#define REN_TIMEOUT	10000	/* 10secs */
+#define REN_MAX_RT	600000	/* 600secs */
+#define REB_TIMEOUT	10000	/* 10secs */
+#define REB_MAX_RT	600000	/* 600secs */
+#define REL_TIMEOUT	1000	/* 1 sec */
+#define REL_MAX_RC	5
+
+#define DHCP6_DURATION_INFINITE 0xffffffff
+#define DHCP6_DURATION_MIN 30
+
+#define DHCP6_RELAY_MULTICAST_HOPS 32
+#define DHCP6_RELAY_HOP_COUNT_LIMIT 32
+
+#define DHCP6_IRT_DEFAULT 86400	/* 1 day */
+#define DHCP6_IRT_MINIMUM 600
+
+/* DUID: DHCP unique Identifier */
+struct duid {
+	size_t duid_len;	/* length */
+	char *duid_id;		/* variable length ID value (must be opaque) */
+};
+
+struct dhcp6_vbuf {		/* generic variable length buffer */
+	int dv_len;
+	caddr_t dv_buf;
+};
+
+/* option information */
+struct dhcp6_ia {		/* identity association */
+	uint32_t iaid;
+	uint32_t t1;
+	uint32_t t2;
+};
+
+struct dhcp6_prefix {		/* IA_PD */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+	int plen;
+};
+
+struct dhcp6_statefuladdr {	/* IA_NA */
+	uint32_t pltime;
+	uint32_t vltime;
+	struct in6_addr addr;
+};
+
+/* Internal data structure */
+typedef enum { DHCP6_LISTVAL_NUM = 1,
+	       DHCP6_LISTVAL_STCODE, DHCP6_LISTVAL_ADDR6,
+	       DHCP6_LISTVAL_IAPD, DHCP6_LISTVAL_PREFIX6,
+	       DHCP6_LISTVAL_IANA, DHCP6_LISTVAL_STATEFULADDR6,
+	       DHCP6_LISTVAL_VBUF
+} dhcp6_listval_type_t;
+TAILQ_HEAD(dhcp6_list, dhcp6_listval);
+struct dhcp6_listval {
+	TAILQ_ENTRY(dhcp6_listval) link;
+
+	dhcp6_listval_type_t type;
+
+	union {
+		int uv_num;
+		uint16_t uv_num16;
+		struct in6_addr uv_addr6;
+		struct dhcp6_prefix uv_prefix6;
+		struct dhcp6_statefuladdr uv_statefuladdr6;
+		struct dhcp6_ia uv_ia;
+		struct dhcp6_vbuf uv_vbuf;
+	} uv;
+
+	struct dhcp6_list sublist;
+};
+#define val_num uv.uv_num
+#define val_num16 uv.uv_num16
+#define val_addr6 uv.uv_addr6
+#define val_ia uv.uv_ia
+#define val_prefix6 uv.uv_prefix6
+#define val_statefuladdr6 uv.uv_statefuladdr6
+#define val_vbuf uv.uv_vbuf
+
+struct dhcp6_optinfo {
+	struct duid clientID;	/* DUID */
+	struct duid serverID;	/* DUID */
+
+	int rapidcommit;	/* bool */
+	int pref;		/* server preference */
+	int32_t elapsed_time;	/* elapsed time (from client to server only) */
+	int64_t refreshtime;	/* info refresh time for stateless options */
+
+	struct dhcp6_list iapd_list; /* list of IA_PD */
+	struct dhcp6_list iana_list; /* list of IA_NA */
+	struct dhcp6_list reqopt_list; /* options in option request */
+	struct dhcp6_list stcode_list; /* status code */
+	struct dhcp6_list sip_list; /* SIP server list */
+	struct dhcp6_list sipname_list; /* SIP domain list */
+	struct dhcp6_list dns_list; /* DNS server list */
+	struct dhcp6_list dnsname_list; /* Domain Search list */
+	struct dhcp6_list ntp_list; /* NTP server list */
+	struct dhcp6_list prefix_list; /* prefix list */
+	struct dhcp6_list nis_list; /* NIS server list */
+	struct dhcp6_list nisname_list; /* NIS domain list */
+	struct dhcp6_list nisp_list; /* NIS+ server list */
+	struct dhcp6_list nispname_list; /* NIS+ domain list */
+	struct dhcp6_list bcmcs_list; /* BCMC server list */
+	struct dhcp6_list bcmcsname_list; /* BCMC domain list */
+
+	struct dhcp6_vbuf relay_msg; /* relay message */
+#define relaymsg_len relay_msg.dv_len
+#define relaymsg_msg relay_msg.dv_buf
+
+	struct dhcp6_vbuf ifidopt; /* Interface-id */
+#define ifidopt_len ifidopt.dv_len
+#define ifidopt_id ifidopt.dv_buf
+
+	uint16_t authflags;
+#define DHCP6OPT_AUTHFLAG_NOINFO	0x1
+	int authproto;
+	int authalgorithm;
+	int authrdm;
+	/* the followings are effective only when NOINFO is unset */
+	uint64_t authrd;
+	union {
+		struct {
+			uint32_t keyid;
+			struct dhcp6_vbuf realm;
+			int offset; /* offset to the HMAC field */
+		} aiu_delayed;
+		struct {
+			int type;
+			int offset; /* offset to the HMAC field */
+			char val[16]; /* key value */
+		} aiu_reconfig;
+	} authinfo;
+#define delayedauth_keyid authinfo.aiu_delayed.keyid
+#define delayedauth_realmlen authinfo.aiu_delayed.realm.dv_len
+#define delayedauth_realmval authinfo.aiu_delayed.realm.dv_buf
+#define delayedauth_offset authinfo.aiu_delayed.offset
+#define reconfigauth_type authinfo.aiu_reconfig.type
+#define reconfigauth_offset authinfo.aiu_reconfig.offset
+#define reconfigauth_val authinfo.aiu_reconfig.val
+};
+
+/* DHCP6 base packet format */
+struct dhcp6 {
+	union {
+		uint8_t m;
+		uint32_t x;
+	} dh6_msgtypexid;
+	/* options follow */
+} __attribute__ ((__packed__));
+#define dh6_msgtype	dh6_msgtypexid.m
+#define dh6_xid		dh6_msgtypexid.x
+#define DH6_XIDMASK	0x00ffffff
+
+/* DHCPv6 relay messages */
+struct dhcp6_relay {
+	uint8_t dh6relay_msgtype;
+	uint8_t dh6relay_hcnt;
+	struct in6_addr dh6relay_linkaddr; /* XXX: badly aligned */
+	struct in6_addr dh6relay_peeraddr; /* ditto */
+	/* options follow */
+} __attribute__ ((__packed__));
+
+/* options */
+#define DH6OPT_CLIENTID	1
+#define DH6OPT_SERVERID	2
+#define DH6OPT_IA_NA 3
+#define DH6OPT_IA_TA 4
+#define DH6OPT_IAADDR 5
+#define DH6OPT_ORO 6
+#define DH6OPT_PREFERENCE 7
+#  define DH6OPT_PREF_UNDEF -1
+#  define DH6OPT_PREF_MAX 255
+#define DH6OPT_ELAPSED_TIME 8
+#  define DH6OPT_ELAPSED_TIME_UNDEF -1
+#define DH6OPT_RELAY_MSG 9
+/* #define DH6OPT_SERVER_MSG 10: deprecated */
+#define DH6OPT_AUTH 11
+#  define DH6OPT_AUTH_PROTO_DELAYED 2
+#  define DH6OPT_AUTH_RRECONFIGURE 3
+#  define DH6OPT_AUTH_ALG_HMACMD5 1
+#define DH6OPT_UNICAST 12
+#define DH6OPT_STATUS_CODE 13
+#  define DH6OPT_STCODE_SUCCESS 0
+#  define DH6OPT_STCODE_UNSPECFAIL 1
+#  define DH6OPT_STCODE_NOADDRSAVAIL 2
+#  define DH6OPT_STCODE_NOBINDING 3
+#  define DH6OPT_STCODE_NOTONLINK 4
+#  define DH6OPT_STCODE_USEMULTICAST 5
+#  define DH6OPT_STCODE_NOPREFIXAVAIL 6
+
+#define DH6OPT_RAPID_COMMIT 14
+#define DH6OPT_USER_CLASS 15
+#define DH6OPT_VENDOR_CLASS 16
+#define DH6OPT_VENDOR_OPTS 17
+#define DH6OPT_INTERFACE_ID 18
+#define DH6OPT_RECONF_MSG 19
+
+#define DH6OPT_SIP_SERVER_D 21
+#define DH6OPT_SIP_SERVER_A 22
+#define DH6OPT_DNS 23
+#define DH6OPT_DNSNAME 24
+#define DH6OPT_IA_PD 25
+#define DH6OPT_IA_PD_PREFIX 26
+#define DH6OPT_NIS_SERVERS 27
+#define DH6OPT_NISP_SERVERS 28
+#define DH6OPT_NIS_DOMAIN_NAME 29
+#define DH6OPT_NISP_DOMAIN_NAME 30
+#define DH6OPT_NTP 31
+#define DH6OPT_REFRESHTIME 32
+ #define DH6OPT_REFRESHTIME_UNDEF -1
+#define DH6OPT_BCMCS_SERVER_D 33
+#define DH6OPT_BCMCS_SERVER_A 34
+#define DH6OPT_GEOCONF_CIVIC 36
+#define DH6OPT_REMOTE_ID 37
+#define DH6OPT_SUBSCRIBER_ID 38
+#define DH6OPT_CLIENT_FQDN 39
+
+/* The followings are KAME specific. */
+
+struct dhcp6opt {
+	uint16_t dh6opt_type;
+	uint16_t dh6opt_len;
+	/* type-dependent data follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 1 (DUID-LLT) */
+struct dhcp6opt_duid_type1 {
+	uint16_t dh6_duid1_type;
+	uint16_t dh6_duid1_hwtype;
+	uint32_t dh6_duid1_time;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 2 (DUID-EN) */
+struct dhcp6opt_duid_type2 {
+	uint16_t dh6_duid2_type;
+	uint32_t dh6_duid2_enterprise_number;
+	/* identifier follows */
+} __attribute__ ((__packed__));
+
+/* DUID type 3 (DUID-LL) */
+struct dhcp6opt_duid_type3 {
+	uint16_t dh6_duid3_type;
+	uint16_t dh6_duid3_hwtype;
+	/* link-layer address follows */
+} __attribute__ ((__packed__));
+
+union dhcp6opt_duid_type {
+	struct dhcp6opt_duid_type1	d1;
+	struct dhcp6opt_duid_type2	d2;
+	struct dhcp6opt_duid_type3	d3;
+};
+
+/* Status Code */
+struct dhcp6opt_stcode {
+	uint16_t dh6_stcode_type;
+	uint16_t dh6_stcode_len;
+	uint16_t dh6_stcode_code;
+} __attribute__ ((__packed__));
+
+/*
+ * General format of Identity Association.
+ * This format applies to Prefix Delegation (IA_PD) and Non-temporary Addresses
+ * (IA_NA)
+ */
+struct dhcp6opt_ia {
+	uint16_t dh6_ia_type;
+	uint16_t dh6_ia_len;
+	uint32_t dh6_ia_iaid;
+	uint32_t dh6_ia_t1;
+	uint32_t dh6_ia_t2;
+	/* sub options follow */
+} __attribute__ ((__packed__));
+
+/* IA Addr */
+struct dhcp6opt_ia_addr {
+	uint16_t dh6_ia_addr_type;
+	uint16_t dh6_ia_addr_len;
+	struct in6_addr dh6_ia_addr_addr;
+	uint32_t dh6_ia_addr_preferred_time;
+	uint32_t dh6_ia_addr_valid_time;
+} __attribute__ ((__packed__));
+
+/* IA_PD Prefix */
+struct dhcp6opt_ia_pd_prefix {
+	uint16_t dh6_iapd_prefix_type;
+	uint16_t dh6_iapd_prefix_len;
+	uint32_t dh6_iapd_prefix_preferred_time;
+	uint32_t dh6_iapd_prefix_valid_time;
+	uint8_t dh6_iapd_prefix_prefix_len;
+	struct in6_addr dh6_iapd_prefix_prefix_addr;
+} __attribute__ ((__packed__));
+
+/* Authentication */
+struct dhcp6opt_auth {
+	uint16_t dh6_auth_type;
+	uint16_t dh6_auth_len;
+	uint8_t dh6_auth_proto;
+	uint8_t dh6_auth_alg;
+	uint8_t dh6_auth_rdm;
+	uint8_t dh6_auth_rdinfo[8];
+	/* authentication information follows */
+} __attribute__ ((__packed__));
+
+enum { DHCP6_AUTHPROTO_UNDEF = -1, DHCP6_AUTHPROTO_DELAYED = 2,
+       DHCP6_AUTHPROTO_RECONFIG = 3 };
+enum { DHCP6_AUTHALG_UNDEF = -1, DHCP6_AUTHALG_HMACMD5 = 1 };
+enum { DHCP6_AUTHRDM_UNDEF = -1, DHCP6_AUTHRDM_MONOCOUNTER = 0 };
+
+#endif /*__DHCP6_H_DEFINED*/
diff -urNBp busybox.orig/networking/udhcp/dhcp6relay.c busybox/networking/udhcp/dhcp6relay.c
--- busybox.orig/networking/udhcp/dhcp6relay.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/dhcp6relay.c	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,867 @@
+/*
+ * DHCPv6 relay
+ *
+ * Copyright (C) 2000 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Original code taken from wide-dhcpv6-20080615 and converted into
+ * a busybox applet by Leonid Lisovskiy <lly@sf.net>
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <sys/uio.h>
+#include <sys/signal.h>
+
+#include <net/if.h>
+#ifdef __FreeBSD__
+#include <net/if_var.h>
+#endif
+
+#include <netinet/in.h>
+
+#include <netdb.h>
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <syslog.h>
+#include <unistd.h>
+#include <stdlib.h>		/* XXX: freebsd2 needs this for opt{arg,ind} */
+#include <errno.h>
+#include <err.h>
+#include <string.h>
+
+/* Override ENABLE_FEATURE_PIDFILE */
+#define WANT_PIDFILE 1
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+
+#define DHCP6RELAY_PIDFILE "/var/run/dhcp6relay.pid"
+
+
+struct ifid_list {
+	TAILQ_ENTRY(ifid_list) ilink;
+	unsigned int ifid;
+};
+
+struct prefix_t {
+	struct in6_addr addr;
+	int plen;
+};
+
+/* list of non-link-local prefixes */
+static const struct prefix_t global_prefixes[] = {
+/*{ {{{0xfe,0xc0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 10 },    "fec0::/10" site-local unicast addresses were deprecated */
+  { {{{0x20,0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 3  }, /* "2000::/3" */
+  { {{{0xfc,0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 7  }, /* "FC00::/7"  Unique Local Address (RFC4193) */
+};
+
+struct globals {
+	struct sockaddr_in6 sa6_server, sa6_client;
+
+	struct msghdr rmh;
+	struct iovec rmhiov[2];
+	int mhops;
+
+	const char *relaydevice;
+	const char *boundaddr;
+	const char *serveraddr;
+	const char *scriptpath;
+	const char *pid_file;
+
+	TAILQ_HEAD(, ifid_list) ifids_list;
+	int relayifid;
+
+	int ssock;		/* socket for relaying to servers */
+	int csock;		/* socket for clients */
+
+	char rmsgctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+	u_char relaybuf[sizeof(struct dhcp6_relay) + BUFSIZ];
+	char   rdatabuf[BUFSIZ];
+};
+
+#define G (*ptr_to_globals)
+#define sa6_server	(G.sa6_server  )
+#define sa6_client	(G.sa6_client  )
+#define rmh		(G.rmh         )
+#define mhops		(G.mhops       )
+#define relayifid	(G.relayifid   )
+#define rmhiov		(G.rmhiov      )
+#define ssock		(G.ssock       )
+#define csock		(G.csock       )
+#define INIT_G() do { \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	mhops = DHCP6_RELAY_MULTICAST_HOPS; \
+	G.serveraddr = DH6ADDR_ALLSERVER; \
+	G.boundaddr = "::"; \
+	G.pid_file = DHCP6RELAY_PIDFILE; \
+	G.scriptpath = NULL; \
+	G.relaydevice = NULL; \
+} while (0)
+
+
+static void relay6_init(int, char *[]);
+static void relay6_loop(void);
+static void relay6_recv(int, int);
+static int make_msgcontrol(struct msghdr *, void *, socklen_t,
+    struct in6_pktinfo *, int);
+static void relay_to_server(struct dhcp6 *, ssize_t,
+    struct sockaddr_in6 *, char *, unsigned int);
+static void relay_to_client(struct dhcp6_relay *, ssize_t,
+    struct sockaddr *);
+static int getifidfromaddr(struct in6_addr *, unsigned int *);
+
+
+//usage:#define dhcp6relay_trivial_usage
+//usage:       "[-vf] [-b boundaddr] [-H hoplim]\n"
+//usage:       "	[-r relay-IF] [-s serveraddr] [-p pidfile] [-S script] interface"
+//usage:#define dhcp6relay_full_usage "\n"
+//usage:      "\n	-v		Print debugging messages (may be repeated)"
+//usage:      "\n	-f		Foreground mode"
+//usage:      "\n	-b boundaddr	Source address to relay packets to servers"
+//usage:      "\n	-H hoplim	Hop limit of DHCPv6 Solicit messages forwarded to servers"
+//usage:      "\n	-r relay-IF	Interface on which messages to servers are sent"
+//usage:      "\n	-s serveraddr	DHCPv6 server address to relay packets to."
+//usage:      "\n			If not specified, packets are relayed to ff05::1:3"
+//usage:      "\n	-S script	Script file to be executed when relay receives"
+//usage:      "\n			a RELAY-REPLY message from a DHCPv6 server"
+//usage:      "\n	-p pidfile	Use pid-file to dump the process ID"
+
+enum {
+	OPT_FOREGROUND = 1 << 0,
+	OPT_b = 1 << 1,
+	OPT_H = 1 << 2,
+	OPT_r = 1 << 3,
+	OPT_s = 1 << 4,
+	OPT_S = 1 << 5,
+	OPT_p = 1 << 6,
+	OPT_VERBOSE = 1 << 7,
+};
+
+int dhcp6relay_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dhcp6relay_main(int argc, char **argv)
+{
+	const char *str_H;
+	int opt;
+
+	INIT_G();
+
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	opt_complementary = ":vv";
+#endif
+	opt = getopt32(argv, "fb:H:r:s:S:p:v",
+			&G.boundaddr, &str_H, &G.relaydevice, &G.serveraddr,
+			&G.scriptpath, &G.pid_file
+			IF_UDHCP_VERBOSE(, &dhcp_verbose)
+			);
+	if (opt & OPT_H) {
+		char *p = NULL;
+
+		mhops = (int)strtoul(str_H, &p, 10);
+		if (!*str_H || *p) {
+			bb_error_msg_and_die("illegal hop limit: %s", str_H);
+			/* NOTREACHED */
+		}
+		if (mhops <= 0 || mhops > 255) {
+			bb_error_msg_and_die("illegal hop limit: %d", mhops);
+			/* NOTREACHED */
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+	if (G.relaydevice == NULL) {
+		if (argc > 1) {
+			bb_error_msg("you should explicitly specify a "
+			    "relaying interface, when you are to "
+			    "listen on multiple interfaces\n");
+		}
+		if (argc != 1) {
+			bb_show_usage();
+			return(1);
+		}
+		G.relaydevice = argv[0];
+	}
+
+	if (!(option_mask32 & OPT_FOREGROUND)) {
+		bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
+		openlog(applet_name, LOG_PID, LOG_DAEMON);
+		logmode = LOGMODE_SYSLOG;
+	}
+
+	/* dump current PID */
+	write_pidfile(G.pid_file);
+
+	relay6_init(argc, argv);
+
+	bb_info_msg("%s started", applet_name);
+	relay6_loop();
+	remove_pidfile(G.pid_file);
+
+	return (0);
+}
+
+static void relay6_init(int ifnum, char *iflist[])
+{
+	struct addrinfo hints;
+	struct addrinfo *res, *res2;
+	int error;
+	struct ipv6_mreq mreq6;
+
+	/* initialize special socket addresses */
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(G.serveraddr, DH6PORT_UPSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	if (res->ai_family != PF_INET6 ||
+	    res->ai_addrlen < sizeof(sa6_server)) {
+		/* this should be impossible, but check for safety */
+		bb_perror_msg_and_die("getaddrinfo returned a bogus address");
+	}
+	/* XXX: assume only one DHCPv6 server address */
+	memcpy(&sa6_server, res->ai_addr, sizeof(sa6_server));
+	freeaddrinfo(res);
+
+	/* initialize send/receive buffer */
+	rmhiov[0].iov_base = (caddr_t)G.rdatabuf;
+	rmhiov[0].iov_len = sizeof(G.rdatabuf);
+	rmh.msg_iov = rmhiov;
+	rmh.msg_iovlen = 1;
+
+	/*
+	 * Setup a socket to communicate with clients.
+	 */
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_INET6;
+	hints.ai_socktype = SOCK_DGRAM;
+	hints.ai_protocol = IPPROTO_UDP;
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(NULL, DH6PORT_UPSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	csock = sock6_init(res);
+
+	hints.ai_flags = 0;
+	error = getaddrinfo(DH6ADDR_ALLAGENT, 0, &hints, &res2);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	memset(&mreq6, 0, sizeof(mreq6));
+	memcpy(&mreq6.ipv6mr_multiaddr,
+	    &((struct sockaddr_in6 *)res2->ai_addr)->sin6_addr,
+	    sizeof(mreq6.ipv6mr_multiaddr));
+
+	TAILQ_INIT(&G.ifids_list);
+	while (ifnum-- > 0) {
+		char *ifp = iflist[0];
+		struct ifid_list *ifd;
+
+		ifd = (struct ifid_list *)xzalloc(sizeof(*ifd));
+		ifd->ifid = if_nametoindex(ifp);
+		if (ifd->ifid == 0) {
+			bb_error_msg_and_die("invalid interface %s", ifp);
+		}
+		mreq6.ipv6mr_interface = ifd->ifid;
+
+		if (setsockopt(csock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
+		    &mreq6, sizeof(mreq6))) {
+			bb_error_msg_and_die("setsockopt(IPV6_JOIN_GROUP)");
+		}
+		TAILQ_INSERT_TAIL(&G.ifids_list, ifd, ilink);
+		iflist++;
+	}
+	freeaddrinfo(res2);
+
+	/*
+	 * Setup a socket to relay to servers.
+	 */
+	relayifid = if_nametoindex(G.relaydevice);
+	if (relayifid == 0)
+		bb_error_msg("invalid interface %s", G.relaydevice);
+	/*
+	 * We are not really sure if we need to listen on the downstream
+	 * port to receive packets from servers.  We'll need to clarify the
+	 * specification, but we do for now.
+	 */
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(G.boundaddr, DH6PORT_DOWNSTREAM, &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	memcpy(&sa6_client, res->ai_addr, sizeof(sa6_client));
+	ssock = sock6_init(res);
+
+	bb_signals(0 + (1 << SIGTERM), record_signo);
+}
+
+static void relay6_loop(void)
+{
+	fd_set readfds;
+	int e, maxsock;
+
+	while (!bb_got_signal) {
+
+		/* we'd rather use FD_COPY here, but it's not POSIX friendly */
+		FD_ZERO(&readfds);
+		FD_SET(csock, &readfds);
+		FD_SET(ssock, &readfds);
+
+		maxsock = MAX(csock, ssock);
+		e = select(maxsock + 1, &readfds, NULL, NULL, NULL);
+		switch (e) {
+		case 0:		/* impossible in our situation */
+		case -1:
+			if (errno != EINTR) {
+				bb_error_msg_and_die("select");
+				/* NOTREACHED */
+			}
+			continue;
+		default:
+			break;
+		}
+
+		if (FD_ISSET(csock, &readfds))
+			relay6_recv(csock, 1);
+
+		if (FD_ISSET(ssock, &readfds))
+			relay6_recv(ssock, 0);
+	}
+}
+
+static void relay6_recv(int s, int fromclient)
+{
+	ssize_t len;
+	struct sockaddr_storage from;
+	struct in6_pktinfo *pi = NULL;
+	struct cmsghdr *cm;
+	struct dhcp6 *dh6;
+	struct ifid_list *ifd;
+	char ifname[IF_NAMESIZE];
+
+	rmh.msg_control = (caddr_t)G.rmsgctlbuf;
+	rmh.msg_controllen = sizeof(G.rmsgctlbuf);
+
+	rmh.msg_name = &from;
+	rmh.msg_namelen = sizeof(from);
+
+	if ((len = recvmsg(s, &rmh, 0)) < 0) {
+		bb_perror_msg("recvmsg");
+		return;
+	}
+
+	log1("from %s, size %d",
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from), (int )len);
+
+	if (((struct sockaddr *)&from)->sa_family != AF_INET6) {
+		bb_info_msg("non-IPv6 packet is received (AF %d) ",
+		    ((struct sockaddr *)&from)->sa_family);
+		return;
+	}
+
+	/* get optional information as ancillary data (if available) */
+	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&rmh); cm;
+	     cm = (struct cmsghdr *)CMSG_NXTHDR(&rmh, cm)) {
+		if (cm->cmsg_level != IPPROTO_IPV6)
+			continue;
+
+		switch (cm->cmsg_type) {
+		case IPV6_PKTINFO:
+			pi = (struct in6_pktinfo *)CMSG_DATA(cm);
+			break;
+		}
+	}
+	if (pi == NULL) {
+		bb_info_msg("failed to get the arrival interface");
+		return;
+	}
+	for (ifd = TAILQ_FIRST(&G.ifids_list); ifd;
+	     ifd = TAILQ_NEXT(ifd, ilink)) {
+		if (pi->ipi6_ifindex == ifd->ifid)
+			break;
+	}
+	/*
+	 * DHCPv6 relay may receive a DHCPv6 packet from a non-listening 
+	 * interface, when a DHCPv6 server is running on that interface.
+	 * This check prevents such reception.
+	 */
+	if (ifd == NULL && pi->ipi6_ifindex != relayifid)
+		return;
+	if (if_indextoname(pi->ipi6_ifindex, ifname) == NULL) {
+		bb_info_msg("if_indextoname(id = %d): %s",
+		    pi->ipi6_ifindex, strerror(errno));
+		return;
+	}
+
+	/* packet validation */
+	if (len < sizeof(*dh6)) {
+		bb_info_msg("short packet (%d bytes)", (int )len);
+		return;
+	}
+
+	dh6 = (struct dhcp6 *)G.rdatabuf;
+	log1("received %s from %s",
+	    dhcp6msgstr(dh6->dh6_msgtype), xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from));
+
+	/*
+	 * Relay the packet according to the type.  A client message or
+	 * a relay forward message is forwarded to servers (or other relays),
+	 * and a relay reply message is forwarded to the intended client.
+	 */
+	if (fromclient) {
+		switch (dh6->dh6_msgtype) {
+		case DH6_SOLICIT:
+		case DH6_REQUEST:
+		case DH6_CONFIRM:
+		case DH6_RENEW:
+		case DH6_REBIND:
+		case DH6_RELEASE:
+		case DH6_DECLINE:
+		case DH6_INFORM_REQ:
+		case DH6_RELAY_FORW:
+			relay_to_server(dh6, len, (struct sockaddr_in6 *)&from,
+			    ifname, htonl(pi->ipi6_ifindex));
+			break;
+		case DH6_RELAY_REPLY:
+			/*
+			 * The server may send a relay reply to the client
+			 * port.
+			 * XXX: need to clarify the port issue
+			 */
+			relay_to_client((struct dhcp6_relay *)dh6, len,
+			    (struct sockaddr *)&from);
+			break;
+		default:
+			{
+			char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+			bb_info_msg("unexpected message (%s) on the client side "
+			    "from %s", dhcp6msgstr(dh6->dh6_msgtype), a);
+			free(a);
+			break;
+			}
+		}
+	} else {
+		if (dh6->dh6_msgtype != DH6_RELAY_REPLY) {
+			char *a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+			bb_info_msg("unexpected message (%s) on the server side"
+			    "from %s", dhcp6msgstr(dh6->dh6_msgtype), a);
+			free(a);
+			return;
+		}
+		relay_to_client((struct dhcp6_relay *)dh6, len,
+		    (struct sockaddr *)&from);
+	}
+}
+
+static int make_msgcontrol(struct msghdr *mh, void *ctlbuf, socklen_t buflen,
+		struct in6_pktinfo *pktinfo, int hlim)
+{
+	struct cmsghdr *cm;
+	socklen_t controllen;
+
+	controllen = 0;
+	if (pktinfo)
+		controllen += CMSG_SPACE(sizeof(*pktinfo));
+	if (hlim > 0)
+		controllen += CMSG_SPACE(sizeof(hlim));
+	if (buflen < controllen)
+		return (-1);
+
+	memset(ctlbuf, 0, buflen);
+	mh->msg_controllen = controllen;
+	mh->msg_control = ctlbuf;
+
+	cm = (struct cmsghdr *)CMSG_FIRSTHDR(mh);
+	if (pktinfo) {
+		cm->cmsg_len = CMSG_LEN(sizeof(*pktinfo));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_PKTINFO;
+		memcpy(CMSG_DATA((struct cmsghdr *)cm), pktinfo,
+		    sizeof(*pktinfo));
+
+		cm = CMSG_NXTHDR(mh, cm);
+	}
+
+	if (hlim > 0) {
+		cm->cmsg_len = CMSG_LEN(sizeof(hlim));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_HOPLIMIT;
+		*(int *)CMSG_DATA((struct cmsghdr *)cm) = hlim;
+
+		cm = CMSG_NXTHDR(mh, cm); /* just in case */
+	}
+
+	return (0);
+}
+
+static void relay_to_server(struct dhcp6 *dh6, ssize_t len,
+			    struct sockaddr_in6 *from,
+			    char *ifname, unsigned int ifid)
+{
+	struct dhcp6_optinfo optinfo;
+	struct dhcp6_relay *dh6relay;
+	struct in6_addr linkaddr;
+	int optlen, relaylen;
+	int i, cc;
+	struct msghdr mh;
+	struct iovec iov[2];
+	struct in6_pktinfo pktinfo;
+	char ctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))
+	    + CMSG_SPACE(sizeof(int))];
+
+	/*
+	 * Prepare a relay forward option.
+	 */
+	dhcp6_init_options(&optinfo);
+
+	/* Relay message */
+	optinfo.relaymsg_msg = xmalloc(len);
+	optinfo.relaymsg_len = len;
+	memcpy(optinfo.relaymsg_msg, dh6, len);
+
+	/* Interface-id.  We always use this option. */
+	optinfo.ifidopt_id = xmalloc(sizeof(ifid));
+	optinfo.ifidopt_len = sizeof(ifid);
+	memcpy(optinfo.ifidopt_id, &ifid, sizeof(ifid));
+
+	/*
+	 * Construct a relay forward message.
+	 */
+	dh6relay = (struct dhcp6_relay *)G.relaybuf;
+	memset(dh6relay, 0, sizeof(*dh6relay));
+	dh6relay->dh6relay_msgtype = DH6_RELAY_FORW;
+	memcpy(&dh6relay->dh6relay_peeraddr, &from->sin6_addr,
+	    sizeof(dh6relay->dh6relay_peeraddr));
+
+	/* find a global address to fill in the link address field */
+	memset(&linkaddr, 0, sizeof(linkaddr));
+	for (cc=0,i=0; i < ARRAY_SIZE(global_prefixes); i++) {
+		if (getifaddr(&linkaddr, ifname, &global_prefixes[i].addr,
+			      global_prefixes[i].plen, 1) == 0) {/* found */
+			cc = 1;
+			break;
+		}
+	}
+	if (cc == 0) {
+		bb_info_msg("failed to find a global address on %s", ifname);
+
+		/*
+		 * When relaying a message from a client, we need a global
+		 * link address.
+		 * XXX: this may be too strong for the stateless case, but
+		 * the DHCPv6 specification seems to require the behavior. 
+		 */
+		if (dh6->dh6_msgtype != DH6_RELAY_FORW)
+			goto out;
+	}
+
+	if (dh6->dh6_msgtype == DH6_RELAY_FORW) {
+		struct dhcp6_relay *dh6relay0 = (struct dhcp6_relay *)dh6;
+
+		/* Relaying a Message from a Relay Agent */
+
+		/*
+		 * If the hop-count in the message is greater than or equal to
+		 * HOP_COUNT_LIMIT, the relay agent discards the received
+		 * message.
+		 * [RFC3315 Section 20.1.2]
+		 */
+		if (dh6relay0->dh6relay_hcnt >= DHCP6_RELAY_HOP_COUNT_LIMIT) {
+			bb_info_msg("too many relay forwardings");
+			goto out;
+		}
+
+		dh6relay->dh6relay_hcnt = dh6relay0->dh6relay_hcnt + 1;
+
+		/*
+		 * We can keep the link-address field 0, regardless of the
+		 * scope of the source address, since we always include
+		 * interface-ID option.
+		 */
+	} else {
+		/* Relaying a Message from a Client */
+		memcpy(&dh6relay->dh6relay_linkaddr, &linkaddr,
+		    sizeof(dh6relay->dh6relay_linkaddr));
+		dh6relay->dh6relay_hcnt = 0;
+	}
+
+	relaylen = sizeof(*dh6relay);
+	if ((optlen = dhcp6_set_options(DH6_RELAY_FORW,
+	    (struct dhcp6opt *)(dh6relay + 1),
+	    (struct dhcp6opt *)(G.relaybuf + sizeof(G.relaybuf)),
+	    &optinfo)) < 0) {
+		bb_error_msg("failed to construct options");
+		goto out;
+	}
+	relaylen += optlen;
+
+	/*
+	 * Forward the message.
+	 */
+	memset(&mh, 0, sizeof(mh));
+	iov[0].iov_base = G.relaybuf;
+	iov[0].iov_len = relaylen;
+	mh.msg_iov = iov;
+	mh.msg_iovlen = 1;
+	mh.msg_name = &sa6_server;
+	mh.msg_namelen = sizeof(sa6_server);
+	if (IN6_IS_ADDR_MULTICAST(&sa6_server.sin6_addr)) {
+		memset(&pktinfo, 0, sizeof(pktinfo));
+		pktinfo.ipi6_ifindex = relayifid;
+		if (make_msgcontrol(&mh, ctlbuf, sizeof(ctlbuf),
+		    &pktinfo, mhops)) {
+			bb_error_msg("failed to make message control data");
+			goto out;
+		}
+	}
+
+	if ((cc = sendmsg(ssock, &mh, 0)) < 0) {
+		bb_perror_msg("sendmsg %s failed",
+		    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sa6_server));
+	} else if (cc != relaylen) {
+		bb_error_msg("failed to send a complete packet to %s",
+		    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sa6_server));
+	} else {
+		log1("relay a message to a server %s",
+		    xmalloc_sockaddr2dotted_noport((struct sockaddr *)&sa6_server));
+	}
+
+  out:
+	dhcp6_clear_options(&optinfo);
+}
+
+static void
+relay_to_client(struct dhcp6_relay *dh6relay, ssize_t len, struct sockaddr *from)
+{
+	struct dhcp6_optinfo optinfo;
+	struct sockaddr_in6 peer;
+	unsigned int ifid;
+	char ifnamebuf[IFNAMSIZ];
+	char *a = NULL;
+	int cc;
+	int relayed = 0;
+	struct dhcp6 *dh6;
+	struct msghdr mh;
+	struct in6_pktinfo pktinfo;
+	struct iovec iov[2];
+	char ctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a1[INET6_ADDRSTRLEN], a2[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a1, (const uint8_t *)&dh6relay->dh6relay_linkaddr);
+	sprint_nip6(a2, (const uint8_t *)&dh6relay->dh6relay_peeraddr);
+	log1("dhcp6 relay reply: hop=%d, linkaddr=%s, peeraddr=%s",
+	    dh6relay->dh6relay_hcnt, a1, a2);
+#endif
+
+	/*
+	 * parse and validate options in the relay reply message.
+	 */
+	dhcp6_init_options(&optinfo);
+	if (dhcp6_get_options((struct dhcp6opt *)(dh6relay + 1),
+	    (struct dhcp6opt *)((char *)dh6relay + len), &optinfo) < 0) {
+		bb_info_msg("failed to parse options");
+		return;
+	}
+
+	/* A relay reply message must include a relay message option */
+	if (optinfo.relaymsg_msg == NULL) {
+		a = xmalloc_sockaddr2dotted_noport(from);
+		bb_info_msg("relay reply message from %s "
+		    "without a relay message", a);
+		goto out;
+	}
+
+	/* minimum validation for the inner message */
+	if (optinfo.relaymsg_len < sizeof(struct dhcp6)) {
+		a = xmalloc_sockaddr2dotted_noport(from);
+		bb_info_msg("short relay message from %s",
+		    a);
+		goto out;
+	}
+
+	/*
+	 * Extract interface ID which should be included in relay reply
+	 * messages to us.
+	 */
+	a = xmalloc_sockaddr2dotted_noport(from);
+	ifid = 0;
+	if (optinfo.ifidopt_id) {
+		if (optinfo.ifidopt_len != sizeof(ifid)) {
+			bb_info_msg(
+			    "unexpected length (%d) for Interface ID from %s",
+			    optinfo.ifidopt_len, a);
+			goto out;
+		} else {
+			memcpy(&ifid, optinfo.ifidopt_id, sizeof(ifid));
+			ifid = ntohl(ifid);
+
+			/* validation for ID */
+			if ((if_indextoname(ifid, ifnamebuf)) == NULL) {
+				bb_info_msg("invalid interface ID: %x", ifid);
+				goto out;
+			}
+		}
+	} else {
+		bb_info_msg("Interface ID is not included from %s", a);
+		/*
+		 * the responding server should be buggy, but we deal with it.
+		 */
+	}
+	free(a);
+
+	/*
+	 * If we fail, try to get the interface from the link address.
+	 */
+	if (ifid == 0 &&
+	    !IN6_IS_ADDR_UNSPECIFIED(&dh6relay->dh6relay_linkaddr) &&
+	    !IN6_IS_ADDR_LINKLOCAL(&dh6relay->dh6relay_linkaddr)) {
+		if (getifidfromaddr(&dh6relay->dh6relay_linkaddr, &ifid))
+			ifid = 0;
+	}
+
+	if (ifid == 0) {
+		bb_error_msg("failed to determine relay link");
+		goto out;
+	}
+
+	peer = sa6_client;
+	dh6 = (struct dhcp6 *) optinfo.relaymsg_msg;
+	if (dh6->dh6_msgtype != DH6_RELAY_REPLY) {
+		relayed++;
+	} else {
+		/* 
+		 * change dst port to server/relay port, since it's a
+		 * reply to relay, not to a client
+		 */
+		peer.sin6_port = htons(547);	/* DH6PORT_UPSTREAM */
+	}
+	memcpy(&peer.sin6_addr, &dh6relay->dh6relay_peeraddr,
+	    sizeof(peer.sin6_addr));
+	if (IN6_IS_ADDR_LINKLOCAL(&peer.sin6_addr))
+		peer.sin6_scope_id = ifid; /* XXX: we assume a 1to1 map */
+
+	/* construct a message structure specifying the outgoing interface */
+	memset(&mh, 0, sizeof(mh));
+	iov[0].iov_base = optinfo.relaymsg_msg;
+	iov[0].iov_len = optinfo.relaymsg_len;
+	mh.msg_iov = iov;
+	mh.msg_iovlen = 1;
+	mh.msg_name = &peer;
+	mh.msg_namelen = sizeof(peer);
+	memset(&pktinfo, 0, sizeof(pktinfo));
+	pktinfo.ipi6_ifindex = ifid;
+	if (make_msgcontrol(&mh, ctlbuf, sizeof(ctlbuf), &pktinfo, 0)) {
+		bb_error_msg("failed to make message control data");
+		goto out;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&peer);
+	/* send packet */
+	if ((cc = sendmsg(csock, &mh, 0)) < 0) {
+		bb_perror_msg("sendmsg to %s failed", a);
+	} else if (cc != optinfo.relaymsg_len) {
+		bb_info_msg("failed to send a complete packet to %s", a);
+	} else {
+		log1("relay a message to a client %s", a);
+	}
+
+	if (relayed && G.scriptpath != NULL) {
+		struct dhcp6_optinfo optinfo1;
+		struct dhcp6opt *optend;
+
+		/* only replies are interesting */
+		if (dh6->dh6_msgtype != DH6_REPLY &&
+		    dh6->dh6_msgtype != DH6_ADVERTISE) {
+			bb_info_msg("forward msg#%d to client?", dh6->dh6_msgtype);
+			goto out;
+		}
+
+		/* parse options */
+		dhcp6_init_options(&optinfo1);
+		optend = (struct dhcp6opt *)((caddr_t) dh6 + optinfo.relaymsg_len);
+		if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1), optend,
+		    &optinfo1) < 0) {
+			bb_info_msg("failed to parse options");
+			goto out;
+		}
+
+		dhcp6_script(G.scriptpath, fill_envp_relay6(&optinfo1, a));
+		dhcp6_clear_options(&optinfo1);
+	}
+
+  out:
+	free(a);
+	dhcp6_clear_options(&optinfo);
+	return;
+}
+
+static int getifidfromaddr(struct in6_addr *addr, unsigned int *ifidp)
+{
+	struct ifaddrs *ifap, *ifa;
+	struct sockaddr_in6 *sa6;
+	unsigned int ifid;
+	int retval = -1;
+
+	if (getifaddrs(&ifap) != 0) {
+		bb_perror_msg("getifaddrs");
+		return (-1);
+	}
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		if (ifa->ifa_addr->sa_family != AF_INET6)
+			continue;
+
+		sa6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+		if (IN6_ARE_ADDR_EQUAL(addr, &sa6->sin6_addr))
+			break;
+	}
+
+	if (ifa != NULL) {
+		if ((ifid = if_nametoindex(ifa->ifa_name)) == 0) {
+			bb_error_msg("if_nametoindex failed for %s", ifa->ifa_name);
+			goto end;
+		}
+		retval = 0;
+		*ifidp = ifid;
+	}
+
+  end:
+	freeifaddrs(ifap);
+	return (retval);
+}
diff -urNBp busybox.orig/networking/udhcp/if6.c busybox/networking/udhcp/if6.c
--- busybox.orig/networking/udhcp/if6.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/if6.c	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,474 @@
+/*	$KAME: if.c,v 1.6 2005/09/16 11:30:15 suz Exp $	*/
+
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+
+#include <net/if.h>
+#include <netinet/in.h>
+#include <netinet/if_ether.h>
+
+#ifdef __linux__
+#include <linux/if_packet.h>
+#endif
+#include <net/if_arp.h>
+#ifdef __sun__
+#include <sys/sockio.h>
+#include <sys/dlpi.h>
+#include <stropts.h>
+#include <fcntl.h>
+#include <libdevinfo.h>
+#endif
+
+#include <syslog.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ifaddrs.h>
+#include <errno.h>
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+
+#ifdef __linux__
+/* from /usr/include/linux/ipv6.h */
+
+struct in6_ifreq {
+	struct in6_addr ifr6_addr;
+	uint32_t ifr6_prefixlen;
+	unsigned int ifr6_ifindex;
+};
+#endif
+
+
+struct dhcp6_if *if6init(char *ifname)
+{
+	struct dhcp6_if *ifp;
+
+	if ((ifp = find_ifconf_byname(ifname)) != NULL) {
+		bb_error_msg("duplicated interface: %s", ifname);
+		return (NULL);
+	}
+
+	ifp = xzalloc(sizeof(*ifp));
+	TAILQ_INIT(&ifp->event_list);
+	ifp->ifname = xstrdup(ifname);
+
+	if (if6reset(ifp))
+		goto fail;
+
+	TAILQ_INIT(&ifp->reqopt_list);
+	TAILQ_INIT(&ifp->iaconf_list);
+
+	ifp->authproto = DHCP6_AUTHPROTO_UNDEF;
+	ifp->authalgorithm = DHCP6_AUTHALG_UNDEF;
+	ifp->authrdm = DHCP6_AUTHRDM_UNDEF;
+
+	{
+		struct ifaddrs *ifa, *ifap;
+		struct sockaddr_in6 *sin6;
+
+		if (getifaddrs(&ifap) < 0) {
+			bb_perror_msg("getifaddrs");
+			goto fail;
+		}
+
+		for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+			if (strcmp(ifa->ifa_name, ifname) != 0)
+				continue;
+			if (ifa->ifa_addr == NULL)
+				continue;
+			if (ifa->ifa_addr->sa_family != AF_INET6)
+				continue;
+
+			sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+			if (IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr))
+				continue;
+
+			ifp->addr = sin6->sin6_addr;
+		}
+
+		freeifaddrs(ifap);
+	}
+
+	ifp->next = client6_config.dhcp6c_if;
+	client6_config.dhcp6c_if = ifp;
+	return (ifp);
+
+  fail:
+	free(ifp->ifname);
+	free(ifp);
+	return (NULL);
+}
+
+int if6reset(struct dhcp6_if *ifp)
+{
+	unsigned int ifid;
+	uint32_t linkid;
+
+	if ((ifid = if_nametoindex(ifp->ifname)) == 0) {
+		bb_perror_msg("invalid interface(%s)", ifp->ifname);
+		return (-1);
+	}
+
+#ifdef HAVE_SCOPELIB
+	if (inet_zoneid(AF_INET6, 2, ifname, &linkid)) {
+		bb_error_msg("failed to get link ID for %s",
+		    ifname);
+		return (-1);
+	}
+#else
+	linkid = ifid;		/* XXX: assume 1to1 mapping IFs and links */
+#endif
+
+	ifp->ifid = ifid;
+	ifp->linkid = linkid;
+
+	return (0);
+}
+
+int sock6_init(struct addrinfo *res)
+{
+	int sock;
+
+	sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+	if (sock < 0) {
+		bb_perror_msg_and_die("socket");
+	}
+	if (setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &const_int_1,
+			sizeof(const_int_1)) < 0) {
+		bb_perror_msg_and_die("setsockopt(SO_REUSEPORT)");
+	}
+	socket_want_pktinfo(sock);
+#ifdef IPV6_V6ONLY
+	if (setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, &const_int_1,
+			sizeof(const_int_1)) < 0) {
+		bb_perror_msg_and_die("setsockopt(IPV6_V6ONLY)");
+	}
+#endif
+
+	/*
+	 * According RFC3315 2.2, only the incoming port should be bound to UDP
+	 * port 546.  However, to have an interoperability with some servers,
+	 * the outgoing port is also bound to the DH6PORT_DOWNSTREAM.
+	 */
+	xbind(sock, res->ai_addr, res->ai_addrlen);
+	freeaddrinfo(res);
+
+	return sock;
+}
+
+struct dhcp6_if *find_ifconf_byname(char *ifname)
+{
+	struct dhcp6_if *ifp;
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		if (strcmp(ifp->ifname, ifname) == 0)
+			return (ifp);
+	}
+
+	return (NULL);
+}
+
+struct dhcp6_if *find_ifconf_byid(unsigned int id)
+{
+	struct dhcp6_if *ifp;
+
+	for (ifp = client6_config.dhcp6c_if; ifp; ifp = ifp->next) {
+		if (ifp->ifid == id)
+			return (ifp);
+	}
+
+	return (NULL);
+}
+
+#ifdef __sun__
+struct hwparms {
+	char *buf;
+	uint16_t *hwtypep;
+	ssize_t retval;
+};
+
+static ssize_t getifhwaddr(const char *ifname, char *buf, uint16_t *hwtypep,
+			int ppa)
+{
+	int fd, flags;
+	char fname[MAXPATHLEN], *cp;
+	struct strbuf putctl;
+	struct strbuf getctl;
+	long getbuf[1024];
+	dl_info_req_t dlir;
+	dl_phys_addr_req_t dlpar;
+	dl_phys_addr_ack_t *dlpaa;
+
+	log1("trying %s ppa %d", ifname, ppa);
+
+	if (ifname[0] == '\0')
+		return (-1);
+	if (ppa >= 0 && !isdigit(ifname[strlen(ifname) - 1]))
+		(void) snprintf(fname, sizeof(fname), "/dev/%s%d", ifname,
+		    ppa);
+	else
+		(void) snprintf(fname, sizeof(fname), "/dev/%s", ifname);
+	getctl.maxlen = sizeof(getbuf);
+	getctl.buf = (char *)getbuf;
+	if ((fd = open(fname, O_RDWR)) == -1) {
+		dl_attach_req_t dlar;
+
+		cp = fname + strlen(fname) - 1;
+		if (!isdigit(*cp))
+			return (-1);
+		while (cp > fname) {
+			if (!isdigit(*cp))
+				break;
+			cp--;
+		}
+		if (cp == fname)
+			return (-1);
+		cp++;
+		dlar.dl_ppa = atoi(cp);
+		*cp = '\0';
+		if ((fd = open(fname, O_RDWR)) == -1)
+			return (-1);
+		dlar.dl_primitive = DL_ATTACH_REQ;
+		putctl.len = sizeof(dlar);
+		putctl.buf = (char *)&dlar;
+		if (putmsg(fd, &putctl, NULL, 0) == -1) {
+			(void) close(fd);
+			return (-1);
+		}
+		flags = 0;
+		if (getmsg(fd, &getctl, NULL, &flags) == -1) {
+			(void) close(fd);
+			return (-1);
+		}
+		if (getbuf[0] != DL_OK_ACK) {
+			(void) close(fd);
+			return (-1);
+		}
+	}
+	dlir.dl_primitive = DL_INFO_REQ;
+	putctl.len = sizeof(dlir);
+	putctl.buf = (char *)&dlir;
+	if (putmsg(fd, &putctl, NULL, 0) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	flags = 0;
+	if (getmsg(fd, &getctl, NULL, &flags) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	if (getbuf[0] != DL_INFO_ACK) {
+		(void) close(fd);
+		return (-1);
+	}
+	switch (((dl_info_ack_t *)getbuf)->dl_mac_type) {
+	case DL_CSMACD:
+	case DL_ETHER:
+	case DL_100VG:
+	case DL_ETH_CSMA:
+	case DL_100BT:
+		*hwtypep = ARPHRD_ETHER;
+		break;
+	default:
+		(void) close(fd);
+		return (-1);
+	}
+	dlpar.dl_primitive = DL_PHYS_ADDR_REQ;
+	dlpar.dl_addr_type = DL_CURR_PHYS_ADDR;
+	putctl.len = sizeof(dlpar);
+	putctl.buf = (char *)&dlpar;
+	if (putmsg(fd, &putctl, NULL, 0) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	flags = 0;
+	if (getmsg(fd, &getctl, NULL, &flags) == -1) {
+		(void) close(fd);
+		return (-1);
+	}
+	if (getbuf[0] != DL_PHYS_ADDR_ACK) {
+		(void) close(fd);
+		return (-1);
+	}
+	dlpaa = (dl_phys_addr_ack_t *)getbuf;
+	if (dlpaa->dl_addr_length != 6) {
+		(void) close(fd);
+		return (-1);
+	}
+	(void) memcpy(buf, (char *)getbuf + dlpaa->dl_addr_offset,
+	    dlpaa->dl_addr_length);
+	return (dlpaa->dl_addr_length);
+}
+
+static int devfs_handler(di_node_t node, di_minor_t minor, void *arg)
+{
+	struct hwparms *parms = arg;
+
+	parms->retval = getifhwaddr(di_minor_name(minor), parms->buf,
+	    parms->hwtypep, di_instance(node));
+	return (parms->retval == -1 ? DI_WALK_CONTINUE : DI_WALK_TERMINATE);
+}
+#endif /* __sun__ */
+
+ssize_t gethwid(char *buf, const char *ifname, uint16_t *hwtypep)
+{
+#ifdef __sun__
+	if (ifname == NULL) {
+		di_node_t root;
+		struct hwparms parms;
+
+		if ((root = di_init("/", DINFOSUBTREE | DINFOMINOR |
+		    DINFOPROP)) == DI_NODE_NIL) {
+			bb_info_msg("di_init failed");
+			return (-1);
+		}
+		parms.buf = buf;
+		parms.hwtypep = hwtypep;
+		parms.retval = -1;
+		(void) di_walk_minor(root, DDI_NT_NET, DI_CHECK_ALIAS, &parms,
+		    devfs_handler);
+		di_fini(root);
+		return (parms.retval);
+	} else {
+		return (getifhwaddr(ifname, buf, hwtypep, -1));
+	}
+#else /* !__sun__ */
+
+	int fd;
+        struct ifreq ifr;
+
+	memset(&ifr, 0, sizeof(ifr));
+	fd = xsocket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
+
+	if (ioctl_or_warn(fd, SIOCGIFHWADDR, &ifr) != 0) {
+		close(fd);
+		return (-1);
+	}
+	close(fd);
+	switch (ifr.ifr_hwaddr.sa_family) {
+		case ARPHRD_ETHER:
+		case ARPHRD_EETHER:
+		case ARPHRD_IEEE802:
+			*hwtypep = ifr.ifr_hwaddr.sa_family;
+			break;
+		default:
+			return (-2);
+	}
+	memcpy(buf, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
+
+	return (ETH_ALEN);
+#endif /* __sun__ */
+}
+
+int ifaddrconf(ifaddrconf_cmd_t cmd, char *ifname, struct sockaddr_in6 *addr,
+	   int plen,
+	   int pltime __attribute__((unused)),
+	   int vltime __attribute__((unused))
+	  )
+{
+/*
+ * TODO: Should be rewritten to Netlink calls in order to support
+ *       preferred/valid lifetimes
+ */
+#if   defined(__linux__)
+	struct in6_ifreq req;
+	struct ifreq ifr;
+#elif defined(__sun__)
+	struct lifreq req;
+#endif
+	unsigned long ioctl_cmd;
+	const char *cmdstr;
+	int s;
+
+	switch (cmd) {
+	case IFADDRCONF_ADD:
+		cmdstr = "add";
+#if   defined(__linux__)
+		ioctl_cmd = SIOCSIFADDR;
+#elif defined(__sun__)
+		ioctl_cmd = SIOCLIFADDIF;
+#endif
+		break;
+	case IFADDRCONF_REMOVE:
+		cmdstr = "remove";
+#if   defined(__linux__)
+		ioctl_cmd = SIOCDIFADDR;
+#elif defined(__sun__)
+		ioctl_cmd = SIOCLIFREMOVEIF;
+#endif
+		break;
+	default:
+		return (-1);
+	}
+
+	s = xsocket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+	memset(&req, 0, sizeof(req));
+
+#if   defined(__linux__)
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy_IFNAMSIZ(ifr.ifr_name, ifname);
+	xioctl(s, SIOGIFINDEX, &ifr);
+	memcpy(&req.ifr6_addr, &addr->sin6_addr, sizeof(struct in6_addr));
+	req.ifr6_prefixlen = plen;
+	req.ifr6_ifindex = ifr.ifr_ifindex;
+#elif defined(__sun__)
+	strncpy(req.lifr_name, ifname, sizeof(req.lifr_name));
+#endif /* __sun__ */
+
+	if (ioctl(s, ioctl_cmd, &req)) {
+		bb_perror_msg("failed to %s an address on %s", cmdstr, ifname);
+		close(s);
+		if (errno == EEXIST) /* Ignore address duplicate */
+			return (0);
+		return (-1);
+	}
+
+#if defined(__sun__)
+	memcpy(&req.lifr_addr, addr, sizeof(*addr));
+	if (ioctl(s, SIOCSLIFADDR, &req) == -1) {
+		bb_perror_msg("failed to %s new address on %s", cmdstr, ifname);
+		close(s);
+		return (-1);
+	}
+#endif /* __sun__ */
+
+	close(s);
+
+	bb_info_msg("%s an address %s/%d on %s", cmdstr,
+	    xmalloc_sockaddr2dotted_noport((struct sockaddr *)addr), plen, ifname);
+
+	return (0);
+}
diff -urNBp busybox.orig/networking/udhcp/Kbuild.src busybox/networking/udhcp/Kbuild.src
--- busybox.orig/networking/udhcp/Kbuild.src	2011-03-13 04:45:06.000000000 +0300
+++ busybox/networking/udhcp/Kbuild.src	2011-05-20 15:22:30.000000000 +0400
@@ -17,5 +17,12 @@ lib-$(CONFIG_UDHCPD)     += dhcpd.o arpp
 lib-$(CONFIG_DUMPLEASES) += dumpleases.o
 lib-$(CONFIG_DHCPRELAY)  += dhcprelay.o
 
+lib-$(CONFIG_DHCP6C)     += common6.o common.o
+
+lib-$(CONFIG_DHCP6C)     += dhcp6c.o config6.o dhcp6c_script.o dhcp6c_ia.o if6.o timer.o
+lib-$(CONFIG_DHCP6RELAY) += dhcp6relay.o domain_codec.o
+
+lib-$(CONFIG_FEATURE_DHCP6_AUTH)    += auth6.o
+
 lib-$(CONFIG_FEATURE_UDHCPC_ARPING) += arpping.o
 lib-$(CONFIG_FEATURE_UDHCP_RFC3397) += domain_codec.o
diff -urNBp busybox.orig/networking/udhcp/timer.c busybox/networking/udhcp/timer.c
--- busybox.orig/networking/udhcp/timer.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/timer.c	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,145 @@
+/*	$KAME: timer.c,v 1.6 2003/07/31 23:25:59 jinmei Exp $	*/
+
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+
+#include <netinet/in.h>
+
+#include <unistd.h>
+#include <syslog.h>
+#include <stdlib.h>
+#include <string.h>
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include <search.h>
+#endif
+
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "timer.h"
+
+#define MILLION 1000000
+
+static const unsigned long long t_max = 0xffffffffffffffffULL;
+
+
+void dhcp6_timer_init(void)
+{
+	LIST_INIT(&client6_config.timer_head);
+	client6_config.tm_sentinel = t_max;
+}
+
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*timeout)(void *),
+				    void *timeodata)
+{
+	struct dhcp6_timer *newtimer;
+
+	if (timeout == NULL) {
+		log1("timeout function unspecified");
+		return (NULL);
+	}
+
+	newtimer = xzalloc(sizeof(*newtimer));
+	newtimer->expire = timeout;
+	newtimer->expire_data = timeodata;
+	newtimer->t = t_max;
+
+	LIST_INSERT_HEAD(&client6_config.timer_head, newtimer, link);
+
+	return (newtimer);
+}
+
+void dhcp6_timer_remove(struct dhcp6_timer **timer)
+{
+	LIST_REMOVE(*timer, link);
+	free(*timer);
+	*timer = NULL;
+}
+
+void dhcp6_timer_set(unsigned long long t, struct dhcp6_timer *timer)
+{
+	timer->t = monotonic_ms() + t;
+
+	/* update the next expiration time */
+	if (timer->t < client6_config.tm_sentinel)
+		client6_config.tm_sentinel = timer->t;
+}
+
+/*
+ * Check expiration for each timer. If a timer is expired,
+ * call the expire function for the timer and update the timer.
+ * Return the next interval for select() call.
+ */
+struct timeval *dhcp6_timer_check(void)
+{
+	unsigned long long now = monotonic_ms();
+	struct dhcp6_timer *tm, *tm_next;
+
+	client6_config.tm_sentinel = t_max;
+	for (tm = LIST_FIRST(&client6_config.timer_head); tm; tm = tm_next) {
+		tm_next = LIST_NEXT(tm, link);
+
+		if (tm->t <= now) {
+			if ((*tm->expire)(tm->expire_data) == NULL)
+				continue; /* timer has been freed */
+		}
+
+		if (tm->t < client6_config.tm_sentinel)
+			client6_config.tm_sentinel = tm->t;
+	}
+
+	if (t_max == client6_config.tm_sentinel) {
+		/* no need to timeout */
+		return (NULL);
+	} else if (client6_config.tm_sentinel < now) {
+		/* this may occur when the interval is too small */
+		client6_config.tm_check.tv_sec = client6_config.tm_check.tv_usec = 0;
+	} else {
+		client6_config.tm_check.tv_sec =
+			(client6_config.tm_sentinel - now) / 1000ULL;
+		client6_config.tm_check.tv_usec =
+			((client6_config.tm_sentinel - now) % 1000ULL) * 1000ULL;
+	}
+	return (&client6_config.tm_check);
+}
+
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *timer)
+{
+	unsigned long long now = monotonic_ms();
+
+	if (timer->t <= now) {
+		log2("a timer must be expired, but not yet");
+		return 0ULL;
+	} else
+		return (timer->t - now);
+}
diff -urNBp busybox.orig/networking/udhcp/timer.h busybox/networking/udhcp/timer.h
--- busybox.orig/networking/udhcp/timer.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox/networking/udhcp/timer.h	2011-05-24 19:32:14.000000000 +0400
@@ -0,0 +1,50 @@
+/*	$KAME: timer.h,v 1.1 2002/05/16 06:04:08 jinmei Exp $	*/
+
+/*
+ * Copyright (C) 2002 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#ifndef __DHCP6_TIMER_H
+#define __DHCP6_TIMER_H 1
+
+struct dhcp6_timer {
+	LIST_ENTRY(dhcp6_timer) link;
+
+	unsigned long long t;
+
+	struct dhcp6_timer *(*expire)(void *);
+	void *expire_data;
+};
+
+void dhcp6_timer_init(void);
+struct dhcp6_timer *dhcp6_timer_add(struct dhcp6_timer *(*)(void *), void *);
+void dhcp6_timer_set(unsigned long long , struct dhcp6_timer *);
+void dhcp6_timer_remove(struct dhcp6_timer **);
+struct timeval *dhcp6_timer_check(void);
+unsigned long long dhcp6_timer_rest(struct dhcp6_timer *);
+
+#endif /* timer.h */
