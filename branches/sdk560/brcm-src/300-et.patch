diff -urB src/et-4.108.9/sys/etc47xx.c src/et/sys/etc47xx.c
--- src/et-4.108.9/sys/etc47xx.c	2007-03-20 15:22:00.000000000 +0300
+++ src/et/sys/etc47xx.c	2009-03-21 22:17:24.000000000 +0300
@@ -96,7 +96,7 @@
 static void chipphyadvertise(struct bcm4xxx *ch, uint phyaddr);
 
 /* chip interrupt bit error summary */
-#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU)
+#define	I_ERRORS	(I_PC | I_PD | I_DE | I_RU | I_RO | I_XU | I_TO)
 #define	DEF_INTMASK	(I_XI | I_RI | I_ERRORS)
 
 struct chops bcm47xx_et_chops = {
@@ -196,6 +196,10 @@
 	etc->nicmode = !(sb_bus(ch->sbh) == SB_BUS);
 	etc->coreunit = sb_coreunit(ch->sbh);
 	etc->boardflags = getintvar(ch->vars, "boardflags");
+	
+	/* set boardflags for 5365 and 5350 */
+	if (etc->chip == BCM5365_CHIP_ID || etc->chip == BCM5350_CHIP_ID)
+		etc->boardflags |= BFL_ENETROBO | BFL_ENETVLAN;
 
 	boardflags = etc->boardflags;
 	boardtype = sb_boardtype(ch->sbh);
@@ -601,6 +605,9 @@
 
 	/* set tx watermark */
 	W_REG(ch->osh, &regs->txwatermark, 56);
+	
+	/* set tx duplex */
+	W_REG(ch->osh, &regs->txcontrol, etc->duplex ? EXC_FD : 0);
 
 	/*
 	 * Optionally, disable phy autonegotiation and force our speed/duplex
@@ -619,6 +626,9 @@
 		/* post dma receive buffers */
 		dma_rxfill(ch->di);
 
+		/* setup timer interrupt */
+		W_REG(ch->osh, &regs->gptimer, 0);
+		
 		/* lastly, enable interrupts */
 		et_intrson(etc->et);
 	}
@@ -729,6 +739,15 @@
 		events |= INTR_ERROR;
 	if (intstatus & I_TO)
 		events |= INTR_TO;
+	
+	/* check for rx after tx for 3 seconds on the unit 1, */
+	/* schedule reset if it's missing - possible rx stuck */
+	if (ch->etc->chip == BCM4710_CHIP_ID && ch->etc->unit == 1) {
+		if (intstatus & I_RI)
+			W_REG(ch->osh, &regs->gptimer, 0);
+		else if (!R_REG(ch->osh, &regs->gptimer))
+			W_REG(ch->osh, &regs->gptimer, 3 * 125000000);
+	}
 
 	return (events);
 }
@@ -793,6 +812,10 @@
 		ET_ERROR(("et%d: transmit fifo underflow\n", etc->unit));
 		etc->txuflo++;
 	}
+	
+	if (intstatus & I_TO) {
+                ET_ERROR(("et%d: rx stuck suspected\n", etc->unit));
+	}
 
 	return (TRUE);
 }
@@ -1065,9 +1088,17 @@
 
 	phyid = chipphyrd(ch, phyaddr, 0x2);
 	phyid |=  chipphyrd(ch, phyaddr, 0x3) << 16;
+
 	if (phyid == 0x55210022) {
+		chipphywr(ch, phyaddr, 28, (uint16) (chipphyrd(ch, phyaddr, 28) & 0x0fff));
 		chipphywr(ch, phyaddr, 30, (uint16) (chipphyrd(ch, phyaddr, 30) | 0x3000));
 		chipphywr(ch, phyaddr, 22, (uint16) (chipphyrd(ch, phyaddr, 22) & 0xffdf));
+
+		chipphywr(ch, phyaddr, 28, (uint16) ((chipphyrd(ch, phyaddr, 28) & 0x0fff) | 0x1000));
+		chipphywr(ch, phyaddr, 29, 1);
+		chipphywr(ch, phyaddr, 30, 4);
+
+		chipphywr(ch, phyaddr, 28, (uint16) (chipphyrd( ch, phyaddr, 28) & 0x0fff));
 	}
 }
 
@@ -1108,6 +1139,13 @@
 	}
 
 	chipphywr(ch, phyaddr, 0, ctl);
+
+	/* force Auto MDI-X for the AC101L phy */
+	if (chipphyrd(ch, phyaddr, 2) == 0x0022 && 
+		chipphyrd(ch, phyaddr, 3) == 0x5521)
+	{
+		chipphywr(ch, phyaddr, 23, 0x8000);
+	}
 }
 
 /* set selected capability bits in autonegotiation advertisement */
diff -urB src/et-4.108.9/sys/etc.c src/et/sys/etc.c
--- src/et-4.108.9/sys/etc.c	2007-03-20 15:22:00.000000000 +0300
+++ src/et/sys/etc.c	2009-03-28 20:30:32.000000000 +0300
@@ -320,6 +366,7 @@
 void
 etc_watchdog(etc_info_t *etc)
 {
+	uint16 control;
 	uint16 status;
 	uint16 adv;
 	uint16 lpa;
@@ -328,23 +375,43 @@
 
 	/* no local phy registers */
 	if (etc->phyaddr == EPHY_NOREG) {
-		etc->linkstate = TRUE;
-		etc->speed = 100;
-		etc->duplex = 1;
-		return;
+		control = CTL_SPEED | CTL_DUPLEX;
+		status = STAT_LINK;
+	} else {
+		control = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 0);
+		status = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 1);
 	}
 
-	status = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 1);
-	adv = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 4);
-	lpa = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 5);
-
 	/* check for bad mdio read */
-	if (status == 0xffff) {
+	if (control == 0xffff || status == 0xffff) {
 		ET_ERROR(("et%d: etc_watchdog: bad mdio read: phyaddr %d mdcport %d\n",
 			etc->unit, etc->phyaddr, etc->mdcport));
 		return;
 	}
 
+	/* update current speed and duplex */
+	if (control & CTL_ANENAB) {
+		adv = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 4);
+		lpa = (*etc->chops->phyrd)(etc->ch, etc->phyaddr, 5);
+	
+		if ((adv & ADV_100FULL) && (lpa & LPA_100FULL)) {
+			etc->speed = 100;
+			etc->duplex = 1;
+		} else if ((adv & ADV_100HALF) && (lpa & LPA_100HALF)) {
+			etc->speed = 100;
+			etc->duplex = 0;
+		} else if ((adv & ADV_10FULL) && (lpa & LPA_10FULL)) {
+			etc->speed = 10;
+			etc->duplex = 1;
+		} else {
+			etc->speed = 10;
+			etc->duplex = 0;
+		}
+	} else {
+		etc->speed = (control & CTL_SPEED) ? 100 : 10;
+		etc->duplex = (control & CTL_DUPLEX) ? 1 : 0;
+	}
+
 	/* monitor link state */
 	if (!etc->linkstate && (status & STAT_LINK)) {
 		etc->linkstate = TRUE;
@@ -352,27 +419,16 @@
 		if (etc->pm_modechange)
 			etc->pm_modechange = FALSE;
 		else
+		{
 			et_link_up(etc->et);
+		}
 	}
 	else if (etc->linkstate && !(status & STAT_LINK)) {
 		etc->linkstate = FALSE;
 		if (!etc->pm_modechange)
+		{
 			et_link_down(etc->et);
-	}
-
-	/* update current speed and duplex */
-	if ((adv & ADV_100FULL) && (lpa & LPA_100FULL)) {
-		etc->speed = 100;
-		etc->duplex = 1;
-	} else if ((adv & ADV_100HALF) && (lpa & LPA_100HALF)) {
-		etc->speed = 100;
-		etc->duplex = 0;
-	} else if ((adv & ADV_10FULL) && (lpa & LPA_10FULL)) {
-		etc->speed = 10;
-		etc->duplex = 1;
-	} else {
-		etc->speed = 10;
-		etc->duplex = 0;
+		}	
 	}
 
 	/* keep emac txcontrol duplex bit consistent with current phy duplex */
diff -urB src/et-4.108.9/sys/et_dbg.h src/et/sys/et_dbg.h
--- src/et-4.108.9/sys/et_dbg.h	2007-03-20 15:22:00.000000000 +0300
+++ src/et/sys/et_dbg.h	2009-03-21 22:17:24.000000000 +0300
@@ -16,8 +16,8 @@
 #ifndef _et_dbg_
 #define _et_dbg_
 
-#define	ET_ERROR(args)
-#define	ET_TRACE(args)
+#define	ET_ERROR(args)  if (!(et_msg_level & 1)) ; else printf args
+#define	ET_TRACE(args)  if (!(et_msg_level & 2)) ; else printf args
 #define	ET_PRHDR(msg, eh, len, unit)
 #define	ET_PRPKT(msg, buf, len, unit)
 
diff -urB src/et-4.108.9/sys/et_linux.c src/et/sys/et_linux.c
--- src/et-4.108.9/sys/et_linux.c	2007-03-20 15:22:00.000000000 +0300
+++ src/et/sys/et_linux.c	2009-03-28 14:16:10.000000000 +0300
@@ -36,6 +36,7 @@
 #ifdef SIOCETHTOOL
 #include <linux/ethtool.h>
 #endif /* SIOCETHTOOL */
+#include <linux/mii.h>
 #include <linux/ip.h>
 
 #include <asm/system.h>
@@ -694,6 +742,7 @@
 	char *buf;
 	int size;
 	bool get, set;
+	struct mii_ioctl_data *data = (struct mii_ioctl_data *)&ifr->ifr_data;
 
 	et = ET_INFO(dev);
 
@@ -714,13 +763,25 @@
 		get = TRUE; set = FALSE;
 		break;
 	case SIOCGETCPHYRD:
+	case SIOCGETCPHYRD2:
+	case SIOCGETCROBORD:
 		size = sizeof(int) * 2;
 		get = TRUE; set = TRUE;
 		break;
 	case SIOCSETCPHYWR:
+	case SIOCSETCPHYWR2:
+	case SIOCSETCROBOWR:
 		size = sizeof(int) * 2;
 		get = FALSE; set = TRUE;
 		break;
+	case SIOCGMIIPHY:
+		data->phy_id = et->etc->phyaddr;
+	case SIOCGMIIREG:
+		data->val_out = (*et->etc->chops->phyrd)(et->etc->ch, data->phy_id, data->reg_num);
+		return 0;
+	case SIOCSMIIREG:
+		(*et->etc->chops->phywr)(et->etc->ch, data->phy_id, data->reg_num, data->val_in);
+		return 0;
 	default:
 		size = sizeof(int);
 		get = FALSE; set = TRUE;
@@ -1014,6 +1075,25 @@
 	if (flags & (RXF_NO | RXF_RXER | RXF_CRC | RXF_OV))
 		goto err;
 
+	/* check for invalid data on the unit 1, workaround hw bug */
+	if (etc->chip == BCM4710_CHIP_ID && etc->unit == 1) 
+	{
+		uint8 *ether_dhost = ((struct ether_header*)skb->data)->ether_dhost;
+		if (	!(flags & (RXF_MULT | RXF_BRDCAST)) != !ETHER_ISMULTI(ether_dhost) ||
+			!(flags & RXF_BRDCAST) != !ETHER_ISBCAST(ether_dhost) ||
+			((flags & (RXF_MULT | RXF_BRDCAST | RXF_MISS)) == 0 &&
+				ether_cmp(ether_dhost, &etc->cur_etheraddr)))
+		{
+			bcm_ether_ntoa((struct ether_addr*)ether_dhost, eabuf);
+			ET_ERROR(("et%d: rx: bad dest address %s [%c%c%c]\n", 
+				etc->unit, eabuf, (flags & RXF_MULT) ? 'M' : ' ', 
+				(flags & RXF_BRDCAST) ? 'B' : ' ', (flags & RXF_MISS) ? 'P' : ' '));
+			/* schedule reset */
+			et->events |= INTR_ERROR;
+			goto err;
+		}
+	}
+
 	/* Extract priority from payload and store it out-of-band in skb->priority */
 	if (et->etc->qos)
 		pktsetprio(skb, TRUE);
