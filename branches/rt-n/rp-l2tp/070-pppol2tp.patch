diff -BurpN rp-l2tp-0.4/handlers/Makefile.in rp-l2tp/handlers/Makefile.in
--- rp-l2tp-0.4/handlers/Makefile.in	2009-08-31 06:07:49.000000000 +0000
+++ rp-l2tp/handlers/Makefile.in	2009-08-31 06:08:17.000000000 +0000
@@ -14,7 +14,7 @@ HANDLERS=sync-pppd.so cmd.so
 
 OBJS=pty.o sync-pppd.o dstring.o
 SRCS=$(OBJS:.o=.c)
-CFLAGS=@CFLAGS@ -I.. -I../@LIBEVENT@ -Wall
+CFLAGS=@CFLAGS@ -I.. -I../@LIBEVENT@ -I. -Wall
 
 all: $(HANDLERS) l2tp-control
 
diff -BurpN rp-l2tp-0.4/handlers/linux/if_pppol2tp.h rp-l2tp/handlers/linux/if_pppol2tp.h
--- rp-l2tp-0.4/handlers/linux/if_pppol2tp.h	1970-01-01 00:00:00.000000000 +0000
+++ rp-l2tp/handlers/linux/if_pppol2tp.h	2009-08-31 06:08:17.000000000 +0000
@@ -0,0 +1,67 @@
+/***************************************************************************
+ * Linux PPP over L2TP (PPPoL2TP) Socket Implementation (RFC 2661)
+ *
+ * This file supplies definitions required by the PPP over L2TP driver
+ * (pppol2tp.c).  All version information wrt this file is located in pppol2tp.c
+ *
+ * License:
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __LINUX_IF_PPPOL2TP_H
+#define __LINUX_IF_PPPOL2TP_H
+
+#include <asm/types.h>
+
+#ifdef __KERNEL__
+#include <linux/in.h>
+#endif
+
+/* Structure used to bind() the socket to a particular socket & tunnel */
+struct pppol2tp_addr
+{
+	pid_t	pid;			/* pid that owns the fd.
+					 * 0 => current */
+	int	fd;			/* FD of UDP socket to use */
+
+	struct sockaddr_in addr;	/* IP address and port to send to */
+
+	__u16 s_tunnel, s_session;	/* For matching incoming packets */
+	__u16 d_tunnel, d_session;	/* For sending outgoing packets */
+};
+
+/* Socket options:
+ * DEBUG	- bitmask of debug message categories
+ * SENDSEQ	- 0 => don't send packets with sequence numbers
+ *		  1 => send packets with sequence numbers
+ * RECVSEQ	- 0 => receive packet sequence numbers are optional
+ *		  1 => drop receive packets without sequence numbers
+ * LNSMODE	- 0 => act as LAC.
+ *		  1 => act as LNS.
+ * REORDERTO	- reorder timeout (in millisecs). If 0, don't try to reorder.
+ */
+enum {
+	PPPOL2TP_SO_DEBUG	= 1,
+	PPPOL2TP_SO_RECVSEQ	= 2,
+	PPPOL2TP_SO_SENDSEQ	= 3,
+	PPPOL2TP_SO_LNSMODE	= 4,
+	PPPOL2TP_SO_REORDERTO	= 5,
+};
+
+/* Debug message categories for the DEBUG socket option */
+enum {
+	PPPOL2TP_MSG_DEBUG	= (1 << 0),	/* verbose debug (if
+						 * compiled in) */
+	PPPOL2TP_MSG_CONTROL	= (1 << 1),	/* userspace - kernel
+						 * interface */
+	PPPOL2TP_MSG_SEQ	= (1 << 2),	/* sequence numbers */
+	PPPOL2TP_MSG_DATA	= (1 << 3),	/* data packets */
+};
+
+
+
+#endif
diff -BurpN rp-l2tp-0.4/handlers/linux/if_pppox.h rp-l2tp/handlers/linux/if_pppox.h
--- rp-l2tp-0.4/handlers/linux/if_pppox.h	1970-01-01 00:00:00.000000000 +0000
+++ rp-l2tp/handlers/linux/if_pppox.h	2009-08-31 05:05:14.000000000 +0000
@@ -0,0 +1,165 @@
+/***************************************************************************
+ * Linux PPP over X - Generic PPP transport layer sockets
+ * Linux PPP over Ethernet (PPPoE) Socket Implementation (RFC 2516)
+ *
+ * This file supplies definitions required by the PPP over Ethernet driver
+ * (pppox.c).  All version information wrt this file is located in pppox.c
+ *
+ * License:
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __LINUX_IF_PPPOX_H
+#define __LINUX_IF_PPPOX_H
+
+
+#include <asm/types.h>
+#include <asm/byteorder.h>
+
+#ifdef  __KERNEL__
+#include <linux/if_ether.h>
+#include <linux/if.h>
+#include <linux/netdevice.h>
+#include <linux/sched.h>
+#include <asm/semaphore.h>
+#include <linux/ppp_channel.h>
+#endif /* __KERNEL__ */
+#include <linux/if_pppol2tp.h>
+
+/* For user-space programs to pick up these definitions
+ * which they wouldn't get otherwise without defining __KERNEL__
+ */
+#ifndef AF_PPPOX
+#define AF_PPPOX	24
+#define PF_PPPOX	AF_PPPOX
+#endif /* !(AF_PPPOX) */
+
+/************************************************************************
+ * PPPoE addressing definition
+ */
+typedef __u16 sid_t;
+struct pppoe_addr{
+       sid_t           sid;                    /* Session identifier */
+       unsigned char   remote[ETH_ALEN];       /* Remote address */
+       char            dev[IFNAMSIZ];          /* Local device to use */
+};
+
+/************************************************************************
+ * Protocols supported by AF_PPPOX
+ */
+#define PX_PROTO_OE    0 /* Currently just PPPoE */
+#define PX_PROTO_OL2TP 1 /* Now L2TP also */
+#define PX_PROTO_PPTP  2
+#define PX_MAX_PROTO   3
+
+/* The use of a union isn't viable because the size of this struct
+ * must stay fixed over time -- applications use sizeof(struct
+ * sockaddr_pppox) to fill it. Use protocol specific sockaddr types
+ * instead.
+ */
+struct sockaddr_pppox {
+       sa_family_t     sa_family;            /* address family, AF_PPPOX */
+       unsigned int    sa_protocol;          /* protocol identifier */
+       union{
+               struct pppoe_addr       pppoe;
+       }sa_addr;
+}__attribute__ ((packed)); /* deprecated */
+
+/* Must be binary-compatible with sockaddr_pppox for backwards compatabilty */
+struct sockaddr_pppoe {
+	sa_family_t     sa_family;	/* address family, AF_PPPOX */
+	unsigned int    sa_protocol;    /* protocol identifier */
+	struct pppoe_addr pppoe;
+}__attribute__ ((packed));
+
+struct sockaddr_pppol2tp {
+	sa_family_t     sa_family;      /* address family, AF_PPPOX */
+	unsigned int    sa_protocol;    /* protocol identifier */
+	struct pppol2tp_addr pppol2tp;
+}__attribute__ ((packed));
+
+/*********************************************************************
+ *
+ * ioctl interface for defining forwarding of connections
+ *
+ ********************************************************************/
+
+#define PPPOEIOCSFWD	_IOW(0xB1 ,0, sizeof(struct sockaddr_pppox))
+#define PPPOEIOCDFWD	_IO(0xB1 ,1)
+/*#define PPPOEIOCGFWD	_IOWR(0xB1,2, sizeof(struct sockaddr_pppox))*/
+
+/* Codes to identify message types */
+#define PADI_CODE	0x09
+#define PADO_CODE	0x07
+#define PADR_CODE	0x19
+#define PADS_CODE	0x65
+#define PADT_CODE	0xa7
+struct pppoe_tag {
+	__u16 tag_type;
+	__u16 tag_len;
+	char tag_data[0];
+} __attribute ((packed));
+
+/* Tag identifiers */
+#define PTT_EOL		__constant_htons(0x0000)
+#define PTT_SRV_NAME	__constant_htons(0x0101)
+#define PTT_AC_NAME	__constant_htons(0x0102)
+#define PTT_HOST_UNIQ	__constant_htons(0x0103)
+#define PTT_AC_COOKIE	__constant_htons(0x0104)
+#define PTT_VENDOR 	__constant_htons(0x0105)
+#define PTT_RELAY_SID	__constant_htons(0x0110)
+#define PTT_SRV_ERR     __constant_htons(0x0201)
+#define PTT_SYS_ERR  	__constant_htons(0x0202)
+#define PTT_GEN_ERR  	__constant_htons(0x0203)
+
+struct pppoe_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 ver : 4;
+	__u8 type : 4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8 type : 4;
+	__u8 ver : 4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8 code;
+	__u16 sid;
+	__u16 length;
+	struct pppoe_tag tag[0];
+} __attribute__ ((packed));
+
+#ifdef __KERNEL__
+
+struct pppox_proto {
+	int (*create)(struct socket *sock);
+	int (*ioctl)(struct socket *sock, unsigned int cmd,
+		     unsigned long arg);
+};
+
+extern int register_pppox_proto(int proto_num, struct pppox_proto *pp);
+extern void unregister_pppox_proto(int proto_num);
+extern void pppox_unbind_sock(struct sock *sk);/* delete ppp-channel binding */
+extern int pppox_channel_ioctl(struct ppp_channel *pc, unsigned int cmd,
+			       unsigned long arg);
+
+/* PPPoX socket states */
+enum {
+    PPPOX_NONE		= 0,  /* initial state */
+    PPPOX_CONNECTED	= 1,  /* connection established ==TCP_ESTABLISHED */
+    PPPOX_BOUND		= 2,  /* bound to ppp device */
+    PPPOX_RELAY		= 4,  /* forwarding is enabled */
+    PPPOX_ZOMBIE	= 8,  /* dead, but still bound to ppp device */
+    PPPOX_DEAD		= 16  /* dead, useless, please clean me up!*/
+};
+
+extern struct ppp_channel_ops pppoe_chan_ops;
+
+extern int pppox_proto_init(struct net_proto *np);
+
+#endif /* __KERNEL__ */
+
+#endif /* !(__LINUX_IF_PPPOX_H) */
diff -BurpN rp-l2tp-0.4/handlers/sync-pppd.c rp-l2tp/handlers/sync-pppd.c
--- rp-l2tp-0.4/handlers/sync-pppd.c	2009-08-31 06:07:49.000000000 +0000
+++ rp-l2tp/handlers/sync-pppd.c	2009-08-31 06:08:17.000000000 +0000
@@ -22,6 +22,10 @@ static char const RCSID[] =
 #include <stdio.h>
 #include <string.h>
 #include <fcntl.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/if_pppol2tp.h>
+#include <linux/if_pppox.h>
 
 #define HANDLER_NAME "sync-pppd"
 
@@ -41,6 +45,7 @@ static char *pppd_lac_options[MAX_OPTS+1
 static int num_pppd_lns_options = 0;
 static int num_pppd_lac_options = 0;
 static int use_unit_option = 0;
+static int kernel_mode = 1;
 static char *pppd_path = NULL;
 
 #define PUSH_LNS_OPT(x) pppd_lns_options[num_pppd_lns_options++] = (x)
@@ -71,6 +76,7 @@ static l2tp_opt_descriptor my_opts[] = {
     { "lac-pppd-opts",     OPT_TYPE_CALLFUNC,   (void *) handle_lac_opts},
     { "lns-pppd-opts",     OPT_TYPE_CALLFUNC,   (void *) handle_lns_opts},
     { "set-ppp-if-name",   OPT_TYPE_BOOL,       &use_unit_option},
+    { "kernel-mode",       OPT_TYPE_BOOL,       &kernel_mode},
     { "pppd-path",         OPT_TYPE_STRING,     &pppd_path},
     { NULL,                OPT_TYPE_BOOL,       NULL }
 };
@@ -152,7 +158,9 @@ handle_frame(l2tp_session *ses,
     len += 2;
 
     /* TODO: Add error checking */
-    n = write(sl->fd, buf, len);
+    if (sl->fd < 0) {
+        l2tp_set_errmsg("Attempt to write %d bytes to non existent fd.", len);
+    } else n = write(sl->fd, buf, len);
 }
 
 /**********************************************************************
@@ -176,10 +184,10 @@ close_session(l2tp_session *ses, char co
     ses->private = NULL;
     sl->ses = NULL;
 
-    kill(SIGTERM, sl->pid);
-    close(sl->fd);
+    kill(sl->pid, SIGTERM);
+    if (sl->fd >= 0) close(sl->fd);
     sl->fd = -1;
-    Event_DelHandler(sl->es, sl->event);
+    if (sl->event) Event_DelHandler(sl->es, sl->event);
     sl->event = NULL;
 
     /* Re-establish session if desired */
@@ -286,12 +294,13 @@ readable(EventSelector *es, int fd, unsi
 static int
 establish_session(l2tp_session *ses)
 {
-    int m_pty, s_pty;
+    int m_pty = -1, s_pty;
+    struct sockaddr_pppol2tp sax;
     pid_t pid;
     EventSelector *es = ses->tunnel->es;
     struct slave *sl = malloc(sizeof(struct slave));
-    int i;
-    char unit[32];
+    int i, flags;
+    char unit[32], fdstr[10];
 
     ses->private = NULL;
     if (!sl) return -1;
@@ -299,10 +308,42 @@ establish_session(l2tp_session *ses)
     sl->es = es;
 
     /* Get pty */
+    if (kernel_mode) {
+        s_pty = socket(AF_PPPOX, SOCK_DGRAM, PX_PROTO_OL2TP);
+        if (s_pty < 0) {
+            l2tp_set_errmsg("Unable to allocate PPPoL2TP socket.");
+	    free(sl);
+            return -1;
+        }
+        flags = fcntl(s_pty, F_GETFL);
+        if (flags == -1 || fcntl(s_pty, F_SETFL, flags | O_NONBLOCK) == -1) {
+            l2tp_set_errmsg("Unable to set PPPoL2TP socket nonblock.");
+	    free(sl);
+            return -1;
+        }
+        sax.sa_family = AF_PPPOX;
+        sax.sa_protocol = PX_PROTO_OL2TP;
+        sax.pppol2tp.pid = 0;
+        sax.pppol2tp.fd = Sock;
+        sax.pppol2tp.addr.sin_addr.s_addr = ses->tunnel->peer_addr.sin_addr.s_addr;
+        sax.pppol2tp.addr.sin_port = ses->tunnel->peer_addr.sin_port;
+        sax.pppol2tp.addr.sin_family = AF_INET;
+        sax.pppol2tp.s_tunnel  = ses->tunnel->my_id;
+        sax.pppol2tp.s_session = ses->my_id;
+        sax.pppol2tp.d_tunnel  = ses->tunnel->assigned_id;
+        sax.pppol2tp.d_session = ses->assigned_id;
+        if (connect(s_pty, (struct sockaddr *)&sax, sizeof(sax)) < 0) {
+            l2tp_set_errmsg("Unable to connect PPPoL2TP socket.");
+	    free(sl);
+            return -1;
+        }
+	snprintf (fdstr, sizeof(fdstr), "%d", s_pty);
+    } else {
     if (pty_get(&m_pty, &s_pty) < 0) {
 	free(sl);
 	return -1;
     }
+    }
 
     /* Fork */
     pid = fork();
@@ -312,8 +352,6 @@ establish_session(l2tp_session *ses)
     }
 
     if (pid) {
-	int flags;
-
 	/* In the parent */
 	sl->pid = pid;
 
@@ -325,13 +363,16 @@ establish_session(l2tp_session *ses)
 
 	sl->fd = m_pty;
 
-	/* Set slave FD non-blocking */
-	flags = fcntl(sl->fd, F_GETFL);
-	if (flags >= 0) fcntl(sl->fd, F_SETFL, (long) flags | O_NONBLOCK);
+	if (!kernel_mode) {
+            /* Set slave FD non-blocking */
+	    flags = fcntl(sl->fd, F_GETFL);
+	    if (flags >= 0) fcntl(sl->fd, F_SETFL, (long) flags | O_NONBLOCK);
 
-	/* Handle readability on slave end */
-	sl->event = Event_AddHandler(es, m_pty, EVENT_FLAG_READABLE,
+	    /* Handle readability on slave end */
+	    sl->event = Event_AddHandler(es, m_pty, EVENT_FLAG_READABLE,
 			 readable, ses);
+	} else
+	    sl->event = NULL;
 
 	ses->private = sl;
 	return 0;
@@ -344,9 +385,11 @@ establish_session(l2tp_session *ses)
     }
 
     /* Dup s_pty onto stdin and stdout */
-    dup2(s_pty, 0);
-    dup2(s_pty, 1);
-    if (s_pty > 1) close(s_pty);
+    if (!kernel_mode) {
+    	dup2(s_pty, 0);
+    	dup2(s_pty, 1);
+        if (s_pty > 1) close(s_pty);
+    }
 
     /* Create unit */
     sprintf(unit, "%d", (int) getpid());
@@ -359,6 +402,13 @@ establish_session(l2tp_session *ses)
 	    PUSH_LAC_OPT("unit");
 	    PUSH_LAC_OPT(unit);
 	}
+	/* Push plugin options */
+	if (kernel_mode && num_pppd_lac_options <= MAX_OPTS-4) {
+	    PUSH_LAC_OPT("plugin");
+	    PUSH_LAC_OPT("pppol2tp.so");
+	    PUSH_LAC_OPT("pppol2tp");
+	    PUSH_LAC_OPT(fdstr);
+	}
         /* push peer specific options */
         lac_opt = ses->tunnel->peer->lac_options;
         while (*lac_opt) {
@@ -382,6 +432,14 @@ establish_session(l2tp_session *ses)
 	    PUSH_LNS_OPT("unit");
 	    PUSH_LNS_OPT(unit);
 	}
+	/* Push plugin options */
+	if (kernel_mode && num_pppd_lac_options <= MAX_OPTS-5) {
+	    PUSH_LNS_OPT("plugin");
+	    PUSH_LNS_OPT("pppol2tp.so");
+	    PUSH_LNS_OPT("pppol2tp");
+	    PUSH_LNS_OPT(fdstr);
+	    PUSH_LNS_OPT("pppol2tp_lns_mode");
+	}
         /* push peer specific options */
         lns_opt = ses->tunnel->peer->lns_options;
         while (*lns_opt) {
