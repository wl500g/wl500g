--- oldlinux/drivers/usb/serial/ftdi_sio.c	2008-03-30 14:00:43.000000000 +0200
+++ linux/drivers/usb/serial/ftdi_sio.c	2008-05-01 19:46:50.000000000 +0200
@@ -10,20 +10,23 @@
  * 	This program is free software; you can redistribute it and/or modify
  * 	it under the terms of the GNU General Public License as published by
  * 	the Free Software Foundation; either version 2 of the License, or
  * 	(at your option) any later version.
  *
  * See Documentation/usb/usb-serial.txt for more information on using this driver
  *
  * See http://ftdi-usb-sio.sourceforge.net for upto date testing info
  *	and extra documentation
  *
+ * (2/Feb/2006) ST
+ *      Added support for the 232R chip.
+ *
  * (10/Mar/2004) Jan Capek
  *      Added PID's for ICD-U20/ICD-U40 - incircuit PIC debuggers from CCS Inc.
  *
  * (09/Feb/2004) Ian Abbott
  *      Changed full name of USB-UIRT device to avoid "/" character.
  *      Added FTDI's alternate PID (0x6006) for FT232/245 devices.
  *      Added PID for "ELV USB Module UO100" from Stefan Frings.
  * 
  * (21/Oct/2003) Ian Abbott
  *      Renamed some VID/PID macros for Matrix Orbital and Perle Systems
@@ -246,21 +249,21 @@
 #else
 	static int debug;
 #endif
 
 #include "usb-serial.h"
 #include "ftdi_sio.h"
 
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v1.3.5"
+#define DRIVER_VERSION "v1.3.5r1"
 #define DRIVER_AUTHOR "Greg Kroah-Hartman <greg@kroah.com>, Bill Ryder <bryder@sgi.com>, Kuba Ober <kuba@mareimbrium.org>"
 #define DRIVER_DESC "USB FTDI Serial Converters Driver"
 
 static struct usb_device_id id_table_sio [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_SIO_PID) },
 	{ }						/* Terminating entry */
 };
 
 /*
  * The 8U232AM has the same API as the sio except for:
@@ -473,20 +476,29 @@
 	{ USB_DEVICE_VER(FALCOM_VID, FALCOM_TWIST_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_SUUNTO_SPORTS_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_RM_CANVIEW_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(BANDB_VID, BANDB_USOTL4_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(BANDB_VID, BANDB_USTL4_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(BANDB_VID, BANDB_USO9ML2_PID, 0x400, 0xffff) },
 	{ USB_DEVICE_VER(FTDI_VID, EVER_ECO_PRO_CDS, 0x400, 0xffff) },
 	{ }						/* Terminating entry */
 };
 
+static struct usb_device_id id_table_FT2232C[] = {
+	{ USB_DEVICE_VER(FTDI_VID, FTDI_8U2232C_PID, 0x500, 0xffff) },
+	{ }						/* Terminating entry */
+};
+
+static struct usb_device_id id_table_FT232R[] = {
+	{ USB_DEVICE_VER(FTDI_VID, FTDI_8U232AM_PID, 0x600, 0xffff) },
+	{ }						/* Terminating entry */
+};
 
 static struct usb_device_id id_table_USB_UIRT [] = {
 	{ USB_DEVICE(FTDI_VID, FTDI_USB_UIRT_PID) },
 	{ }						/* Terminating entry */
 };
 
 
 static struct usb_device_id id_table_HE_TIRA1 [] = {
 	{ USB_DEVICE_VER(FTDI_VID, FTDI_HE_TIRA1_PID, 0x400, 0xffff) },
 	{ }						/* Terminating entry */
@@ -642,40 +654,43 @@
 	int custom_divisor;	/* custom_divisor kludge, this is for baud_base (different from what goes to the chip!) */
 	__u16 last_set_data_urb_value ;
 				/* the last data state set - needed for doing a break */
         int write_offset;       /* This is the offset in the usb data block to write the serial data - 
 				 * it is different between devices
 				 */
 	int flags;		/* some ASYNC_xxxx flags are supported */
 	unsigned long last_dtr_rts;	/* saved modem control outputs */
         wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
  	char prev_status, diff_status;        /* Used for TIOCMIWAIT */
+	__u16 interface;		/* FT2232C */
 
 	struct urb	*write_urb_pool[NUM_URBS];
 	spinlock_t	write_urb_pool_lock;
 
 	int force_baud;		/* if non-zero, force the baud rate to this value */
 	int force_rtscts;	/* if non-zero, force RTS-CTS to always be enabled */
 };
 
 /* Used for TIOCMIWAIT */
 #define FTDI_STATUS_B0_MASK	(FTDI_RS0_CTS | FTDI_RS0_DSR | FTDI_RS0_RI | FTDI_RS0_RLSD)
 #define FTDI_STATUS_B1_MASK	(FTDI_RS_BI)
 /* End TIOCMIWAIT */
 
 #define FTDI_IMPL_ASYNC_FLAGS = ( ASYNC_SPD_HI | ASYNC_SPD_VHI \
  ASYNC_SPD_CUST | ASYNC_SPD_SHI | ASYNC_SPD_WARP )
 
 /* function prototypes for a FTDI serial converter */
 static int  ftdi_SIO_startup		(struct usb_serial *serial);
 static int  ftdi_8U232AM_startup	(struct usb_serial *serial);
 static int  ftdi_FT232BM_startup	(struct usb_serial *serial);
+static int  ftdi_FT2232C_startup	(struct usb_serial *serial);
+static int  ftdi_FT232R_startup		(struct usb_serial *serial);
 static int  ftdi_USB_UIRT_startup	(struct usb_serial *serial);
 static int  ftdi_HE_TIRA1_startup	(struct usb_serial *serial);
 static int  ftdi_userdev_startup	(struct usb_serial *serial);
 static void ftdi_shutdown		(struct usb_serial *serial);
 static int  ftdi_open			(struct usb_serial_port *port, struct file *filp);
 static void ftdi_close			(struct usb_serial_port *port, struct file *filp);
 static int  ftdi_write			(struct usb_serial_port *port, int from_user, const unsigned char *buf, int count);
 static int  ftdi_write_room		(struct usb_serial_port *port);
 static int  ftdi_chars_in_buffer	(struct usb_serial_port *port);
 static void ftdi_write_bulk_callback	(struct urb *urb);
@@ -756,20 +771,68 @@
 	.chars_in_buffer =	ftdi_chars_in_buffer,
 	.read_bulk_callback =	ftdi_read_bulk_callback,
 	.write_bulk_callback =	ftdi_write_bulk_callback,
 	.ioctl =		ftdi_ioctl,
 	.set_termios =		ftdi_set_termios,
 	.break_ctl =		ftdi_break_ctl,
 	.startup =		ftdi_FT232BM_startup,
 	.shutdown =		ftdi_shutdown,
 };
 
+static struct usb_serial_device_type ftdi_FT2232C_device = {
+	.owner =		THIS_MODULE,
+	.name =			"FTDI FT2232C Compatible",
+	.id_table =		id_table_FT2232C,
+	.num_interrupt_in =	0,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			ftdi_open,
+	.close =		ftdi_close,
+	.throttle =		ftdi_throttle,
+	.unthrottle =		ftdi_unthrottle,
+	.write =		ftdi_write,
+	.write_room =		ftdi_write_room,
+	.chars_in_buffer =	ftdi_chars_in_buffer,
+	.read_bulk_callback =	ftdi_read_bulk_callback,
+	.write_bulk_callback =	ftdi_write_bulk_callback,
+	.ioctl =		ftdi_ioctl,
+	.set_termios =		ftdi_set_termios,
+	.break_ctl =		ftdi_break_ctl,
+	.startup =		ftdi_FT2232C_startup,
+	.shutdown =		ftdi_shutdown,
+};
+
+static struct usb_serial_device_type ftdi_FT232R_device = {
+	.owner =		THIS_MODULE,
+	.name =			"FTDI FT232R Compatible",
+	.id_table =		id_table_FT232R,
+	.num_interrupt_in =	0,
+	.num_bulk_in =		1,
+	.num_bulk_out =		1,
+	.num_ports =		1,
+	.open =			ftdi_open,
+	.close =		ftdi_close,
+	.throttle =		ftdi_throttle,
+	.unthrottle =		ftdi_unthrottle,
+	.write =		ftdi_write,
+	.write_room =		ftdi_write_room,
+	.chars_in_buffer =	ftdi_chars_in_buffer,
+	.read_bulk_callback =	ftdi_read_bulk_callback,
+	.write_bulk_callback =	ftdi_write_bulk_callback,
+	.ioctl =		ftdi_ioctl,
+	.set_termios =		ftdi_set_termios,
+	.break_ctl =		ftdi_break_ctl,
+	.startup =		ftdi_FT232R_startup,
+	.shutdown =		ftdi_shutdown,
+};
+
 static struct usb_serial_device_type ftdi_USB_UIRT_device = {
 	.owner =		THIS_MODULE,
 	.name =			"USB-UIRT Infrared Tranceiver",
 	.id_table =		id_table_USB_UIRT,
 	.num_interrupt_in =	0,
 	.num_bulk_in =		1,
 	.num_bulk_out =		1,
 	.num_ports =		1,
 	.open =			ftdi_open,
 	.close =		ftdi_close,
@@ -893,59 +956,68 @@
 		ftdi_high_or_low = FTDI_SIO_SET_RTS_HIGH;
 		priv->last_dtr_rts |= TIOCM_RTS;
 	} else {
 		ftdi_high_or_low = FTDI_SIO_SET_RTS_LOW;
 		priv->last_dtr_rts &= ~TIOCM_RTS;
 	}
 	return(usb_control_msg(port->serial->dev,
 			       usb_sndctrlpipe(port->serial->dev, 0),
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST, 
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE,
-			       ftdi_high_or_low, 0, 
+			       ftdi_high_or_low, priv->interface, 
 			       buf, 0, WDR_TIMEOUT));
 }
 
 
 static int set_dtr(struct usb_serial_port *port, int high_or_low)
 {
 	struct ftdi_private * priv = (struct ftdi_private *)port->private;
 	char buf[1];
 	unsigned ftdi_high_or_low;
 	if (high_or_low) {
 		ftdi_high_or_low = FTDI_SIO_SET_DTR_HIGH;
 		priv->last_dtr_rts |= TIOCM_DTR;
 	} else {
 		ftdi_high_or_low = FTDI_SIO_SET_DTR_LOW;
 		priv->last_dtr_rts &= ~TIOCM_DTR;
 	}
 	return(usb_control_msg(port->serial->dev,
 			       usb_sndctrlpipe(port->serial->dev, 0),
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST, 
 			       FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE,
-			       ftdi_high_or_low, 0, 
+			       ftdi_high_or_low, priv->interface, 
 			       buf, 0, WDR_TIMEOUT));
 }
 
 
 static __u32 get_ftdi_divisor(struct usb_serial_port * port);
 
 
 static int change_speed(struct usb_serial_port *port)
 {
 	char buf[1];
+	struct ftdi_private * priv = (struct ftdi_private *)port->private;
         __u16 urb_value;
 	__u16 urb_index;
 	__u32 urb_index_value;
 
 	urb_index_value = get_ftdi_divisor(port);
 	urb_value = (__u16)urb_index_value;
-	urb_index = (__u16)(urb_index_value >> 16);
+
+	if(priv->chip_type == FT2232C) {
+		urb_index = (__u16)(urb_index_value >> 8);
+		urb_index &= 0xFF00;
+		urb_index |= priv->interface;
+	} else {
+		urb_index = (__u16)(urb_index_value >> 16);
+		urb_index |= priv->interface;
+	}	
 	
 	return (usb_control_msg(port->serial->dev,
 			    usb_sndctrlpipe(port->serial->dev, 0),
 			    FTDI_SIO_SET_BAUDRATE_REQUEST,
 			    FTDI_SIO_SET_BAUDRATE_REQUEST_TYPE,
 			    urb_value, urb_index,
 			    buf, 0, 100) < 0);
 }
 
 
@@ -1023,21 +1095,29 @@
 		chip_name = "FT8U232AM";
 		if (baud <= 3000000) {
 			div_value = ftdi_232am_baud_to_divisor(baud);
 		} else {
 	                dbg("%s - Baud rate too high!", __FUNCTION__);
 			div_value = ftdi_232am_baud_to_divisor(9600);
 			div_okay = 0;
 		}
 		break;
 	case FT232BM: /* FT232BM chip */
-		chip_name = "FT232BM";
+	case FT2232C: /* FT2232C chip */
+	case FT232R: /* FT232R chip */
+		if (priv->chip_type == FT232R) {
+			chip_name = "FT232R";
+		} else if (priv->chip_type == FT2232C) {
+			chip_name = "FT2232C";
+		} else {
+			chip_name = "FT232BM";
+		}
 		if (baud <= 3000000) {
 			div_value = ftdi_232bm_baud_to_divisor(baud);
 		} else {
 	                dbg("%s - Baud rate too high!", __FUNCTION__);
 			div_value = ftdi_232bm_baud_to_divisor(9600);
 			div_okay = 0;
 		}
 		break;
 	} /* priv->chip_type */
 
@@ -1142,21 +1222,21 @@
 	struct urb *urb; 
 	
 	dbg("%s",__FUNCTION__);
 
 	priv = kmalloc(sizeof(struct ftdi_private), GFP_KERNEL);
 	if (!priv){
 		err("%s- kmalloc(%Zd) failed.", __FUNCTION__, sizeof(struct ftdi_private));
 		return -ENOMEM;
 	}
 	memset(priv, 0, sizeof(*priv));
-
+	
         init_waitqueue_head(&priv->delta_msr_wait);
 	/* This will push the characters through immediately rather
 	   than queue a task to deliver them */
 	priv->flags = ASYNC_LOW_LATENCY;
 
 	/* Increase the size of read buffers */
 	if (port->bulk_in_buffer) {
 		kfree (port->bulk_in_buffer);
 	}
 	port->bulk_in_buffer = kmalloc (BUFSZ, GFP_KERNEL);
@@ -1264,20 +1344,69 @@
 		return (err);
 	}
 
 	priv = serial->port->private;
 	priv->chip_type = FT232BM;
 	priv->baud_base = 48000000 / 2; /* Would be / 16, but FT232BM supports multiple of 0.125 divisor fractions! */
 	
 	return (0);
 } /* ftdi_FT232BM_startup */
 
+/* Startup for the FT2232C chip */
+/* Called from usbserial:serial_probe */
+static int ftdi_FT2232C_startup (struct usb_serial *serial)
+{ /* ftdi_FT2232C_startup */
+	struct ftdi_private *priv;
+	int err;
+	int inter;
+
+	dbg("%s",__FUNCTION__);
+	err = ftdi_common_startup(serial);
+	if (err){
+		return (err);
+	}
+
+	priv = serial->port->private;
+	priv->chip_type = FT2232C;
+	inter = serial->interface->altsetting->bInterfaceNumber;
+
+	if(inter) {
+		priv->interface = INTERFACE_B;
+	}
+	else  {
+		priv->interface = INTERFACE_A;
+	}
+	priv->baud_base = 48000000 / 2; /* Would be / 16, but FT232BM supports multiple of 0.125 divisor fractions! */
+	
+	return (0);
+} /* ftdi_FT2232C_startup */
+
+/* Startup for the FT232R chip */
+/* Called from usbserial:serial_probe */
+static int ftdi_FT232R_startup (struct usb_serial *serial)
+{ /* ftdi_FT232R_startup */
+	struct ftdi_private *priv;
+	int err;
+
+	dbg("%s",__FUNCTION__);
+	err = ftdi_common_startup(serial);
+	if (err){
+		return (err);
+	}
+
+	priv = serial->port->private;
+	priv->chip_type = FT232R;
+	priv->baud_base = 48000000 / 2; /* Would be / 16, but FT232BM supports multiple of 0.125 divisor fractions! */
+	
+	return (0);
+} /* ftdi_FT232R_startup */
+
 /* Startup for the USB-UIRT device, which requires hardwired baudrate (38400 gets mapped to 312500) */
 /* Called from usbserial:serial_probe */
 static int ftdi_USB_UIRT_startup (struct usb_serial *serial)
 { /* ftdi_USB_UIRT_startup */
 	struct ftdi_private *priv;
 	int err;
 
 	dbg("%s",__FUNCTION__);
 	err = ftdi_8U232AM_startup(serial);
 	if (err){
@@ -1400,21 +1529,21 @@
 	dbg("%s", __FUNCTION__);
 
 
 	port->tty->low_latency = (priv->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
 
 	/* No error checking for this (will get errors later anyway) */
 	/* See ftdi_sio.h for description of what is reset */
 	usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			FTDI_SIO_RESET_REQUEST, FTDI_SIO_RESET_REQUEST_TYPE, 
 			FTDI_SIO_RESET_SIO, 
-			0, buf, 0, WDR_TIMEOUT);
+			priv->interface, buf, 0, WDR_TIMEOUT);
 
 	/* Termios defaults are set by usb_serial_init. We don't change
 	   port->tty->termios - this would loose speed settings, etc.
 	   This is same behaviour as serial.c/rs_open() - Kuba */
 
 	/* ftdi_set_termios  will send usb control messages */
 	ftdi_set_termios(port, &tmp_termios);
 
 	/* FIXME: Flow control might be enabled, so it should be checked -
 	   we have no control of defaults! */
@@ -1446,37 +1575,38 @@
  *
  *   This only gets called when it is the last close
  *   
  *   
  */
 
 static void ftdi_close (struct usb_serial_port *port, struct file *filp)
 { /* ftdi_close */
 	struct usb_serial *serial;
 	unsigned int c_cflag = port->tty->termios->c_cflag;
+	struct ftdi_private *priv = (struct ftdi_private *)port->private;
 	char buf[1];
 	int err;
 
 	dbg("%s", __FUNCTION__);
 
 	serial = get_usb_serial ( port, __FUNCTION__);
 	if (!serial)
 		return;
 
 	if (serial->dev) {
 		if (c_cflag & HUPCL){
 			/* Disable flow control */
 			if (usb_control_msg(serial->dev, 
 					    usb_sndctrlpipe(serial->dev, 0),
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST,
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-					    0, 0, buf, 0, WDR_TIMEOUT) < 0) {
+					    0, priv->interface, buf, 0, WDR_TIMEOUT) < 0) {
 				err("error from flowcontrol urb");
 			}	    
 
 			/* drop DTR */
 			if (set_dtr(port, LOW) < 0){
 				err("Error from DTR LOW urb");
 			}
 			/* drop RTS */
 			if (set_rts(port, LOW) < 0) {
 				err("Error from RTS LOW urb");
@@ -1875,21 +2005,21 @@
 	if (break_state) {
 		urb_value = priv->last_set_data_urb_value | FTDI_SIO_SET_BREAK;
 	} else {
 		urb_value = priv->last_set_data_urb_value; 
 	}
 
 	
 	if (usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			    FTDI_SIO_SET_DATA_REQUEST, 
 			    FTDI_SIO_SET_DATA_REQUEST_TYPE,
-			    urb_value , 0,
+			    urb_value , priv->interface,
 			    buf, 0, WDR_TIMEOUT) < 0) {
 		err("%s FAILED to enable/disable break state (state was %d)", __FUNCTION__,break_state);
 	}	   
 
 	dbg("%s break state is %d - urb is %d", __FUNCTION__,break_state, urb_value);
 	
 }
 
 
 /* old_termios contains the original termios settings and tty->termios contains
@@ -1954,32 +2084,32 @@
 		}
 	}
 
 	/* This is needed by the break command since it uses the same command - but is
 	 *  or'ed with this value  */
 	priv->last_set_data_urb_value = urb_value;
 	
 	if (usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 			    FTDI_SIO_SET_DATA_REQUEST, 
 			    FTDI_SIO_SET_DATA_REQUEST_TYPE,
-			    urb_value , 0,
+			    urb_value, priv->interface,
 			    buf, 0, 100) < 0) {
 		err("%s FAILED to set databits/stopbits/parity", __FUNCTION__);
 	}	   
 
 	/* Now do the baudrate */
 	if ((cflag & CBAUD) == B0 ) {
 		/* Disable flow control */
 		if (usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-				    0, 0, 
+				    0, priv->interface, 
 				    buf, 0, WDR_TIMEOUT) < 0) {
 			err("%s error from disable flowcontrol urb", __FUNCTION__);
 		}	    
 		/* Drop RTS and DTR */
 		if (set_dtr(port, LOW) < 0){
 			err("%s Error from DTR LOW urb", __FUNCTION__);
 		}
 		if (set_rts(port, LOW) < 0){
 			err("%s Error from RTS LOW urb", __FUNCTION__);
 		}	
@@ -1999,21 +2129,21 @@
 	}
 
 	/* Set flow control */
 	/* Note device also supports DTR/CD (ugh) and Xon/Xoff in hardware */
 	if (cflag & CRTSCTS) {
 		dbg("%s Setting to CRTSCTS flow control", __FUNCTION__);
 		if (usb_control_msg(serial->dev, 
 				    usb_sndctrlpipe(serial->dev, 0),
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
 				    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-				    0 , FTDI_SIO_RTS_CTS_HS,
+				    0 , (FTDI_SIO_RTS_CTS_HS | priv->interface),
 				    buf, 0, WDR_TIMEOUT) < 0) {
 			err("urb failed to set to rts/cts flow control");
 		}		
 		
 	} else { 
 		/*
 		 * Xon/Xoff code
 		 *
 		 * Check the IXOFF status in the iflag component of the termios structure
 		 * if IXOFF is not set, the pre-xon/xoff code is executed.
@@ -2025,33 +2155,33 @@
 			// a lot of other dereferencing is done but that would be very
 			// inefficient as vstart and vstop are not always needed
 			vstart=port->tty->termios->c_cc[VSTART];
 			vstop=port->tty->termios->c_cc[VSTOP];
 			urb_value=(vstop << 8) | (vstart);
 
 			if (usb_control_msg(serial->dev,
 					    usb_sndctrlpipe(serial->dev, 0),
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST,
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-					    urb_value , FTDI_SIO_XON_XOFF_HS,
+					    urb_value , (FTDI_SIO_XON_XOFF_HS | priv->interface),
 					    buf, 0, WDR_TIMEOUT) < 0) {
 				err("urb failed to set to xon/xoff flow control");
 			}
 		} else {
 			/* else clause to only run if cfag ! CRTSCTS and iflag ! XOFF */
 			/* CHECKME Assuming XON/XOFF handled by tty stack - not by device */
 			dbg("%s Turning off hardware flow control", __FUNCTION__);
 			if (usb_control_msg(serial->dev, 
 					    usb_sndctrlpipe(serial->dev, 0),
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST, 
 					    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,
-					    0, 0, 
+					    0, priv->interface, 
 					    buf, 0, WDR_TIMEOUT) < 0) {
 				err("urb failed to clear flow control");
 			}				
 		}
 		
 	}
 	return;
 } /* ftdi_termios */
 
 
@@ -2071,36 +2201,36 @@
 
 	case TIOCMGET:
 		dbg("%s TIOCMGET", __FUNCTION__);
 		switch (priv->chip_type) {
 		case SIO:
 			/* Request the status from the device */
 			if ((ret = usb_control_msg(serial->dev, 
 						   usb_rcvctrlpipe(serial->dev, 0),
 						   FTDI_SIO_GET_MODEM_STATUS_REQUEST, 
 						   FTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,
-						   0, 0, 
+						   0, priv->interface, 
 						   buf, 1, WDR_TIMEOUT)) < 0 ) {
 				err("%s Could not get modem status of device - err: %d", __FUNCTION__,
 				    ret);
 				return(ret);
 			}
 			break;
 		case FT8U232AM:
 		case FT232BM:
 			/* the 8U232AM returns a two byte value (the sio is a 1 byte value) - in the same
 			   format as the data returned from the in point */
 			if ((ret = usb_control_msg(serial->dev, 
 						   usb_rcvctrlpipe(serial->dev, 0),
 						   FTDI_SIO_GET_MODEM_STATUS_REQUEST, 
 						   FTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,
-						   0, 0, 
+						   0, priv->interface, 
 						   buf, 2, WDR_TIMEOUT)) < 0 ) {
 				err("%s Could not get modem status of device - err: %d", __FUNCTION__,
 				    ret);
 				return(ret);
 			}
 			break;
 		default:
 			return -EFAULT;
 			break;
 		}
@@ -2263,20 +2393,22 @@
 		err("%s - failed submitting read urb, error %d", __FUNCTION__, result);
 }
 
 static int __init ftdi_init (void)
 {
 
 	dbg("%s", __FUNCTION__);
 	usb_serial_register (&ftdi_SIO_device);
 	usb_serial_register (&ftdi_8U232AM_device);
 	usb_serial_register (&ftdi_FT232BM_device);
+	usb_serial_register (&ftdi_FT2232C_device);
+	usb_serial_register (&ftdi_FT232R_device);
 	usb_serial_register (&ftdi_USB_UIRT_device);
 	usb_serial_register (&ftdi_HE_TIRA1_device);
 
 	if (vendor != -1) {
 		/* User specified USB vendor and device id */
 		/* The macro initialized "matchvendor" as the matching flags */
 		id_table_userdev[0].idVendor = vendor; 
 		id_table_userdev[0].idProduct = product;
 		usb_serial_register (&ftdi_userdev_device);
 	}
@@ -2289,20 +2421,22 @@
 
 static void __exit ftdi_exit (void)
 {
 
 	dbg("%s", __FUNCTION__);
 
 	if (vendor != -1)
 		usb_serial_deregister (&ftdi_userdev_device);
 	usb_serial_deregister (&ftdi_HE_TIRA1_device);
 	usb_serial_deregister (&ftdi_USB_UIRT_device);
+	usb_serial_deregister (&ftdi_FT232R_device);
+	usb_serial_deregister (&ftdi_FT2232C_device);
 	usb_serial_deregister (&ftdi_FT232BM_device);
 	usb_serial_deregister (&ftdi_8U232AM_device);
 	usb_serial_deregister (&ftdi_SIO_device);
 
 }
 
 
 module_init(ftdi_init);
 module_exit(ftdi_exit);
 
--- oldlinux/drivers/usb/serial/ftdi_sio.h	2008-03-30 14:00:43.000000000 +0200
+++ linux/drivers/usb/serial/ftdi_sio.h	2008-05-01 19:46:50.000000000 +0200
@@ -19,20 +19,21 @@
  *
  * Philipp G¦hring - pg@futureware.at - added the Device ID of the USB relais
  * from Rudolf Gugler
  *
  */
 
 #define FTDI_VID	0x0403	/* Vendor Id */
 #define FTDI_SIO_PID	0x8372	/* Product Id SIO application of 8U100AX  */
 #define FTDI_8U232AM_PID 0x6001 /* Similar device to SIO above */
 #define FTDI_8U232AM_ALT_PID 0x6006 /* FTDI's alternate PID for above */
+#define FTDI_8U2232C_PID 0x6010 /* Dual channel device */
 #define FTDI_RELAIS_PID	0xFA10  /* Relais device from Rudolf Gugler */
 #define FTDI_NF_RIC_VID	0x0DCD	/* Vendor Id */
 #define FTDI_NF_RIC_PID	0x0001	/* Product Id */
 
 /* www.irtrans.de device */
 #define FTDI_IRTRANS_PID 0xFC60 /* Product Id */
 
 /* www.crystalfontz.com devices - thanx for providing free devices for evaluation ! */
 /* they use the ftdi chipset for the USB interface and the vendor id is the same */
 #define FTDI_XF_632_PID 0xFC08	/* 632: 16x2 Character Display */
@@ -250,20 +251,23 @@
 /* Commands */
 #define FTDI_SIO_RESET 		0 /* Reset the port */
 #define FTDI_SIO_MODEM_CTRL 	1 /* Set the modem control register */
 #define FTDI_SIO_SET_FLOW_CTRL	2 /* Set flow control register */
 #define FTDI_SIO_SET_BAUD_RATE	3 /* Set baud rate */
 #define FTDI_SIO_SET_DATA	4 /* Set the data characteristics of the port */
 #define FTDI_SIO_GET_MODEM_STATUS	5 /* Retrieve current value of modern status register */
 #define FTDI_SIO_SET_EVENT_CHAR	6 /* Set the event character */
 #define FTDI_SIO_SET_ERROR_CHAR	7 /* Set the error character */
 
+#define INTERFACE_A		1
+#define INTERFACE_B		2
+
 /* Port Identifier Table */
 #define PIT_DEFAULT 		0 /* SIOA */
 #define PIT_SIOA		1 /* SIOA */
 /* The device this driver is tested with one has only one port */
 #define PIT_SIOB		2 /* SIOB */
 #define PIT_PARALLEL		3 /* Parallel */
 
 /* FTDI_SIO_RESET */
 #define FTDI_SIO_RESET_REQUEST FTDI_SIO_RESET
 #define FTDI_SIO_RESET_REQUEST_TYPE 0x40
@@ -349,20 +353,22 @@
  * rates.  If the calculated divisor value is 1, this needs to be replaced with
  * 0.  Additionally for the FT232BM, if the calculated divisor value is 0x4001
  * (1.5), this needs to be replaced with 0x0001 (1) (but this divisor value is
  * not supported by the FT8U232AM).
  */
 
 typedef enum {
 	SIO = 1,
 	FT8U232AM = 2,
 	FT232BM = 3,
+	FT2232C = 4,
+	FT232R = 5
 } ftdi_chip_type_t;
 
 typedef enum {
  ftdi_sio_b300 = 0, 
  ftdi_sio_b600 = 1, 
  ftdi_sio_b1200 = 2,
  ftdi_sio_b2400 = 3,
  ftdi_sio_b4800 = 4,
  ftdi_sio_b9600 = 5,
  ftdi_sio_b19200 = 6,
