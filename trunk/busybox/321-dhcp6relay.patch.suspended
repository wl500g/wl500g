diff -urNBp busybox/include/applets.src.h busybox.full/include/applets.src.h
--- busybox/include/applets.src.h	2011-09-26 15:51:25.000000000 +0400
+++ busybox.full/include/applets.src.h	2011-09-26 14:57:43.000000000 +0400
@@ -117,6 +117,7 @@ IF_DEVFSD(APPLET(devfsd, BB_DIR_SBIN, BB
 IF_DEVMEM(APPLET(devmem, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DF(APPLET(df, BB_DIR_BIN, BB_SUID_DROP))
 IF_DHCP6C(APPLET(dhcp6c, BB_DIR_SBIN, BB_SUID_DROP))
+IF_DHCP6RELAY(APPLET(dhcp6relay, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_DHCPRELAY(APPLET(dhcprelay, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_DIFF(APPLET(diff, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_DIRNAME(APPLET_NOFORK(dirname, dirname, BB_DIR_USR_BIN, BB_SUID_DROP, dirname))
diff -urNBp busybox/networking/udhcp/common6.c busybox.full/networking/udhcp/common6.c
--- busybox/networking/udhcp/common6.c	2011-09-26 18:24:15.000000000 +0400
+++ busybox.full/networking/udhcp/common6.c	2011-09-26 15:37:10.000000000 +0400
@@ -69,7 +69,7 @@ static int copy_option(uint16_t, uint16_
     struct dhcp6opt *, int *);
 static int in6_addrscopebyif(const struct in6_addr *, const char *);
 
-#if ENABLE_FEATURE_DHCP6_AUTH
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
 static int copyout_auth(struct dhcp6_optinfo *optinfo,
 		struct dhcp6opt **pp, struct dhcp6opt *bp, struct dhcp6opt *ep,
 		int *totallenp);
@@ -310,8 +310,44 @@ void dhcp6_vbuf_free(struct dhcp6_vbuf *
 	vbuf->dv_buf = NULL;
 }
 
+#if /* ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static int dhcp6_set_addr(int dh6optype, struct dhcp6_list *list,
+	       struct dhcp6opt **p, struct dhcp6opt *ep, int *len)
+{
+	struct in6_addr *in6;
+	struct dhcp6_listval *lv;
+	int optlen = 0;
+
+	if (TAILQ_EMPTY(list))
+		return 0;
+
+	TAILQ_FOREACH(lv, list, link) {
+		if (lv->dh6optype == dh6optype)
+			optlen += sizeof(struct in6_addr);
+	}
+	if (optlen == 0)
+		return 0;
+
+	in6 = (struct in6_addr *)(*p) + sizeof(struct dhcp6opt);
+	if ((void *)ep - (void *)(in6) < optlen)
+		bb_error_msg("option buffer short for %s", dhcp6optstr(dh6optype));
+
+	TAILQ_FOREACH(lv, list, link) {
+		if (lv->dh6optype != dh6optype)
+			continue;
+		memcpy(in6, &lv->val_addr6, sizeof(*in6));
+		in6++;
+	}
+	if (copy_option(dh6optype, optlen, NULL, p, ep, len) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
 /* Domain names stored in RFC1035 format */
-#if ENABLE_FEATURE_UDHCP_RFC3397
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY
 static int dhcp6_get_domain(int optlen, void *cp, int dh6optype,
 			    struct dhcp6_list *list)
 {
@@ -345,7 +381,59 @@ static int dhcp6_get_domain(int optlen, 
 
 	return 0;
 }
-#endif /* FEATURE_UDHCP_RFC3397 */
+#endif /* FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY */
+
+#if /* ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+static int dhcp6_set_domain(int dh6optype, struct dhcp6_list *list,
+			 struct dhcp6opt **p, struct dhcp6opt *ep, int *len)
+{
+	int optlen = 0;
+	struct dhcp6_listval *lv;
+	char *cp;
+
+	if (TAILQ_EMPTY(list))
+		return 0;
+	TAILQ_FOREACH(lv, list, link) {
+		if (lv->dh6optype == dh6optype)
+			++optlen;
+	}
+	if (optlen == 0)
+		/* No records in list with type specified */
+		return 0;
+
+	cp = (char *)(*p) + sizeof(struct dhcp6opt);
+	optlen = 0;
+	TAILQ_FOREACH(lv, list, link) {
+		int nlen;
+		uint8_t *name;
+
+		if (lv->dh6optype != dh6optype)
+			continue;
+
+		name = dname_enc(NULL, 0, (const char *)lv->val_vbuf.dv_buf, &nlen);
+		if (name == NULL) {
+			bb_error_msg("failed to encode a %s domain name",
+				dhcp6optstr(dh6optype));
+			return -1;
+		}
+		if ((char *)ep < cp + nlen) {
+			bb_error_msg("option buffer short for %s",
+				dhcp6optstr(dh6optype));
+			return -1;
+		}
+		memcpy(cp, name, nlen);
+		free(name);
+		cp += nlen;
+		optlen += nlen;
+	}
+
+	if (copy_option(dh6optype, optlen, NULL, p, ep, len) != 0) {
+		return -1;
+	}
+
+	return 0;
+}
+#endif
 
 struct dhcp6_event *dhcp6_create_event(struct dhcp6_if *ifp, int state)
 {
@@ -462,7 +462,7 @@ void dhcp6_remove_evdata(struct dhcp6_ev
 	}
 }
 
-#if ENABLE_FEATURE_DHCP6_AUTH
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
 struct authparam *new_authparam(int proto, int alg, int rdm)
 {
 	struct authparam *authparam;
@@ -728,6 +816,9 @@ void dhcp6_init_options(struct dhcp6_opt
 	TAILQ_INIT(&optinfo->reqopt_list);
 	TAILQ_INIT(&optinfo->stcode_list);
 	TAILQ_INIT(&optinfo->ad_list);
+#if 0 /* ENABLE_DHCP6S */
+	TAILQ_INIT(&optinfo->prefix_list);
+#endif
 
 	optinfo->authproto = -1;
 	optinfo->authalgorithm = -1;
@@ -749,6 +840,9 @@ void dhcp6_clear_options(struct dhcp6_op
 	dhcp6_clear_list(&optinfo->reqopt_list);
 	dhcp6_clear_list(&optinfo->stcode_list);
 	dhcp6_clear_list(&optinfo->ad_list);
+#if 0 /* ENABLE_DHCP6S */
+	dhcp6_clear_list(&optinfo->prefix_list);
+#endif
 
 	dhcp6_vbuf_free(&optinfo->relay_msg);
 	dhcp6_vbuf_free(&optinfo->ifidopt);
@@ -771,6 +865,9 @@ int dhcp6_copy_options(struct dhcp6_opti
 	dhcp6_copy_list(&dst->reqopt_list, &src->reqopt_list);
 	dhcp6_copy_list(&dst->stcode_list, &src->stcode_list);
 	dhcp6_copy_list(&dst->ad_list, &src->ad_list);
+#if 0 /* ENABLE_DHCP6S */
+	dhcp6_copy_list(&dst->prefix_list, &src->prefix_list);
+#endif
 
 	dst->rapidcommit = src->rapidcommit;
 	dst->elapsed_time = src->elapsed_time;
@@ -858,7 +956,7 @@ int dhcp6_get_options(struct dhcp6opt *p
 		struct in6_addr valaddr;
 	} u1 ALIGN4;
 	struct dhcp6_list sublist;
-#if ENABLE_FEATURE_DHCP6_AUTH
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
 	int authinfolen;
 #endif
 
@@ -964,7 +1062,7 @@ int dhcp6_get_options(struct dhcp6opt *p
 			memcpy(optinfo->relaymsg_msg, cp, optlen);
 			break;
 
-#if ENABLE_FEATURE_DHCP6_AUTH
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
 		case D6_OPT_AUTH:
 			/*
 			 * Any DHCP message that includes more than one
@@ -1028,7 +1126,7 @@ int dhcp6_get_options(struct dhcp6opt *p
 				goto fail;
 			}
 			break;
-#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+#endif /* ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY */
 
 		case D6_OPT_RAPID_COMMIT:
 			if (optlen != 0)
@@ -1047,7 +1145,7 @@ int dhcp6_get_options(struct dhcp6opt *p
 		case D6_OPT_NIS_DOMAIN:
 		case D6_OPT_NISP_DOMAIN:
 		case D6_OPT_BCMCS_SERVER_D:
-#if ENABLE_FEATURE_UDHCP_RFC3397
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY
 			if (dhcp6_get_domain(optlen, cp, opt, &optinfo->ad_list) == -1)
 				goto fail;
 #endif
@@ -1546,6 +1644,56 @@ int dhcp6_set_options(int type, struct d
 			goto fail;
 	}
 
+#if /* ENABLE_DHCP6S ||*/ ENABLE_DHCP6RELAY
+	if (dhcp6_set_domain(D6_OPT_SIP_SERVER_D, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(D6_OPT_SIP_SERVER_A, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(D6_OPT_DNS, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(D6_OPT_DNSNAME, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(D6_OPT_NIS_SERVERS, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(D6_OPT_NISP_SERVERS, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(D6_OPT_NIS_DOMAIN, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(D6_OPT_NISP_DOMAIN, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(D6_OPT_SNTP_SERVERS, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(D6_OPT_NTP_SERVER, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_domain(D6_OPT_BCMCS_SERVER_D, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+
+	if (dhcp6_set_addr(D6_OPT_BCMCS_SERVER_A, &optinfo->ad_list,
+	    &p, optep, &len) != 0)
+		goto fail;
+#endif /* ENABLE_DHCP6S || ENABLE_DHCP6RELAY */
+
 	if (dhcp6_set_iaoptions(D6_OPT_IA_NA, &optinfo->ia_list, &p, optep, &len) < 0)
 		goto fail;
 
@@ -1569,12 +1717,12 @@ int dhcp6_set_options(int type, struct d
 			goto fail;
 	}
 
-#if ENABLE_FEATURE_DHCP6_AUTH
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
 	if (optinfo->authproto != -1) {
 		if (copyout_auth(optinfo, &p, optbp, optep, &len) != 0)
 			goto fail;
 	}
-#endif /* ENABLE_FEATURE_DHCP6_AUTH */
+#endif /* ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY */
 
 	return len;
 
@@ -1751,7 +1899,7 @@
 	return len;
 }
 
-#if ENABLE_FEATURE_DHCP6_AUTH
+#if ENABLE_FEATURE_DHCP6_AUTH || ENABLE_DHCP6RELAY
 # if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
 static char *sprint_auth(struct dhcp6_optinfo *optinfo)
 {
diff -urNBp busybox/networking/udhcp/common.h busybox.full/networking/udhcp/common.h
--- busybox/networking/udhcp/common.h	2011-09-26 15:53:22.000000000 +0400
+++ busybox.full/networking/udhcp/common.h	2011-09-26 14:57:43.000000000 +0400
@@ -192,7 +192,7 @@ uint8_t *udhcp_get_option(struct dhcp_pa
 int udhcp_end_option(uint8_t *optionptr) FAST_FUNC;
 void udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt) FAST_FUNC;
 void udhcp_add_simple_option(struct dhcp_packet *packet, uint8_t code, uint32_t data) FAST_FUNC;
-#if ENABLE_FEATURE_UDHCP_RFC3397
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY
 char *dname_dec(const uint8_t *cstr, int clen, const char *pre) FAST_FUNC;
 uint8_t *dname_enc(const uint8_t *cstr, int clen, const char *src, int *retlen) FAST_FUNC;
 #endif
diff -urNBp busybox/networking/udhcp/config6.c busybox.full/networking/udhcp/config6.c
--- busybox/networking/udhcp/config6.c	2011-09-26 18:10:00.000000000 +0400
+++ busybox.full/networking/udhcp/config6.c	2011-09-26 15:37:28.000000000 +0400
@@ -130,6 +130,9 @@ static int configure_interface(void)
 			switch (cfl->type) {
 			case DECL_REQUEST:
 			case DECL_SEND:
+#if 0 /* ENABLE_DHCP6S */
+			case DECL_ALLOW:
+#endif
 				if (add_options(cfl->type, ifp, cfl->sublist))
 					return -1;
 				break;
@@ -984,7 +987,7 @@ static const struct dhcp_cf_options dhcp
     { "nis-server-address",       DHCPOPT_NIS,           0 },
     { "nisp-server-address",      DHCPOPT_NISP,          0 },
     { "bcmcs-server-address",     DHCPOPT_BCMCS,         0 },
-#if ENABLE_FEATURE_UDHCP_RFC3397
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_DHCP6RELAY
     { "domain-name",              DHCPOPT_DNSNAME,       0 },
     { "sip-server-domain-name",   DHCPOPT_SIPNAME,       0 },
     { "nis-domain-name",          DHCPOPT_NISNAME,       0 },
diff -urNBp busybox/networking/udhcp/config6.h busybox.full/networking/udhcp/config6.h
--- busybox/networking/udhcp/config6.h	2011-09-26 18:07:52.000000000 +0400
+++ busybox.full/networking/udhcp/config6.h	2011-09-26 15:37:34.000000000 +0400
@@ -209,6 +209,29 @@ struct ia_conf {
 	struct pifc_list iapd_pif_list;
 };
 
+#if 0 /* ENABLE_DHCP6S */
+/* per-host configuration */
+struct host_conf {
+	struct host_conf *next;
+
+	char *name;					/* host name to identify the host */
+	struct dhcp6_vbuf duid;		/* DUID for the host */
+
+	/* prefixes to be delegated to the host */
+	struct dhcp6_list prefix_list;
+	/* address to be assigned for the host */
+	struct dhcp6_list addr_list;
+	/* address pool from which addresses are assigned for the host */
+	struct dhcp6_poolspec pool;
+
+	/* secret key shared with the client for delayed authentication */
+	struct keyinfo *delayedkey;
+	/* previous replay detection value from the client */
+	int saw_previous_rd;		/* if we remember the previous value */
+	uint64_t previous_rd;
+};
+#endif /* ENABLE_DHCP6S */
+
 struct cf_list;
 struct authinfo;
 
diff -urNBp busybox/networking/udhcp/Config.src busybox.full/networking/udhcp/Config.src
--- busybox/networking/udhcp/Config.src	2011-09-26 15:52:54.000000000 +0400
+++ busybox.full/networking/udhcp/Config.src	2011-09-26 14:57:43.000000000 +0400
@@ -96,7 +96,7 @@ config UDHCP_DEBUG
 	int "Maximum verbosity level for udhcp applets (0..9)"
 	default 9
 	range 0 9
-	depends on UDHCPD || UDHCPC || DHCPRELAY || DHCP6C
+	depends on UDHCPD || UDHCPC || DHCPRELAY || DHCP6C || DHCP6RELAY
 	help
 	  Verbosity can be increased with multiple -v options.
 	  This option controls how high it can be cranked up.
@@ -168,3 +168,11 @@ config FEATURE_DHCP6_AUTH
 	help
 	  If selected, client will support DHCPv6 messages authentication,
 	  currently HMAC-MD5 only.
+
+config DHCP6RELAY
+	bool "dhcp6relay"
+	default n
+	depends on FEATURE_IPV6 && DHCP6C
+	help
+	  dhcp6relay listens for DHCPv6 requests on one or more interfaces
+	  and forwards these requests to a different interface.
diff -urNBp busybox/networking/udhcp/dhcp6c_script.c busybox.full/networking/udhcp/dhcp6c_script.c
--- busybox/networking/udhcp/dhcp6c_script.c	2011-09-26 15:54:09.000000000 +0400
+++ busybox.full/networking/udhcp/dhcp6c_script.c	2011-09-26 15:45:54.000000000 +0400
@@ -150,6 +150,105 @@ char **fill_envp_client6(struct dhcp6_op
 	return envp;
 }
 
+#if ENABLE_DHCP6RELAY
+static const envp_list_t relay6_envp_list[] = {
+    { "iapd_%d=",        DHCP6_LISTVAL_PREFIX6 },
+    { "iana_%d=",  DHCP6_LISTVAL_STATEFULADDR6 },
+};
+
+static char *ia2str(int, struct dhcp6_listval *, const char *);
+
+char **fill_envp_relay6(struct dhcp6_optinfo *optinfo, const char *clientaddr)
+{
+	int i, j, envc;
+	char **envp, **curr;
+	struct dhcp6_listval *v;
+
+	envc = 2;     /* we at least include the address and the terminator */
+
+	/* count the number of variables */
+	v = TAILQ_FIRST(&optinfo->ia_list);
+	while (v) {
+		envc++;
+		v = TAILQ_NEXT(v, link);
+	}
+
+	/* allocate an environments array */
+	curr = envp = xzalloc(sizeof(char *) * envc);
+
+	/*
+	 * Copy the parameters as environment variables
+	 */
+	/* address */
+	*curr = xasprintf("client=%s", clientaddr);
+	putenv(*curr++);
+	if (envc <=2)
+		return envp;
+
+	/* IAs */
+	for (i=0; i < ARRAY_SIZE(relay6_envp_list); i++) {
+		j = 0;
+		TAILQ_FOREACH(v, &optinfo->ia_list, link) {
+			if (v->lvtype != relay6_envp_list[i].type)
+				continue;
+			if ((*curr = ia2str(j++, v, relay6_envp_list[i].name)) == NULL)
+				return NULL;
+
+			putenv(*curr++);
+		}
+	}
+
+	return envp;
+}
+
+
+static char *ia2str(int num, struct dhcp6_listval *iav, const char *fmt)
+{
+	struct dhcp6_listval *siav;
+	char *s;
+	const char *comma;
+	int len;
+	char a[INET6_ADDRSTRLEN];
+
+#define IASTR_MAXSIZE	((16/*name*/ + (INET6_ADDRSTRLEN + 1)/*addr6*/ + 4/*prefix*/ + 1) * 32)
+	if ((s = malloc_or_warn(IASTR_MAXSIZE)) == NULL)
+		return NULL;
+
+	memset(s, 0, IASTR_MAXSIZE);
+	len = snprintf(s, IASTR_MAXSIZE, fmt, num);
+	comma = "";
+
+	TAILQ_FOREACH(siav, &iav->sublist, link) {
+		if (len >= IASTR_MAXSIZE)
+			goto out;
+		switch (siav->lvtype) {
+		case DHCP6_LISTVAL_STATEFULADDR6:
+			sprint_nip6(a, (const uint8_t *)&siav->val_statefuladdr6.addr);
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s%s", comma, a);
+			break;
+
+		case DHCP6_LISTVAL_PREFIX6:
+			sprint_nip6(a, (const uint8_t *)&siav->val_prefix6.addr);
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s%s/%d", comma, a, siav->val_prefix6.plen);
+			break;
+
+		case DHCP6_LISTVAL_NUM16:
+			len += snprintf(s + len, IASTR_MAXSIZE - len,
+			    "%s#%d", comma, siav->val_num16);
+			break;
+
+		default:
+			bb_error_msg("impossible subopt");
+		}
+		comma = ",";
+	}
+ out:
+	return s;
+}
+#endif /* ENABLE_DHCP6RELAY */
+
 int dhcp6_script(const char *scriptpath, char **envp)
 {
 	char *argv[2];
diff -urNBp busybox/networking/udhcp/dhcp6.h busybox.full/networking/udhcp/dhcp6.h
--- busybox/networking/udhcp/dhcp6.h	2011-09-26 18:07:33.000000000 +0400
+++ busybox.full/networking/udhcp/dhcp6.h	2011-09-26 15:36:32.000000000 +0400
@@ -175,6 +175,9 @@ struct dhcp6_optinfo {
 	struct dhcp6_list reqopt_list;	/* options in option request */
 	struct dhcp6_list stcode_list;	/* status code */
 	struct dhcp6_list ad_list;		/* SIP/DNS/NTP/NIS/NIS+/BCMS servers/domain list */
+#if 0 /* ENABLE_DHCP6S */
+	struct dhcp6_list prefix_list;	/* prefix list */
+#endif
 
 	struct dhcp6_vbuf relay_msg;	/* relay message */
 #define relaymsg_len relay_msg.dv_len
diff -urNBp busybox/networking/udhcp/dhcp6relay.c busybox.full/networking/udhcp/dhcp6relay.c
--- busybox/networking/udhcp/dhcp6relay.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox.full/networking/udhcp/dhcp6relay.c	2011-06-14 20:37:33.000000000 +0400
@@ -0,0 +1,829 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * DHCPv6 relay
+ *
+ * Copyright (C) 2000 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Original code taken from wide-dhcpv6-20080615 and converted into
+ * a busybox applet by Leonid Lisovskiy <lly@sf.net>
+ */
+
+#include <sys/queue.h>
+#include <sys/uio.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <ifaddrs.h>
+#include <syslog.h>
+
+/* Override ENABLE_FEATURE_PIDFILE */
+#define WANT_PIDFILE 1
+#include "common.h"
+#include "dhcp6.h"
+#include "config6.h"
+#include "common6.h"
+#include "dhcp6c.h"
+
+#define DHCP6RELAY_PIDFILE "/var/run/dhcp6relay.pid"
+
+
+struct ifid_list {
+	TAILQ_ENTRY(ifid_list) ilink;
+	unsigned int ifid;
+};
+
+struct prefix_t {
+	struct in6_addr addr;
+	int plen;
+};
+
+/* list of non-link-local prefixes */
+static const struct prefix_t global_prefixes[] = {
+/*{ {{{0xfe,0xc0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 10 },    "fec0::/10" site-local unicast addresses were deprecated */
+  { {{{0x20,0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 3  }, /* "2000::/3" */
+  { {{{0xfc,0x00, 0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}, 7  }, /* "FC00::/7"  Unique Local Address (RFC4193) */
+};
+
+struct globals {
+	len_and_sockaddr *sa6_server;
+	struct sockaddr_in6 sa6_client;
+
+	int mhops;
+
+	const char *relaydevice;
+	const char *boundaddr;
+	const char *serveraddr;
+	const char *scriptpath;
+	const char *pid_file;
+
+	TAILQ_HEAD(, ifid_list) ifids_list;
+	unsigned int relayifid;
+
+	int ssock;		/* socket for relaying to servers */
+	int csock;		/* socket for clients */
+
+	uint8_t relaybuf[sizeof(struct dhcp6_relay) + BUFSIZ];
+	char    rdatabuf[BUFSIZ];
+} FIX_ALIASING;
+
+#define G (*ptr_to_globals)
+#define ssock		(G.ssock       )
+#define csock		(G.csock       )
+#define INIT_G() do { \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+	G.mhops = DHCP6_RELAY_MULTICAST_HOPS; \
+	G.serveraddr = DH6ADDR_ALLSERVER; \
+	G.boundaddr = "::"; \
+	G.pid_file = DHCP6RELAY_PIDFILE; \
+	G.scriptpath = NULL; \
+	G.relaydevice = NULL; \
+} while (0)
+
+
+static void relay6_init(int, char *[]);
+static void relay6_loop(void);
+static void relay6_recv(int, int);
+static void relay_to_server(struct dhcp6 *, ssize_t,
+    struct sockaddr_in6 *, char *, unsigned int);
+static void relay_to_client(struct dhcp6_relay *, ssize_t, struct sockaddr *);
+static int getifidfromaddr(struct in6_addr *);
+static int getifaddr(struct in6_addr *addr, char *ifnam,
+	      const struct in6_addr *prefix, int plen,
+	      int strong /* if strong host model is required or not */);
+
+
+enum {
+	OPT_FOREGROUND = 1 << 0,
+	OPT_b = 1 << 1,
+	OPT_H = 1 << 2,
+	OPT_r = 1 << 3,
+	OPT_s = 1 << 4,
+	OPT_S = 1 << 5,
+	OPT_p = 1 << 6,
+	OPT_VERBOSE = 1 << 7,
+};
+
+//usage:#define dhcp6relay_trivial_usage
+//usage:       "[-vf] [-b boundaddr] [-H hoplim]\n"
+//usage:       "	[-r relay-IF] [-s serveraddr] [-p pidfile] [-S script] interface"
+//usage:#define dhcp6relay_full_usage "\n"
+//usage:      "\n	-v		Print debugging messages (may be repeated)"
+//usage:      "\n	-f		Foreground mode"
+//usage:      "\n	-b boundaddr	Source address to relay packets to servers"
+//usage:      "\n	-H hoplim	Hop limit of DHCPv6 Solicit messages forwarded to servers"
+//usage:      "\n	-r relay-IF	Interface on which messages to servers are sent"
+//usage:      "\n	-s serveraddr	DHCPv6 server address to relay packets to."
+//usage:      "\n			If not specified, packets are relayed to ff05::1:3"
+//usage:      "\n	-S script	Script file to be executed when relay receives"
+//usage:      "\n			a RELAY-REPLY message from a DHCPv6 server"
+//usage:      "\n	-p pidfile	Use pid-file to dump the process ID"
+
+int dhcp6relay_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dhcp6relay_main(int argc, char **argv)
+{
+	const char *str_H;
+	int opt;
+
+	INIT_G();
+
+	opt_complementary = "-1" IF_UDHCP_VERBOSE(":vv");
+	opt = getopt32(argv, "fb:H:r:s:S:p:v",
+			&G.boundaddr, &str_H, &G.relaydevice, &G.serveraddr,
+			&G.scriptpath, &G.pid_file
+			IF_UDHCP_VERBOSE(, &dhcp_verbose)
+			);
+	if (opt & OPT_H) {
+		char *p = NULL;
+
+		G.mhops = (int )strtoul(str_H, &p, 10);
+		if (!*str_H || *p) {
+			bb_error_msg_and_die("illegal hop limit: %s", str_H);
+		}
+		if (G.mhops <= 0 || G.mhops > 255) {
+			bb_error_msg_and_die("illegal hop limit: %d", G.mhops);
+		}
+	}
+
+	if (!(option_mask32 & OPT_FOREGROUND)) {
+		bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
+		openlog(applet_name, LOG_PID, LOG_DAEMON);
+		logmode = LOGMODE_SYSLOG;
+	}
+
+	argc -= optind;
+	argv += optind;
+	if (G.relaydevice == NULL) {
+		if (argc > 1) {
+			bb_error_msg_and_die("you should explicitly specify a "
+			    "relaying interface, when you are to "
+			    "listen on multiple interfaces");
+		}
+		G.relaydevice = argv[0];
+	}
+
+	/* dump current PID */
+	write_pidfile(G.pid_file);
+
+	relay6_init(argc, argv);
+
+	bb_info_msg("%s started", applet_name);
+	relay6_loop();
+	remove_pidfile(G.pid_file);
+
+	if (ENABLE_FEATURE_CLEAN_UP) {
+		free(G.sa6_server);
+	}
+
+	return 0;
+}
+
+static void relay6_init(int ifnum, char *iflist[])
+{
+	struct addrinfo hints;
+	struct addrinfo *res;
+	len_and_sockaddr *maddr;
+	int error;
+	struct ipv6_mreq mreq6;
+
+	/* initialize special socket addresses */
+	G.sa6_server = xhost_and_af2sockaddr(G.serveraddr, DH6PORT_UPSTREAM, AF_INET6);
+
+	/*
+	 * Setup a socket to communicate with clients.
+	 */
+	csock = sock6_init(NULL, xstr(DH6PORT_UPSTREAM));
+
+	maddr = xhost_and_af2sockaddr(DH6ADDR_ALLAGENT, 0, AF_INET6);
+	memset(&mreq6, 0, sizeof(mreq6));
+	memcpy(&mreq6.ipv6mr_multiaddr, &maddr->u.sin6.sin6_addr,
+			sizeof(mreq6.ipv6mr_multiaddr));
+	free(maddr);
+
+	TAILQ_INIT(&G.ifids_list);
+	while (ifnum-- > 0) {
+		char *ifp = iflist[0];
+		struct ifid_list *ifd;
+
+		ifd = (struct ifid_list *)xzalloc(sizeof(*ifd));
+		ifd->ifid = if_nametoindex(ifp);
+		if (ifd->ifid == 0) {
+			bb_perror_msg_and_die("invalid interface(%s)", ifp);
+		}
+		mreq6.ipv6mr_interface = ifd->ifid;
+
+		if (setsockopt(csock, IPPROTO_IPV6, IPV6_JOIN_GROUP,
+		    &mreq6, sizeof(mreq6))) {
+			bb_error_msg_and_die("setsockopt(IPV6_JOIN_GROUP)");
+		}
+		TAILQ_INSERT_TAIL(&G.ifids_list, ifd, ilink);
+		iflist++;
+	}
+
+	/*
+	 * Setup a socket to relay to servers.
+	 */
+	G.relayifid = if_nametoindex(G.relaydevice);
+	if (G.relayifid == 0)
+		bb_perror_msg("invalid interface(%s)", G.relaydevice);
+	/*
+	 * We are not really sure if we need to listen on the downstream
+	 * port to receive packets from servers.  We'll need to clarify the
+	 * specification, but we do for now.
+	 */
+	hints.ai_flags = AI_PASSIVE;
+	error = getaddrinfo(G.boundaddr, xstr(DH6PORT_DOWNSTREAM), &hints, &res);
+	if (error) {
+		bb_error_msg_and_die("getaddrinfo: %s", gai_strerror(error));
+	}
+	memcpy(&G.sa6_client, res->ai_addr, sizeof(G.sa6_client));
+	ssock = sock6_init(G.boundaddr, xstr(DH6PORT_DOWNSTREAM));
+
+	bb_signals(0 + (1 << SIGTERM), record_signo);
+}
+
+static void relay6_loop(void)
+{
+	fd_set readfds;
+	int e, maxsock;
+
+	while (!bb_got_signal) {
+
+		/* we'd rather use FD_COPY here, but it's not POSIX friendly */
+		FD_ZERO(&readfds);
+		FD_SET(csock, &readfds);
+		FD_SET(ssock, &readfds);
+
+		maxsock = MAX(csock, ssock);
+		e = select(maxsock + 1, &readfds, NULL, NULL, NULL);
+		switch (e) {
+		case 0:		/* impossible in our situation */
+		case -1:
+			if (errno != EINTR) {
+				bb_error_msg_and_die("select");
+			}
+			continue;
+		default:
+			break;
+		}
+
+		if (FD_ISSET(csock, &readfds))
+			relay6_recv(csock, 1);
+
+		if (FD_ISSET(ssock, &readfds))
+			relay6_recv(ssock, 0);
+	}
+}
+
+static void relay6_recv(int s, int fromclient)
+{
+	ssize_t len;
+	struct sockaddr_in6 from, to;
+	unsigned int ifid;
+	struct dhcp6 *dh6 = (struct dhcp6 *)G.rdatabuf;
+	struct ifid_list *ifd;
+	char ifname[IF_NAMESIZE];
+	char *a;
+
+	if ((len = recv_from_to(s, G.rdatabuf, sizeof(G.rdatabuf),
+		&from, &to, sizeof(struct sockaddr_in6))) < sizeof(struct dhcp6)) {
+		return;
+	}
+
+	TAILQ_FOREACH(ifd, &G.ifids_list, ilink) {
+		if (to.sin6_scope_id == ifd->ifid)
+			break;
+	}
+	/*
+	 * DHCPv6 relay may receive a DHCPv6 packet from a non-listening
+	 * interface, when a DHCPv6 server is running on that interface.
+	 * This check prevents such reception.
+	 */
+	if (ifd == NULL && to.sin6_scope_id != G.relayifid)
+		return;
+	if (if_indextoname(to.sin6_scope_id, ifname) == NULL) {
+		bb_perror_msg("if_indextoname(%u)", to.sin6_scope_id);
+		return;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&from);
+	log1("received %s from %s", dhcp6msgstr(dh6->dh6_msgtype), a);
+
+	/*
+	 * Relay the packet according to the type.  A client message or
+	 * a relay forward message is forwarded to servers (or other relays),
+	 * and a relay reply message is forwarded to the intended client.
+	 */
+	switch (dh6->dh6_msgtype) {
+		case DH6_SOLICIT:
+		case DH6_REQUEST:
+		case DH6_CONFIRM:
+		case DH6_RENEW:
+		case DH6_REBIND:
+		case DH6_RELEASE:
+		case DH6_DECLINE:
+		case DH6_INFORM_REQ:
+		case DH6_RELAY_FORW:
+			if (fromclient)
+				goto wrong;
+			relay_to_server(dh6, len, (struct sockaddr_in6 *)&from,
+			    ifname, htonl(ifid));
+			break;
+		case DH6_RELAY_REPLY:
+			/*
+			 * The server may send a relay reply to the client
+			 * port.
+			 * XXX: need to clarify the port issue
+			 */
+			relay_to_client((struct dhcp6_relay *)dh6, len,
+			    (struct sockaddr *)&from);
+			break;
+		default:
+wrong:
+			bb_info_msg("unexpected message (%s) on the %s side "
+			    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
+			    fromclient ? "client" : "server", a);
+			break;
+	}
+
+	free(a);
+}
+
+static int make_msgcontrol(struct msghdr *mh, void *ctlbuf, socklen_t buflen,
+		struct in6_pktinfo *pktinfo, uint32_t hlim)
+{
+	struct cmsghdr *cm;
+	socklen_t controllen = 0;
+
+	if (pktinfo)
+		controllen += CMSG_SPACE(sizeof(*pktinfo));
+	if (hlim > 0)
+		controllen += CMSG_SPACE(sizeof(hlim));
+	if (buflen < controllen)
+		return -1;
+
+	memset(ctlbuf, 0, buflen);
+	mh->msg_controllen = controllen;
+	mh->msg_control = ctlbuf;
+
+	cm = CMSG_FIRSTHDR(mh);
+	if (pktinfo) {
+		cm->cmsg_len = CMSG_LEN(sizeof(*pktinfo));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_PKTINFO;
+		memcpy(CMSG_DATA(cm), pktinfo, sizeof(*pktinfo));
+
+		cm = CMSG_NXTHDR(mh, cm);
+	}
+
+	if (hlim > 0) {
+		cm->cmsg_len = CMSG_LEN(sizeof(hlim));
+		cm->cmsg_level = IPPROTO_IPV6;
+		cm->cmsg_type = IPV6_HOPLIMIT;
+		/* *(int *)CMSG_DATA(cm) = hlim; - unaligned access */
+		move_to_unaligned32(CMSG_DATA(cm), hlim);
+
+		cm = CMSG_NXTHDR(mh, cm); /* just in case */
+	}
+
+	return 0;
+}
+
+static void relay_to_server(struct dhcp6 *dh6, ssize_t len,
+			    struct sockaddr_in6 *from,
+			    char *ifname, unsigned int ifid)
+{
+	struct dhcp6_optinfo optinfo;
+	struct dhcp6_relay *dh6relay;
+	struct in6_addr linkaddr;
+	int optlen, relaylen;
+	int i, cc;
+	char *a;
+	struct msghdr mh;
+	struct iovec iov[1];
+	struct in6_pktinfo pktinfo;
+	char ctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))
+	    + CMSG_SPACE(sizeof(int))];
+
+	/*
+	 * Prepare a relay forward option.
+	 */
+	dhcp6_init_options(&optinfo);
+
+	/* Relay message */
+	optinfo.relaymsg_msg = xmalloc(len);
+	optinfo.relaymsg_len = len;
+	memcpy(optinfo.relaymsg_msg, dh6, len);
+
+	/* Interface-id.  We always use this option. */
+	optinfo.ifidopt_id = xmalloc(sizeof(ifid));
+	optinfo.ifidopt_len = sizeof(ifid);
+	memcpy(optinfo.ifidopt_id, &ifid, sizeof(ifid));
+
+	/*
+	 * Construct a relay forward message.
+	 */
+	dh6relay = (struct dhcp6_relay *)G.relaybuf;
+	memset(dh6relay, 0, sizeof(*dh6relay));
+	dh6relay->dh6relay_msgtype = DH6_RELAY_FORW;
+	memcpy(&dh6relay->dh6relay_peeraddr, &from->sin6_addr,
+	    sizeof(dh6relay->dh6relay_peeraddr));
+
+	/* find a global address to fill in the link address field */
+	memset(&linkaddr, 0, sizeof(linkaddr));
+	for (cc=0,i=0; i < ARRAY_SIZE(global_prefixes); i++) {
+		if (getifaddr(&linkaddr, ifname, &global_prefixes[i].addr,
+			      global_prefixes[i].plen, 1) == 0) {/* found */
+			cc = 1;
+			break;
+		}
+	}
+	if (cc == 0) {
+		bb_info_msg("can't find a global address on %s", ifname);
+
+		/*
+		 * When relaying a message from a client, we need a global
+		 * link address.
+		 * XXX: this may be too strong for the stateless case, but
+		 * the DHCPv6 specification seems to require the behavior.
+		 */
+		if (dh6->dh6_msgtype != DH6_RELAY_FORW)
+			goto out;
+	}
+
+	if (dh6->dh6_msgtype == DH6_RELAY_FORW) {
+		struct dhcp6_relay *dh6relay0 = (struct dhcp6_relay *)dh6;
+
+		/* Relaying a Message from a Relay Agent */
+
+		/*
+		 * If the hop-count in the message is greater than or equal to
+		 * HOP_COUNT_LIMIT, the relay agent discards the received
+		 * message.
+		 * [RFC3315 Section 20.1.2]
+		 */
+		if (dh6relay0->dh6relay_hcnt >= DHCP6_RELAY_HOP_COUNT_LIMIT) {
+			bb_info_msg("too many relay forwardings");
+			goto out;
+		}
+
+		dh6relay->dh6relay_hcnt = dh6relay0->dh6relay_hcnt + 1;
+
+		/*
+		 * We can keep the link-address field 0, regardless of the
+		 * scope of the source address, since we always include
+		 * interface-ID option.
+		 */
+	} else {
+		/* Relaying a Message from a Client */
+		memcpy(&dh6relay->dh6relay_linkaddr, &linkaddr,
+		    sizeof(dh6relay->dh6relay_linkaddr));
+		dh6relay->dh6relay_hcnt = 0;
+	}
+
+	relaylen = sizeof(*dh6relay);
+	if ((optlen = dhcp6_set_options(DH6_RELAY_FORW,
+	    (struct dhcp6opt *)(dh6relay + 1),
+	    (struct dhcp6opt *)(G.relaybuf + sizeof(G.relaybuf)), &optinfo)) < 0) {
+		bb_error_msg("can't construct options");
+		goto out;
+	}
+	relaylen += optlen;
+
+	/*
+	 * Forward the message.
+	 */
+	memset(&mh, 0, sizeof(mh));
+	iov[0].iov_base = G.relaybuf;
+	iov[0].iov_len = relaylen;
+	mh.msg_iov = iov;
+	mh.msg_iovlen = 1;
+	mh.msg_name = G.sa6_server;
+	mh.msg_namelen = sizeof(*G.sa6_server);
+	if (IN6_IS_ADDR_MULTICAST(&G.sa6_server->u.sin6.sin6_addr)) {
+		memset(&pktinfo, 0, sizeof(pktinfo));
+		pktinfo.ipi6_ifindex = G.relayifid;
+		make_msgcontrol(&mh, ctlbuf, sizeof(ctlbuf), &pktinfo, G.mhops);
+	}
+
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)G.sa6_server);
+	if ((cc = sendmsg(ssock, &mh, 0)) < 0) {
+		bb_perror_msg("sendmsg to %s ", a);
+	} else if (cc != relaylen) {
+		bb_error_msg("can't send a complete packet to %s", a);
+	} else {
+		log1("relay a message to a server %s", a);
+	}
+	free(a);
+
+  out:
+	dhcp6_clear_options(&optinfo);
+}
+
+static void
+relay_to_client(struct dhcp6_relay *dh6relay, ssize_t len, struct sockaddr *from)
+{
+	struct dhcp6_optinfo optinfo;
+	struct sockaddr_in6 peer;
+	unsigned int ifid;
+	char ifnamebuf[IFNAMSIZ];
+	char *a = NULL;
+	int cc;
+	int relayed = 0;
+	struct dhcp6 *dh6;
+	struct msghdr mh;
+	struct in6_pktinfo pktinfo;
+	struct iovec iov[1];
+	char ctlbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];
+#if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 1
+	char a1[INET6_ADDRSTRLEN], a2[INET6_ADDRSTRLEN];
+
+	sprint_nip6(a1, (const uint8_t *)&dh6relay->dh6relay_linkaddr);
+	sprint_nip6(a2, (const uint8_t *)&dh6relay->dh6relay_peeraddr);
+	log1("dhcp6 relay reply: hop=%d, linkaddr=%s, peeraddr=%s",
+	    dh6relay->dh6relay_hcnt, a1, a2);
+#endif
+
+	/*
+	 * parse and validate options in the relay reply message.
+	 */
+	dhcp6_init_options(&optinfo);
+	if (dhcp6_get_options((struct dhcp6opt *)(dh6relay + 1),
+	    (struct dhcp6opt *)((char *)dh6relay + len), &optinfo) < 0) {
+		bb_info_msg("can't parse options");
+		return;
+	}
+
+	a = xmalloc_sockaddr2dotted_noport(from);
+	/* A relay reply message must include a relay message option */
+	if (optinfo.relaymsg_msg == NULL) {
+		bb_info_msg("relay reply message from %s "
+		    "without a relay message", a);
+		goto out;
+	}
+
+	/* minimum validation for the inner message */
+	if (optinfo.relaymsg_len < sizeof(struct dhcp6)) {
+		bb_info_msg("short relay message from %s", a);
+		goto out;
+	}
+
+	/*
+	 * Extract interface ID which should be included in relay reply
+	 * messages to us.
+	 */
+	ifid = 0;
+	if (optinfo.ifidopt_id) {
+		if (optinfo.ifidopt_len != sizeof(ifid)) {
+			bb_info_msg(
+			    "unexpected length (%d) for Interface ID from %s",
+			    optinfo.ifidopt_len, a);
+			goto out;
+		} else {
+			memcpy(&ifid, optinfo.ifidopt_id, sizeof(ifid));
+			ifid = ntohl(ifid);
+
+			/* validation for ID */
+			if ((if_indextoname(ifid, ifnamebuf)) == NULL) {
+				bb_info_msg("invalid interface ID: %x", ifid);
+				goto out;
+			}
+		}
+	} else {
+		bb_info_msg("Interface ID is not included from %s", a);
+		/*
+		 * the responding server should be buggy, but we deal with it.
+		 */
+	}
+
+	/*
+	 * If we fail, try to get the interface from the link address.
+	 */
+	if (ifid == 0 &&
+	    !IN6_IS_ADDR_UNSPECIFIED(&dh6relay->dh6relay_linkaddr) &&
+	    !IN6_IS_ADDR_LINKLOCAL(&dh6relay->dh6relay_linkaddr)) {
+		ifid = getifidfromaddr(&dh6relay->dh6relay_linkaddr);
+	}
+
+	if (ifid == 0) {
+		bb_error_msg("can't determine relay link");
+		goto out;
+	}
+
+	peer = G.sa6_client;
+	dh6 = (struct dhcp6 *) optinfo.relaymsg_msg;
+	if (dh6->dh6_msgtype != DH6_RELAY_REPLY) {
+		relayed++;
+	} else {
+		/*
+		 * change dst port to server/relay port, since it's a
+		 * reply to relay, not to a client
+		 */
+		peer.sin6_port = htons(DH6PORT_UPSTREAM);
+	}
+	memcpy(&peer.sin6_addr, &dh6relay->dh6relay_peeraddr,
+	    sizeof(peer.sin6_addr));
+	if (IN6_IS_ADDR_LINKLOCAL(&peer.sin6_addr))
+		peer.sin6_scope_id = ifid; /* XXX: we assume a 1to1 map */
+
+	/* construct a message structure specifying the outgoing interface */
+	memset(&mh, 0, sizeof(mh));
+	iov[0].iov_base = optinfo.relaymsg_msg;
+	iov[0].iov_len = optinfo.relaymsg_len;
+	mh.msg_iov = iov;
+	mh.msg_iovlen = 1;
+	mh.msg_name = &peer;
+	mh.msg_namelen = sizeof(peer);
+	memset(&pktinfo, 0, sizeof(pktinfo));
+	pktinfo.ipi6_ifindex = ifid;
+	make_msgcontrol(&mh, ctlbuf, sizeof(ctlbuf), &pktinfo, 0);
+
+	free(a);
+	a = xmalloc_sockaddr2dotted_noport((struct sockaddr *)&peer);
+	/* send packet */
+	if ((cc = sendmsg(csock, &mh, 0)) < 0) {
+		bb_perror_msg("sendmsg to %s ", a);
+	} else if (cc != optinfo.relaymsg_len) {
+		bb_info_msg("can't send a complete packet to %s", a);
+	} else {
+		log1("relay a message to a client %s", a);
+	}
+
+	if (relayed && G.scriptpath != NULL) {
+		struct dhcp6_optinfo optinfo1;
+
+		/* only replies are interesting */
+		if (dh6->dh6_msgtype != DH6_REPLY &&
+		    dh6->dh6_msgtype != DH6_ADVERTISE) {
+			bb_info_msg("forward msg#%d to client?", dh6->dh6_msgtype);
+			goto out;
+		}
+
+		/* parse options */
+		dhcp6_init_options(&optinfo1);
+		if (dhcp6_get_options((struct dhcp6opt *)(dh6 + 1),
+		    (struct dhcp6opt *)((caddr_t) dh6 + optinfo.relaymsg_len),
+		    &optinfo1) < 0) {
+			bb_info_msg("can't parse options");
+			goto out;
+		}
+
+		dhcp6_script(G.scriptpath, fill_envp_relay6(&optinfo1, a));
+		dhcp6_clear_options(&optinfo1);
+	}
+
+  out:
+	free(a);
+	dhcp6_clear_options(&optinfo);
+	return;
+}
+
+static int in6_addrscopebyif(const struct in6_addr *addr, const char *ifnam)
+{
+	unsigned ifindex;
+
+	ifindex = if_nametoindex(ifnam);
+	if (ifindex == 0)
+		return -1;
+
+	if (IN6_IS_ADDR_LINKLOCAL(addr) || IN6_IS_ADDR_MC_LINKLOCAL(addr))
+		return ifindex;
+
+	if (IN6_IS_ADDR_SITELOCAL(addr) || IN6_IS_ADDR_MC_SITELOCAL(addr))
+		return 1;	/* XXX */
+
+	if (IN6_IS_ADDR_MC_ORGLOCAL(addr))
+		return 1;	/* XXX */
+
+	return 1;		/* treat it as global */
+}
+
+static int getifaddr(struct in6_addr *addr, char *ifnam,
+	      const struct in6_addr *prefix, int plen,
+	      int strong /* if strong host model is required or not */)
+{
+	struct ifaddrs *ifap, *ifa;
+	struct sockaddr_in6 sin6;
+	int error = -1;
+
+	if (getifaddrs(&ifap) != 0) {
+		bb_perror_msg("getifaddrs");
+		return -1;
+	}
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		int s1, s2;
+
+		if (strong && strcmp(ifnam, ifa->ifa_name) != 0)
+			continue;
+
+		/* in any case, ignore interfaces in different scope zones. */
+		s1 = in6_addrscopebyif(prefix, ifnam);
+		s2 = in6_addrscopebyif(prefix, ifa->ifa_name);
+		if (s1 < 0 || s2 < 0 || s1 != s2)
+			continue;
+
+		if (ifa->ifa_addr->sa_family != AF_INET6)
+			continue;
+#ifdef HAVE_SA_LEN
+		if (ifa->ifa_addr->sa_len > sizeof(sin6))
+			continue;
+#endif
+
+		memcpy(&sin6, ifa->ifa_addr, sizeof(struct sockaddr_in6));
+#ifdef __KAME__
+		if (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr)) {
+			sin6.sin6_addr.s6_addr[2] = 0;
+			sin6.sin6_addr.s6_addr[3] = 0;
+		}
+#endif
+		if (plen % 8 == 0) {
+			if (memcmp(&sin6.sin6_addr, prefix, plen / 8) != 0)
+				continue;
+		} else {
+			struct in6_addr a, m;
+			int i;
+
+			memcpy(&a, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
+			memset(&m, 0, sizeof(m));
+			memset(&m, 0xff, plen / 8);
+			m.s6_addr[plen / 8] = (0xff00 >> (plen % 8)) & 0xff;
+			for (i = 0; i < sizeof(a); i++)
+				a.s6_addr[i] &= m.s6_addr[i];
+
+			if (memcmp(&a, prefix, plen / 8) != 0 ||
+			    a.s6_addr[plen / 8] !=
+			    (prefix->s6_addr[plen / 8] & m.s6_addr[plen / 8]))
+				continue;
+		}
+		memcpy(addr, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
+#ifdef __KAME__
+		if (IN6_IS_ADDR_LINKLOCAL(addr))
+			addr->s6_addr[2] = addr->s6_addr[3] = 0;
+#endif
+		error = 0;
+		break;
+	}
+
+	freeifaddrs(ifap);
+	return error;
+}
+
+static int getifidfromaddr(struct in6_addr *addr)
+{
+	struct ifaddrs *ifap, *ifa;
+	struct sockaddr_in6 *sa6;
+	unsigned int ifid;
+	int retval = 0;
+
+	if (getifaddrs(&ifap) != 0) {
+		bb_perror_msg("getifaddrs");
+		return 0;
+	}
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		if (ifa->ifa_addr->sa_family != AF_INET6)
+			continue;
+
+		sa6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+		if (IN6_ARE_ADDR_EQUAL(addr, &sa6->sin6_addr))
+			break;
+	}
+
+	if (ifa != NULL) {
+		if ((ifid = if_nametoindex(ifa->ifa_name)) == 0) {
+			bb_error_msg("invalid interface(%s)", ifa->ifa_name);
+			goto end;
+		}
+		retval = ifid;
+	}
+
+ end:
+	freeifaddrs(ifap);
+	return retval;
+}
diff -urNBp busybox/networking/udhcp/Kbuild.src busybox.full/networking/udhcp/Kbuild.src
--- busybox/networking/udhcp/Kbuild.src	2011-09-26 15:52:23.000000000 +0400
+++ busybox.full/networking/udhcp/Kbuild.src	2011-09-26 14:57:43.000000000 +0400
@@ -20,6 +20,7 @@ lib-$(CONFIG_DHCPRELAY)  += dhcprelay.o
 lib-$(CONFIG_DHCP6C)     += common6.o common.o
 
 lib-$(CONFIG_DHCP6C)     += dhcp6c.o config6.o dhcp6c_script.o dhcp6c_ia.o if6.o timer.o
+lib-$(CONFIG_DHCP6RELAY) += dhcp6relay.o domain_codec.o
 
 lib-$(CONFIG_FEATURE_DHCP6_AUTH)    += auth6.o
 
