diff -BurpN inadyn.orig/configure.ac inadyn/configure.ac
--- inadyn.orig/configure.ac	2010-07-10 23:31:21.000000000 +0000
+++ inadyn/configure.ac	2010-07-11 12:47:05.000000000 +0000
@@ -66,6 +66,11 @@ if test "x${NEED_WINSOCK}" = "xyes" ; th
 	AC_DEFINE(NEED_WINSOCK, 1, [Linker needs to include winsock])
 fi
 
+AM_CONDITIONAL([use_cache_file], [test "x${use_cache_file}" = "xyes"])
+if test "x${use_cache_file}" = "xyes" ; then
+	AC_DEFINE(USE_CACHE_FILE, 1, [Use cache file instead of cache dir])
+fi
+
 AC_OUTPUT([Makefile
 		src/Makefile
 		include/Makefile])
diff -BurpN inadyn.orig/include/dyndns.h inadyn/include/dyndns.h
--- inadyn.orig/include/dyndns.h	2010-07-11 10:12:18.000000000 +0000
+++ inadyn/include/dyndns.h	2010-07-11 12:07:17.000000000 +0000
@@ -54,6 +54,7 @@ typedef enum
 #define DYNDNS_DEFAULT_DEBUG_LEVEL	1
 #define DYNDNS_DEFAULT_CONFIG_FILE	"/etc/inadyn.conf"
 #define DYNDNS_DEFAULT_CACHE_PREFIX	"/tmp/"
+#define DYNDNS_DEFAULT_CACHE_FILE	"inadyn.cache"
 #define DYNDNS_DEFAULT_IP_FILE		"inadyn_ip.cache"
 #define DYNDNS_DEFAULT_TIME_FILE	"inadyn_time.cache"
 
@@ -313,9 +314,12 @@ typedef struct DYN_DNS_CLIENT
 	char *p_req_buffer; /* for HTTP requests*/
 	int req_buffer_size;
 	char external_command[1024];
+#ifndef USE_CACHE_FILE
 	char time_cache[1024];
 	char ip_cache[1024];
-
+#else
+	char file_cache[1024];
+#endif
 
 	USER_INFO sys_usr_info; /*info about the current account running inadyn*/
 	DYNDNS_INFO_TYPE info[DYNDNS_MAX_SERVER_NUMBER]; /*servers, names, passwd*/
diff -BurpN inadyn.orig/src/dyndns.c inadyn/src/dyndns.c
--- inadyn.orig/src/dyndns.c	2010-07-11 10:11:19.000000000 +0000
+++ inadyn/src/dyndns.c	2010-07-11 12:52:12.000000000 +0000
@@ -602,7 +602,7 @@ static RC_TYPE do_update_alias_table(DYN
 						/*recalc forced update period*/
 						p_self->forced_update_period_sec = p_self->forced_update_period_sec_orig;
 						p_self->forced_update_times = p_self->forced_update_period_sec / p_self->sleep_sec;
-
+					#ifndef USE_CACHE_FILE
 						if ((fp=fopen(p_self->ip_cache, "w")))
 						{
 							fprintf(fp,"%s", p_self->info[i].my_ip_address.name);
@@ -613,6 +613,13 @@ static RC_TYPE do_update_alias_table(DYN
 							fprintf(fp,"%ld", time (NULL));
 							fclose(fp);
 						}
+					#else
+						if ((fp=fopen(p_self->file_cache, "w")))
+						{
+							fprintf(fp,"%ld,%s\n", time (NULL), p_self->info[i].my_ip_address.name);
+							fclose(fp);
+						}
+					#endif
 						if (strlen(p_self->external_command) > 0)
 							os_shell_execute(p_self->external_command);
 					}
@@ -670,12 +677,20 @@ RC_TYPE get_default_config_data(DYN_DNS_
 		p_self->forced_update_period_sec = DYNDNS_MY_FORCED_UPDATE_PERIOD_S;
 		p_self->forced_update_period_sec_orig = DYNDNS_MY_FORCED_UPDATE_PERIOD_S;
 #ifdef UNIX_OS
+	#ifndef USE_CACHE_FILE
 		sprintf(p_self->ip_cache, "%s%s", DYNDNS_DEFAULT_CACHE_PREFIX, DYNDNS_DEFAULT_IP_FILE);
 		sprintf(p_self->time_cache, "%s%s", DYNDNS_DEFAULT_CACHE_PREFIX, DYNDNS_DEFAULT_TIME_FILE);
+	#else
+		sprintf(p_self->file_cache, "%s%s", DYNDNS_DEFAULT_CACHE_PREFIX, DYNDNS_DEFAULT_CACHE_FILE);
+        #endif
 #endif
 #ifdef _WIN32
+	#ifndef USE_CACHE_FILE
 		sprintf(p_self->ip_cache, "%s", DYNDNS_DEFAULT_IP_FILE);
 		sprintf(p_self->time_cache, "%s", DYNDNS_DEFAULT_TIME_FILE);
+	#else
+		sprintf(p_self->file_cache, "%s", DYNDNS_DEFAULT_CACHE_FILE);
+	#endif
 #endif
 		/*update period*/
 		p_self->sleep_sec = DYNDNS_DEFAULT_SLEEP;
@@ -1159,6 +1174,7 @@ int dyn_dns_main(DYN_DNS_CLIENT *p_dyndn
 
     dyn_dns_print_hello(NULL);
 
+#ifndef USE_CACHE_FILE
     if ((fp=fopen(p_dyndns->ip_cache, "r")))
     {
 	if (!fgets (p_dyndns->info[0].my_ip_address.name, sizeof (p_dyndns->info[0].my_ip_address.name),fp)) {
@@ -1167,6 +1183,18 @@ int dyn_dns_main(DYN_DNS_CLIENT *p_dyndn
 	fclose(fp);
 	DBG_PRINTF((LOG_INFO, MODULE_TAG "IP read from cache file is '%s'. No update required.\n", p_dyndns->info[0].my_ip_address.name));
     }
+#else
+    if ((fp=fopen(p_dyndns->file_cache, "r")))
+    {
+	int dif;
+
+	if (fscanf(fp, "%ld,%16s", &dif, p_dyndns->info[0].my_ip_address.name) < 2) {
+		DBG_PRINTF((LOG_WARNING,"DYNDNS: Error reading IP from cache\n"));
+	}
+	fclose(fp);
+	DBG_PRINTF((LOG_INFO, MODULE_TAG "IP read from cache file is '%s'. No update required.\n", p_dyndns->info[0].my_ip_address.name));
+    }
+#endif
 
 	/* the real work here */
 	do
diff -BurpN inadyn.orig/src/inadyn_cmd.c inadyn/src/inadyn_cmd.c
--- inadyn.orig/src/inadyn_cmd.c	2010-07-11 10:09:26.000000000 +0000
+++ inadyn/src/inadyn_cmd.c	2010-07-11 12:51:24.000000000 +0000
@@ -70,7 +70,11 @@ static RC_TYPE set_syslog_handler(CMD_DA
 static RC_TYPE set_change_persona_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE print_version_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_exec_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+#ifndef USE_CACHE_FILE
 static RC_TYPE get_cache_dir(CMD_DATA *p_cmd, int current_nr, void *p_context);
+#else
+static RC_TYPE get_cache_file(CMD_DATA *p_cmd, int current_nr, void *p_context);
+#endif
 
 static CMD_DESCRIPTION_TYPE cmd_options_table[] = 
 {
@@ -137,7 +141,11 @@ static CMD_DESCRIPTION_TYPE cmd_options_
 	{"--change_persona", 1, {set_change_persona_handler, NULL}, "after init switch to a new user/group. Parameters: <uid[:gid]> to change to. Works on **NIX systems only."},
 	{"--version", 0, {print_version_handler, NULL}, "print the version number\n"},
 	{"--exec", 1, {get_exec_handler, NULL}, "external command to exec after an IP update. Include the full path."},
+#ifndef USE_CACHE_FILE
 	{"--cache_dir", 1, {get_cache_dir, NULL}, "cache directory name. (e.g. /tmp/ddns). Defaults to /tmp on **NIX systems."},
+#else
+	{"--cache_file", 1, {get_cache_file, NULL}, "cache file name. (e.g. /tmp/ddns.cache). Defaults to /tmp/inadyn.cache."},
+#endif
 	{"--wildcard", 0, {wildcard_handler, NULL}, "enable domain wildcarding for dyndns.org, 3322.org, or easydns.com."},
 	{NULL,		0,	{0, NULL},	NULL }
 };
@@ -624,6 +632,7 @@ static RC_TYPE get_exec_handler(CMD_DATA
 	return RC_OK;
 }
 
+#ifndef USE_CACHE_FILE
 static RC_TYPE get_cache_dir(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -640,6 +649,23 @@ static RC_TYPE get_cache_dir(CMD_DATA *p
 	sprintf(p_self->time_cache, "%s/%s", p_cmd->argv[current_nr], DYNDNS_DEFAULT_TIME_FILE);
 	return RC_OK;
 }
+#else
+static RC_TYPE get_cache_file(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	if (sizeof(p_self->file_cache) < strlen(p_cmd->argv[current_nr]))
+	{
+		return  RC_DYNDNS_BUFFER_TOO_SMALL;
+	}
+	sprintf(p_self->file_cache, "%s", p_cmd->argv[current_nr]);
+	return RC_OK;
+}
+#endif
 
 /** 
     Searches the DYNDNS system by the argument.
@@ -985,7 +1011,9 @@ RC_TYPE get_config_data(DYN_DNS_CLIENT *
 	int i;
 	RC_TYPE rc = RC_OK;
 	FILE *fp;
+#ifndef USE_CACHE_FILE
 	char cached_time[80];
+#endif
 	int dif;
 	
 	do
@@ -1082,6 +1110,7 @@ RC_TYPE get_config_data(DYN_DNS_CLIENT *
 			break;
 		}
 		/*forced update*/
+		#ifndef USE_CACHE_FILE
 		if ((fp=fopen(p_self->time_cache, "r")))
 		{
 			if (!fgets(cached_time, sizeof (cached_time), fp))
@@ -1092,6 +1121,18 @@ RC_TYPE get_config_data(DYN_DNS_CLIENT *
 			dif = time(NULL) - atoi(cached_time);
 			p_self->forced_update_period_sec -= dif;
 		}
+		#else
+		if ((fp=fopen(p_self->file_cache, "r")))
+		{
+			if (fscanf(fp, "%ld,", &dif) < 1)
+			{
+				DBG_PRINTF((LOG_WARNING,"I: Could not read cached time\n"));
+			}
+			fclose(fp);
+			dif = time(NULL) - dif;
+			p_self->forced_update_period_sec -= dif;
+		}
+		#endif
 		p_self->times_since_last_update = 0;
 		p_self->forced_update_times = p_self->forced_update_period_sec / p_self->sleep_sec;
 
