--- linux/arch/mips/bcm947xx/irq.c	2007-03-20 15:20:31.000000000 +0300
+++ linux.5354/arch/mips/bcm947xx/irq.c	2007-10-22 08:14:04.000000000 +0400
@@ -62,6 +62,7 @@
 
 #include <typedefs.h>
 #include <osl.h>
+#include <bcmutils.h>
 #include <sbconfig.h>
 #include <sbutils.h>
 #include <hndcpu.h>
@@ -272,10 +273,11 @@
 	 * after processing all pending interrupts.
 	 */
 	for (irq = 2; irq < NUM_IRQS && ipvec != 0; irq ++) {
+		if (ipvec & 1) {
 		kstat.irqs[cpu][irq]++;
-		action = irq_desc[irq].action;
-		if (action && (ipvec & 1))
+			if ((action = irq_desc[irq].action))
 			handle_IRQ_event(irq, regs, action);
+		}
 		ipvec >>= 1;
 	}
 	set_c0_status(pending);
--- linux/arch/mips/bcm947xx/pcibios.c	2006-11-06 01:19:44.000000000 +0300
+++ linux.5354/arch/mips/bcm947xx/pcibios.c	2007-09-29 01:14:42.000000000 +0400
@@ -185,10 +181,8 @@
 			d->irq = irq + 2;
 			pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
 		}
-	}
-
+	} else {
 	/* Fix up external PCI */
-	else {
 		for (ln = b->devices.next; ln != &b->devices; ln = ln->next) {
 			d = pci_dev_b(ln);
 			/* Fix up resource bases */
@@ -214,6 +208,7 @@
 				d->irq = (pci_find_device(VENDOR_BROADCOM, SB_PCI, NULL))->irq;
 			pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
 		}
+		sbpci_arb_park(sbh, PCI_PARK_NVRAM);
 	}
 }
 
@@ -307,8 +339,31 @@
 	 */
 	else if (sb_coreid(sbh) == SB_USB20H) {
 		if (!sb_iscoreup(sbh)) {
+			
+			uint32 tmp;
+			
 			sb_core_reset(sbh, 0, 0);
-			writel(0x7FF, (ulong)regs + 0x200);
+			writel(0x7ff, (uintptr)regs + 0x200);
+
+			/* Change Flush control reg */
+			tmp = readl((uintptr)regs + 0x400);
+			tmp &= ~8;
+			writel(tmp, (uintptr)regs + 0x400);
+
+			/* Change Shim control reg */
+			tmp = readl((uintptr)regs + 0x304);
+			tmp &= ~0x100;
+			writel(tmp, (uintptr)regs + 0x304);
+                        
+			/* Change Syn01 reg */
+			tmp = 0x00fe00fe;
+   			writel(tmp, (uintptr)regs + 0x894);
+
+			/* Change Syn03 reg */
+			tmp = readl((uintptr)regs + 0x304);
+			tmp |= 0x1;
+  			writel(tmp, (uintptr)regs + 0x89c);
+
 			udelay(1);
 		}
 	} else
--- linux/arch/mips/bcm947xx/time.c	2006-11-06 01:19:44.000000000 +0300
+++ linux.5354/arch/mips/bcm947xx/time.c	2007-09-29 01:14:42.000000000 +0400
@@ -24,10 +24,12 @@
 #include <bcmnvram.h>
 #include <sbconfig.h>
 #include <sbextif.h>
+#include <sbchipc.h>
 #include <sbutils.h>
 #include <hndmips.h>
 #include <mipsinc.h>
 #include <hndcpu.h>
+#include <bcmdevs.h>
 
 /* Global SB handle */
 extern void *bcm947xx_sbh;
@@ -56,6 +56,10 @@
 	write_c0_count(0);
 	write_c0_compare(0xffff);
 
+	/* 5354 could run both on 200 & 240 Mhz -- use nvram setting */
+	if (sb_chip(sbh) == BCM5354_CHIP_ID && nvram_match("clkfreq", "200"))
+		hz = 200000000;
+	else
 	if (!(hz = sb_cpu_clock(sbh)))
 		hz = 100000000;
 
@@ -114,8 +108,12 @@
 	timer_interrupt(irq, dev_id, regs);
 
 	/* Set the watchdog timer to reset after the specified number of ms */
-	if (watchdog > 0)
+	if (watchdog > 0) {
+		if (sb_chip(sbh) == BCM5354_CHIP_ID)
+			sb_watchdog(sbh, WATCHDOG_CLOCK_5354 / 1000 * watchdog);
+		else
 		sb_watchdog(sbh, WATCHDOG_CLOCK / 1000 * watchdog);
+	}
 
 #ifdef	CONFIG_HWSIM
 	(*((int *)0xa0000f1c))++;
--- linux/arch/mips/bcm947xx/nvram_linux.c	2008-03-16 21:52:30.000000000 +0300
+++ linux.5354/arch/mips/bcm947xx/nvram_linux.c	2007-09-29 01:14:42.000000000 +0400
@@ -284,6 +284,12 @@
 }
 
 int
+nvram_init(void *sbh)
+{
+	return 0;
+}
+
+int
 nvram_set(const char *name, const char *value)
 {
 	unsigned long flags;
@@ -667,6 +673,7 @@
 	int order = 0, ret = 0;
 	struct page *page, *end;
 	unsigned int i;
+	osl_t *osh;
 
 	/* Allocate and reserve memory to mmap() */
 	while ((PAGE_SIZE << order) < NVRAM_SPACE)
@@ -702,6 +709,15 @@
 		goto err;
 	}
 
+	if (sb_osh(sbh) == NULL) {
+		osh = osl_attach(NULL, SB_BUS, FALSE);
+		if (osh == NULL) {
+			printk("Error allocating osh\n");
+			goto err;
+		}
+		sb_setosh(sbh, osh);
+	}
+
 	/* Initialize hash table */
 	_nvram_init(sbh);
 
